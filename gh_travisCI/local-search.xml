<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Ubuntu 出现 Unable to mkstemp 等问题解决</title>
    <link href="/2022/10/19/ubuntu-error-unable-to-mkstemp/"/>
    <url>/2022/10/19/ubuntu-error-unable-to-mkstemp/</url>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在使用 WSL Ubuntu 进行软件更新或软件下载时，出现如下问题：</p><div class="code-wrapper"><pre><code class="hljs bash">$ sudo apt install xxx[sudo] password <span class="hljs-keyword">for</span> xxxxxx:Reading package lists... Error!E: Unable to mkstemp /tmp/clearsigned.message.r1RilL - GetTempFile (20: Not a directory)E: The package lists or status file could not be parsed or opened.</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash">$ sudo apt updateE: Unable to mkstemp /tmp/clearsigned.message.u1lbd8 - GetTempFile (20: Not a directory)E: The package lists or status file could not be parsed or opened.</code></pre></div><p>造成软件更新或下载失败。</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>想起之前在这 ubuntu 做使用，看到 <code>/tmp</code> 非空，且了解到：</p><blockquote><p>&#x2F;tmp&#x2F;    存储系统和用户的临时信息。<br>就想着删除 <code>/tmp</code> 目录下的内容，于是直接动手。</p></blockquote><p>然而，删除完后， <code>/tmp</code> 目录就在是出问题：</p><div class="code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /tmp-bash: <span class="hljs-built_in">cd</span>: /tmp: Not a directory$ <span class="hljs-built_in">mkdir</span> -p /tmp<span class="hljs-built_in">mkdir</span>: cannot create directory ‘/tmp’: File exists</code></pre></div><p>刚开始没当回事，以为重启就没事，也就没在乎。</p><p>哪知过几天再来使用 ubuntu 时，更新或下载软件时出现上述问题。</p><p>然后开始询问度娘，搜索到“误删 <code>/tmp</code> 目录”等等的解决方法。</p><p><strong>思路很简单，就是删除 &#x2F;tmp 再重新创建 &#x2F;tmp。</strong></p><p><strong>命令如下：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">sudo <span class="hljs-built_in">rm</span> -r /tmpsudo <span class="hljs-built_in">mkdir</span> /tmp</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BLog</tag>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Git 时网络问题（代理）解决</title>
    <link href="/2022/09/06/git-proxy-error/"/>
    <url>/2022/09/06/git-proxy-error/</url>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>使用 git 命令执行与 github 相关命令失败的错误提示，如下：</p><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-comment">## station one</span>OpenSSL SSL_read: Connection was reset, errno <span class="hljs-number">10054</span><span class="hljs-comment">## station two</span>Failed to connect to github.com port <span class="hljs-number">443</span> after <span class="hljs-number">21098</span> ms: Timed out</code></pre></div><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>简而言之，github 被墙，走代理，然而设置不正确。</p><p>修改一下就好。</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>执行下述命令（根据自身情况做适当修改）：</p><div class="code-wrapper"><pre><code class="hljs powershell">git config <span class="hljs-literal">--global</span> <span class="hljs-literal">--unset</span> socks5.proxygit config <span class="hljs-literal">--global</span> socks5.proxy <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:xxxx<span class="hljs-comment">### xxxx 为端口号</span></code></pre></div><div class="note note-primary">            <p>没法解决问题的话，就得对症下药，如 DNS 问题就干嘛干嘛之类的。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>水博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更改终端显示语言</title>
    <link href="/2022/07/26/console-lang=en/"/>
    <url>/2022/07/26/console-lang=en/</url>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>将 linux (arch) 的语言设置为中文后，不仅是显示语言成功设置为中文，就连终端的显示（提示）语言也是中文，使用起来，总有种奇怪的感觉，觉得奇怪是因为习惯了全英文的终端显示。</p><p>所以想要将终端显示设置回英文。</p><p>经过多番搜索后，终于找到一个不错的解决方案。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><p><strong>打开终端</strong></p></li><li><p><strong>使用命令 <code>echo $0</code> 或是 <code>echo $SHELL</code> 查看当前使用的 <code>Shell</code>：</strong></p> <div class="code-wrapper"><pre><code class="hljs bash">xxxx@xxxxx: ~$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$0</span>/bin/bash</code></pre></div> <div class="code-wrapper"><pre><code class="hljs bash">xxxx@xxxxx: ~$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$SHELL</span>/bin/bash</code></pre></div><blockquote><p>一般 <code>shell</code> 类型：<code>bash</code>、<code>zsh</code>。</p></blockquote></li><li><p><strong>使用编辑器打开配置文件</strong><br> 编辑器可选取：<code>Vim</code>、<code>nano</code>。<br> <code>bash</code> 的（用户）配置文件：<code>.bashrc</code> 或是 <code>.bash_profile</code></p><blockquote><p>编辑任一即可<br><code>zsh</code> 的（用户）配置文件：<code>.zshrc</code></p></blockquote><p> 输入命令编辑器打开配置文件：</p> <div class="code-wrapper"><pre><code class="hljs bash">nano ~/.bashrc</code></pre></div></li><li><p><strong>编辑配置文件</strong><br> 在文件中加入下述内容：</p> <div class="code-wrapper"><pre><code class="hljs txt">if [ &quot;$TERM&quot;=&quot;linux&quot; ] ;then export LANG=en_US.UTF-8 export LANGUAGE=en_US fi</code></pre></div><p> 保存。</p></li><li><p><strong>使配置文件生效</strong></p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc</code></pre></div><blockquote><p><code>zsh</code> 的配置文件生效命令同理。</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>console</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Gurb 进行多系统引导，并使用主题美化 Grub 界面</title>
    <link href="/2022/07/24/linux-gurb-beauty/"/>
    <url>/2022/07/24/linux-gurb-beauty/</url>
    
    <content type="html"><![CDATA[<p>咕咕咕，开始。</p><div class="note note-primary">            <p><strong>2022-07-24</strong> 更新：简单记录一下，未能添加前后对比图</p>          </div><h3 id="更改-Deepin-的系统引导为-grub"><a href="#更改-Deepin-的系统引导为-grub" class="headerlink" title="更改 Deepin 的系统引导为 grub"></a>更改 Deepin 的系统引导为 grub</h3><ol><li><p><code>ctrl + alt + T</code> 打开终端，查看 <code>efi</code> 的挂载点</p> <div class="code-wrapper"><pre><code class="hljs bash">lsblk<span class="hljs-comment"># 查看 /boot/efi 的挂载点 </span></code></pre></div><p> 查询到 <code>/boot/efi</code> 的挂载点是：<code>/dev/sda1</code></p></li><li><p>安装 <code>grub</code> 到 <code>efi</code> 挂载点</p><div class="code-wrapper"><pre><code class="hljs bash">sudo grub-install /dev/sda1</code></pre></div><blockquote><p>安装成功时会提示下述内容：<br>Installation finished. No error reported.<br>若是中文界面的终端：<br>安装完成。没有错错误报告。</p></blockquote></li></ol><h3 id="美化-grub-引导界面"><a href="#美化-grub-引导界面" class="headerlink" title="美化 grub 引导界面"></a>美化 grub 引导界面</h3><h4 id="下载个人所喜欢的主题"><a href="#下载个人所喜欢的主题" class="headerlink" title="下载个人所喜欢的主题"></a>下载个人所喜欢的主题</h4><p>主题网站：<a href="https://www.gnome-look.org/browse?cat=109&ord=rating">GMOME-LOOK.ORG | GRUB THEME</a></p><p>个人选择了 <code>Vimix</code> 主题。主题路径：<a href="https://www.gnome-look.org/p/1009236">Grub-theme-vimix</a></p><blockquote><p>部分主题拥有适用于不同分辨率显示屏的版本，鉴于个人机器的硬件水平酌情选择，如：<br><code>1080p</code>、<code>4k</code>、<code>2k</code>。</p></blockquote><p>下载方式：</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220724221058.png"></p><p>或是：</p><p>点击 <code>files</code>，再选择对应分辨率的文件。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220724221532.png"></p><h4 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h4><ol><li><p>解压主题：</p><ul><li>使用命令行解压：   <div class="code-wrapper"><pre><code class="hljs bash">tar -Jxf Vimix-1080p.tar.xz<span class="hljs-comment"># tar -Jxf Vimix-2k.tar.xz</span><span class="hljs-comment"># tar -Jxf Vimix-4k.tar.xz</span></code></pre></div> 选择合适的命令解压。</li><li>使用文件系统解压。</li></ul></li><li><p>放置主题文件<br>将解压出来的主题文件放置到系统的 <code>grub</code> 主题文件中去。</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs bash">sudo <span class="hljs-built_in">cp</span> Vimix /usr/share/grub/themes/Vimix -rf</code></pre></div><blockquote><p>上述命令执行时，<strong>所在的路径为 Vimix 文件夹所在路径</strong>。</p></blockquote></li><li><p>修改系统配置</p><p> 编辑 grub 文件。</p> <div class="code-wrapper"><pre><code class="hljs bash">sudo nano /etc/default/grub</code></pre></div><blockquote><p>根据个人喜好选择编辑器如，nano、vim。</p></blockquote><p> 然后修改 GRUB_THEME，这是 grub 的主题设置，默认注释掉。<br> 直接插入一行代码：<br> <div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">GRUB_THEME</span>=<span class="hljs-string">&quot;/usr/share/grub/themes/vimix/theme.txt&quot;</span></code></pre></div></p><blockquote><p>修改了引号中的路径，指向我们自定的主题文件的 <code>theme.txt</code>。</p></blockquote></li></ol><h4 id="更新-grub-cfg-文件"><a href="#更新-grub-cfg-文件" class="headerlink" title="更新 grub.cfg 文件"></a>更新 <code>grub.cfg</code> 文件</h4><p>执行命令更新 <code>grub.cfg</code> 文件，使我们上述所作的设置生效。</p><div class="code-wrapper"><pre><code class="hljs bash">sudo update-grub</code></pre></div><h3 id="重启查看效果"><a href="#重启查看效果" class="headerlink" title="重启查看效果"></a>重启查看效果</h3><p>执行命令命令重启电脑：</p><div class="code-wrapper"><pre><code class="hljs bash">sudo reboot</code></pre></div><p>或是可视化的点点点，重启电脑。</p>]]></content>
    
    
    <categories>
      
      <category>Archlinux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Deepin</tag>
      
      <tag>Grub</tag>
      
      <tag>Beauty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好东西就记录下来</title>
    <link href="/2022/07/12/good-skills-record/"/>
    <url>/2022/07/12/good-skills-record/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p><strong>2022-07-12</strong> 更新</p>          </div><h3 id="PowerShell-获取系统时间"><a href="#PowerShell-获取系统时间" class="headerlink" title="PowerShell 获取系统时间"></a>PowerShell 获取系统时间</h3><blockquote><p>人懒不想每次写博文、更新博文时手敲日期和时间，就想偷懒，使用命令行格式化输出想要的时间。</p></blockquote><blockquote><p>较多使用 Windows 系统，因为使用 PowerShell 获取时间。</p></blockquote><p><strong>基础命令</strong>：</p><ul><li><code>Get-Date</code>: 获取当前<strong>时间</strong></li><li><code>Get-Date -Format &#39;yyyy&#39;</code>: 获取当前<strong>年份</strong></li><li><code>Get-Date -Format &#39;MM&#39;</code>: 获取当前<strong>月份</strong></li><li><code>Get-Date -Format &#39;dd&#39;</code>: 获取当前<strong>日</strong></li><li><code>Get-Date -Format &#39;HH&#39;</code>: 获取当前<strong>时</strong>（24 小时制）</li><li><code>Get-Date -Format &#39;hh&#39;</code>: 获取当前<strong>时</strong>（12 小时制）</li><li><code>Get-Date -Format &#39;mm&#39;</code>: 获取当前<strong>分</strong></li><li><code>Get-Date -Format &#39;ss&#39;</code>: 获取当前<strong>秒</strong></li></ul><p><span style="color: #02b2ff; ">自由组合一下获得格式化的日期或者时间：</span></p><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">Get-Date</span> <span class="hljs-literal">-Format</span> <span class="hljs-string">&#x27;yyyy-MM-dd&#x27;</span><span class="hljs-comment"># 2022-07-12</span><span class="hljs-built_in">Get-Date</span><span class="hljs-comment"># 2022年7月12日 17:47:14</span><span class="hljs-built_in">Get-Date</span> <span class="hljs-literal">-Format</span> <span class="hljs-string">&#x27;HH:mm:ss&#x27;</span><span class="hljs-comment"># 17:47:56</span><span class="hljs-built_in">Get-Date</span> <span class="hljs-literal">-Format</span> <span class="hljs-string">&#x27;yyyy-MM-dd HH:mm:ss&#x27;</span><span class="hljs-comment"># 2022-07-12 17:48:25</span><span class="hljs-built_in">Get-Date</span> <span class="hljs-literal">-Format</span> <span class="hljs-string">&#x27;yyyy年M月dd日 HH时mm分ss秒&#x27;</span><span class="hljs-comment"># 2022年7月12日 17时52分42秒</span></code></pre></div><p>但是每次获取格式化时间时都需要输入这么多字符也很麻烦，那就使用 alias：</p><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Function now &#123;get-date -format &quot;yyyy-MM-d HH:mm:ss&quot;&#125;&#x27;</span> &gt;&gt; <span class="hljs-variable">$profile</span></code></pre></div><blockquote><p>意思就是，将 <code>Function now &#123;get-date -format &quot;yyyy-MM-d HH:mm:ss&quot;&#125;</code> 追加到 <code>$PROFILE</code> 文件里。<br>上述命令含义是：<code>now</code> 代替 <code>get-date -format &quot;yyyy-MM-d HH:mm:ss&quot;</code>。<br>二者效果相同。</p></blockquote><p>然后： </p><div class="code-wrapper"><pre><code class="hljs powershell">now<span class="hljs-comment"># 2022-07-12 18:01:15</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Skills</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Visual Studio Code 插件使用记录</title>
    <link href="/2022/07/12/vscode-plugins/"/>
    <url>/2022/07/12/vscode-plugins/</url>
    
    <content type="html"><![CDATA[<h3 id="更新情况"><a href="#更新情况" class="headerlink" title="更新情况"></a>更新情况</h3><div class="note note-primary">            <p><strong>2022-07-12</strong> 更新：</p><ul><li>添加 <span class="label label-info"><a href="#C-C-Plugins" title="vs code C\C++插件">C\C++ Plugins</a></span>：<span class="label label-default"><a href="#1-C-C">C\C++</a></span>、<span class="label label-default"><a href="#2-C-x2F-C-Extension-Pack">C&#x2F;C++ Extension Pack</a></span></li><li>添加 <span class="label label-info"><a href="#美化" title="vs code 美化插件">美化</a></span>：<span class="label label-default"><a href="#2-One-Dark-Pro">One Dark Pro</a></span>、<span class="label label-default"><a href="#1-Beauty">Beauty</a></span></li><li>添加 <span class="label label-info"><a href="#汉化" title="vs code 汉化插件">汉化</a></span>：<span class="label label-default"><a href="#Chinese-Simplified-简体中文-Language-Pack-for-Visual-Studio">Chinese (Simplified) (简体中文) Language Pack for Visual Studio</a></span></li><li>添加 <span class="label label-info"><a href="#Markdown" title="vs code 汉化插件">Markdown</a></span>：<span class="label label-default"><a href="#1-Markdown-All-in-One">Markdown All in One</a></span>、<span class="label label-default"><a href="#2-Markdown-PDF">Markdown PDF</a></span></li><li>添加 <span class="label label-info"><a href="#Python" title="vs code python 插件">Python</a></span>：<span class="label label-default"><a href="#1-Python">Python</a></span>、<span class="label label-default"><a href="#2-Pylance">Pylance</a></span></li></ul>          </div><div class="note note-primary">            <p><strong>2022-07-16</strong> 更新：</p><ul><li><span class="label label-info">美化</span> 添加：<span class="label label-default"><a href="#2-Material-Icon-Theme">Material Icon Theme</a></span>、<span class="label label-default"><a href="#3-vscode-icons">vscode-icons</a></span></li><li>添加 <span class="label label-info"><a href="#前端" title="vs code 前端插件">前端</a></span>：<span class="label label-default"><a href="#1-Live-Server">Live Server</a></span>、<span class="label label-default"><a href="#2-Auto-Complete-Tag">Auto Complete Tag</a></span>、<span class="label label-default"><a href="#3-Auto-Rename-Tag">Auto Rename Tag</a></span>、<span class="label label-default"><a href="#4-Auto-Close-Tag">Auto Close Tag</a></span>、<span class="label label-default"><a href="#5-CSS-Peek">CSS Peek</a></span>、<span class="label label-default"><a href="#6-HTML-CSS-Support">HTML CSS Support</a></span></li><li>添加 <span class="label label-info"><a href="#高效率工具" title="vs code 高效率工具插件">高效率工具</a></span>：<span class="label label-default"><a href="#1-Path-Intellisense">Path Intellisense</a></span>、<span class="label label-default"><a href="#2-Bracket-Pair-Colorization-Toggler">Bracket Pair Colorization Toggler</a></span></li></ul>          </div><h3 id="C-C-Plugins"><a href="#C-C-Plugins" class="headerlink" title="C\C++ Plugins"></a>C\C++ Plugins</h3><div class="note note-info">            <p>关于 windows 下 VS code C\C++ 环境的配置：<a class="btn" href="https://muxiner.github.io/2022/04/19/vscode-env-c-new/#"  target="_blank">Windows 下 VS code 配置 C&#x2F;C++ 环境</a></p>          </div><h4 id="1-C-C"><a href="#1-C-C" class="headerlink" title="1. C\C++"></a>1. C\C++</h4><p><a id='C\C++'></a></p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220712185147.png"></p><p>C&#x2F;C++ 扩展为 Visual Studio Code 添加了对 C&#x2F;C++ 的语言支持，包括 IntelliSense 和调试等功能。</p><blockquote><p>是在 vs code 上面使用 C\C++ 的必要插件。</p></blockquote><h4 id="2-C-x2F-C-Extension-Pack"><a href="#2-C-x2F-C-Extension-Pack" class="headerlink" title="2. C&#x2F;C++ Extension Pack"></a>2. C&#x2F;C++ Extension Pack</h4><p><a id='C/C++Extension-Pack'></a></p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220712185921.png"></p><p>此扩展包包括一组用于 Visual Studio Code 中 C++ 开发的流行扩展。</p><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C&#x2F;C++</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools-themes">C&#x2F;C++ Themes</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=twxs.cmake">CMake</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools">CMake Tools</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=cschlosser.doxdocgen">Doxygen Documentation Generator</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=jeff-hykin.better-cpp-syntax">Better C++ Syntax</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack">Remote Development Extension Pack</a></li></ul><blockquote><p>推荐 C\C++ 插件的插件呀。</p></blockquote><h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><h3 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h3><h4 id="1-Beauty"><a href="#1-Beauty" class="headerlink" title="1. Beauty"></a>1. Beauty</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220712191137.png"></p><p>Beauty 是 Web 开发中 VSCODE 的代码美化器扩展。<br>它支持多种语言，如 javascript, css, less, python, jsx, markups(html, swig, nunjucks)…等。</p><blockquote><p>不格式化其他的编程语言吗。</p></blockquote><h4 id="2-One-Dark-Pro"><a href="#2-One-Dark-Pro" class="headerlink" title="2. One Dark Pro"></a>2. One Dark Pro</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220712191628.png"></p><p><code>Atom</code> 用于 <code>Visual Studio Code</code> 的标志性 <code>One Dark</code> 主题。</p><blockquote><p>很好看的主题呀。</p></blockquote><h4 id="2-Material-Icon-Theme"><a href="#2-Material-Icon-Theme" class="headerlink" title="2. Material Icon Theme"></a>2. Material Icon Theme</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220716174638.png"></p><p>Get the Material Design icons into your VS Code.</p><blockquote><p>这个图标还挺好看的呢。<br>想看清楚的图标的话，需要去官方的 <a href="https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme">MarketPlace</a> 看一看吧。</p></blockquote><h4 id="3-vscode-icons"><a href="#3-vscode-icons" class="headerlink" title="3. vscode-icons"></a>3. vscode-icons</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220716181801.png"></p><p>vscode 团队设计的图标库，还可以，但是在我看来，没上一个好看哦。</p><h3 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h3><h4 id="Chinese-Simplified-简体中文-Language-Pack-for-Visual-Studio"><a href="#Chinese-Simplified-简体中文-Language-Pack-for-Visual-Studio" class="headerlink" title="Chinese (Simplified) (简体中文) Language Pack for Visual Studio"></a>Chinese (Simplified) (简体中文) Language Pack for Visual Studio</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220712192229.png"></p><p>此中文（简体）语言包为 VS Code 提供本地化界面。</p><blockquote><p>英文不友好者狂喜插件。</p></blockquote><h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><h4 id="1-Markdown-All-in-One"><a href="#1-Markdown-All-in-One" class="headerlink" title="1. Markdown All in One"></a>1. Markdown All in One</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220712192533.png"></p><p><code>Visual Studio Code</code> 的 <code>Markdown</code> 支持。</p><blockquote><p>将 <code>vscode</code> 作为 <code>markdown</code> 编辑器的话就需要这个了。</p></blockquote><h4 id="2-Markdown-PDF"><a href="#2-Markdown-PDF" class="headerlink" title="2. Markdown PDF"></a>2. Markdown PDF</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220712192745.png"></p><p>此扩展将 <code>Markdown</code> 文件转换为 <code>pdf</code>、<code>html</code>、<code>png</code> 或 <code>jpeg</code> 文件。</p><blockquote><p>导出 <code>markdown</code> 文件需要的插件。</p></blockquote><div class="note note-info">            <p>如果导出文件时数学公式不正确，可见：<a class="btn" href="https://muxiner.github.io/2022/04/18/vscode-markdown-pdf-math-latex-error/"  target="_blank">VS code Markdown 导出 PDF 时，数学公式未能正确导出</a></p>          </div><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><h4 id="1-Python"><a href="#1-Python" class="headerlink" title="1. Python"></a>1. Python</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220712193331.png"></p><p><code>IntelliSense</code> (Pylance)、<code>Linting</code>、调试（多线程、远程）、<code>Jupyter Notebooks</code>、代码格式化、重构、单元测试。</p><blockquote><p>编辑 python 的必备插件呀。</p></blockquote><h4 id="2-Pylance"><a href="#2-Pylance" class="headerlink" title="2. Pylance"></a>2. Pylance</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220712193550.png"></p><p><code>VS Code</code> 中用于 <code>Python</code> 的高性能、功能丰富的语言服务器。</p><p><code>Pylance</code> 可与 <code>VScode</code> 中的 <code>Python</code> 插件一起使用的一个插件，以提供高性能的语言支持。<br>在后台，<code>Pylance</code> 由 <code>Microsoft</code> 的静态类型检查工具 <code>Pyright</code> 提供支持。 使用 <code>Pyright</code>，<code>Pylance</code> 可以为 <code>Python IntelliSense</code> 体验提供丰富的类型信息，从而帮助您更快地编写更好的代码。</p><p><code>Pylance</code> 名称是 <code>Monty Python</code> 的 <code>Lancelot</code> 的一个小颂歌，<code>Lancelot</code> 是第一个在圣杯中回答守门员问题的骑士。</p><p><strong>快速开始</strong></p><ol><li>安装 <code>Pylance</code> 扩展。<ol><li>打开一个 <code>Python（.py）</code>文件，<code>Pylance</code> 扩展名将被激活。</li></ol></li><li>当提示您将 <code>Pylance</code> 设置为默认语言服务器时，选择“是”。 这将更新您的首选项，也可以通过使用文本编辑器将“python.languageServer”：“ Pylance” 添加到 <code>settings.json</code> 文件中来手动进行。</li></ol><p><code>Pylance</code> 为 <code>Python 3</code> 提供了一些很棒的功能，包括：</p><ul><li>字串</li><li>签名帮助，带有类型信息</li><li>参数建议</li><li>代码补全</li><li>自动导入（以及添加和删除导入代码操作）</li><li>输入代码的时候报告代码错误和警告（诊断）</li><li>代码大纲</li><li>代码导航</li><li>类型检查模式</li><li>本地多个工作区支持</li><li><code>IntelliCode</code> 兼容性</li><li><code>Jupyter Notebooks</code> 兼容性</li><li>语法高亮</li></ul><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><h4 id="1-Live-Server"><a href="#1-Live-Server" class="headerlink" title="1. Live Server"></a>1. Live Server</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220716182133.png"></p><p>模拟本地服务器，编写完网页代码后保存，浏览器的页面情况将自动刷新，就无需在浏览器中刷新。</p><h4 id="2-Auto-Complete-Tag"><a href="#2-Auto-Complete-Tag" class="headerlink" title="2. Auto Complete Tag"></a>2. Auto Complete Tag</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220716184131.png"></p><p>同时拥有<strong>自动关闭标签</strong>和<strong>自动重命名标签</strong>的功能。</p><blockquote><p>就是下面两个插件的功能，要么安装该插件，要么安装下面两个插件。</p></blockquote><h4 id="3-Auto-Rename-Tag"><a href="#3-Auto-Rename-Tag" class="headerlink" title="3. Auto Rename Tag"></a>3. Auto Rename Tag</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220716183614.png"></p><p>自动重命名成对的 HTML&#x2F;XML 标记。</p><h4 id="4-Auto-Close-Tag"><a href="#4-Auto-Close-Tag" class="headerlink" title="4. Auto Close Tag"></a>4. Auto Close Tag</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220716183810.png"></p><p>自动添加 HTML&#x2F;XMl 关闭标记。</p><p>特征：</p><ul><li>键入开始标签的右括号时自动添加结束标签</li><li>插入结束标签后，光标在开始和结束标签之间</li><li>设置不自动关闭的标签列表</li><li>自动关闭自关闭标签</li><li>支持 <code>Sublime Text 3</code> 的自动关闭标签</li><li>使用键盘快捷键或命令面板手动添加关闭标签</li></ul><h4 id="5-CSS-Peek"><a href="#5-CSS-Peek" class="headerlink" title="5. CSS Peek"></a>5. CSS Peek</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220716184534.png"></p><p>快速跳到CSS的定义处预览。</p><p>特征：该扩展支持符号定义跟踪的所有正常功能，但它适用于 <code>css</code> 选择器（<code>类</code>、<code>ID</code> 和 <code>HTML</code> 标记）。这包括：</p><ul><li><code>Peek</code>：内联加载 <code>css</code> 文件并在此处进行快速编辑。( <code>Ctrl + Shift + F12</code> )</li><li><code>转到</code>：直接跳转到 <code>css</code> 文件或在新编辑器中打开它 (<code>F12</code>)</li><li><code>悬停</code>：悬停在符号 (<code>Ctrl + hover</code>)上显示定义</li></ul><h4 id="6-HTML-CSS-Support"><a href="#6-HTML-CSS-Support" class="headerlink" title="6. HTML CSS Support"></a>6. HTML CSS Support</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220716184901.png"></p><p>适用于 <code>HTML</code> 的 <code>Visual Studio Code CSS Intellisense</code>.</p><p>特征: </p><ul><li>完善 HTML <code>id</code> 和 <code>类</code>属性。</li><li>支持链接和嵌入的样式表。</li><li>支持模板继承。</li><li>支持其他样式表。</li><li>支持其他类似 <code>HTML</code> 的语言。</li><li>按需验证 <code>CSS</code> 选择器。</li></ul><p>用法: 可以通过 <code>ctrl + 空格</code> 查看 <code>id</code> 和 <code>类</code> 属性建议列表。</p><h3 id="高效率工具"><a href="#高效率工具" class="headerlink" title="高效率工具"></a>高效率工具</h3><h4 id="1-Path-Intellisense"><a href="#1-Path-Intellisense" class="headerlink" title="1. Path Intellisense"></a>1. Path Intellisense</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220716173750.png"></p><p>该插件支持自动提示文件路径，支持各种文件无脑快速引入。</p><h4 id="2-Bracket-Pair-Colorization-Toggler"><a href="#2-Bracket-Pair-Colorization-Toggler" class="headerlink" title="2. Bracket Pair Colorization Toggler"></a>2. Bracket Pair Colorization Toggler</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220716182853.png"></p><p>给不同区域的括号加上不同的颜色，加以区分。</p><p>仓库：<a href="https://github.com/dzhavat/bracket-pair-toggler">Bracket Pair Colorization Toggler</a></p>]]></content>
    
    
    <categories>
      
      <category>VS code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>记录</tag>
      
      <tag>Plugins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 下包管理器 Scoop 的安装与使用</title>
    <link href="/2022/05/30/using-scoop/"/>
    <url>/2022/05/30/using-scoop/</url>
    
    <content type="html"><![CDATA[<h3 id="🍉-什么是-Scoop"><a href="#🍉-什么是-Scoop" class="headerlink" title="🍉 什么是 Scoop"></a>🍉 什么是 Scoop</h3><blockquote><p>😶‍🌫️ 可以去看 <a href="https://github.com/ScoopInstaller/Scoop">Scoop Github 上的介绍</a>。</p><p>😶‍🌫️ 还有官方文档 <a href="https://github.com/ScoopInstaller/Scoop/wiki">Scoop Wiki</a></p><p>😶‍🌫️ 官网 <a href="https://scoop.sh/">Scoop.sh</a></p></blockquote><p><code>Scoop</code> 是 <code>Windows</code> 上的命令行安装工具。</p><p>🙈 可以用来干嘛？</p><p>🦥 通过命令行界面，<code>Scoop</code> 可以顺畅地安装应用程序。（官方说明）</p><ul><li>🌲 没有权限弹出窗口</li><li>🌲 隐藏 GUI 向导式安装程序</li><li>🌲 防止因而安装大量程序造成 PATH 污染</li><li>🌲 避免安装和卸载程序的不当使用</li><li>🌲 自动查找并安装依赖项</li><li>🌲 自动执行所有额外的设置步骤来获取工作程序</li></ul><h3 id="🍉-安装-Scoop"><a href="#🍉-安装-Scoop" class="headerlink" title="🍉 安装 Scoop"></a>🍉 安装 Scoop</h3><h4 id="🍊-准备工作"><a href="#🍊-准备工作" class="headerlink" title="🍊 准备工作"></a>🍊 准备工作</h4><ul><li><p><code>PowerShell</code> ：确保已安装 <code>PowerShell 5.0</code> 或更高版本。</p><blockquote><p><code>Windows 10</code> 以及更高的版本默认安装的 <code>PowerShell 5.0</code>。</p></blockquote></li><li><p>确保以允许 <code>Powershell</code> 执行本地脚本。</p><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">set-executionpolicy</span> remotesigned <span class="hljs-literal">-scope</span> currentuser</code></pre></div><blockquote><p><code>Unrestricted</code> 也可以，但是安全性较低。</p><p>最好使用 <code>RemoteSigned</code>。</p></blockquote></li></ul><h3 id="🍉-安装-Scoop-1"><a href="#🍉-安装-Scoop-1" class="headerlink" title="🍉 安装 Scoop"></a>🍉 安装 Scoop</h3><h4 id="🍑-安装在默认位置"><a href="#🍑-安装在默认位置" class="headerlink" title="🍑 安装在默认位置"></a>🍑 安装在默认位置</h4><p>默认安装在 <code>C:\Users\username\scoop</code> 路径下。</p><p>执行命令：</p><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">Invoke-Expression</span> (<span class="hljs-built_in">New-Object</span> System.Net.WebClient).DownloadString(<span class="hljs-string">&#x27;https://get.scoop.sh&#x27;</span>)</code></pre></div><p>或是执行（更短的）：</p><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">iwr</span> <span class="hljs-literal">-useb</span> get.scoop.sh | <span class="hljs-built_in">iex</span></code></pre></div><h4 id="🍑-自定义安装目录"><a href="#🍑-自定义安装目录" class="headerlink" title="🍑 自定义安装目录"></a>🍑 自定义安装目录</h4><p>例如将 <code>Scoop</code> 安装在 <code>C:\Scoop</code> 路径下。</p><p>需要添加该路径到<strong>用户变量</strong>中：</p><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-variable">$env:SCOOP</span>=<span class="hljs-string">&#x27;C:\scoop&#x27;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs powershell">[<span class="hljs-type">environment</span>]::setEnvironmentVariable(<span class="hljs-string">&#x27;SCOOP&#x27;</span>,<span class="hljs-variable">$env:SCOOP</span>,<span class="hljs-string">&#x27;User&#x27;</span>)</code></pre></div><blockquote><p>当然也可以添加到<strong>系统变量</strong>中：</p><p>不过此时需要以<strong>管理员身份</strong>运行 <code>PowerShell</code> ，或是以<strong>管理员身份</strong>运行 <code>Windows Terminal</code>，再打开 <code>PowerShell</code> ，否则会报错：</p><div class="code-wrapper"><pre><code class="hljs powershell">[<span class="hljs-type">environment</span>]::setEnvironmentVariable(<span class="hljs-string">&#x27;SCOOP&#x27;</span>,<span class="hljs-variable">$env:SCOOP</span>,<span class="hljs-string">&#x27;Machine&#x27;</span>)</code></pre></div></blockquote><blockquote><p><span style="color:red;">添加完环境变量后需要重启 PowerShell 或 Terminal 等待变量生效。</span></p></blockquote><p>然后再执行安装指令：</p><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">iwr</span> <span class="hljs-literal">-useb</span> get.scoop.sh | <span class="hljs-built_in">iex</span></code></pre></div><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/md_img/20220529150626.png"></p><blockquote><p>出现上图所示，且无错误提示，则安装成功。</p></blockquote><h4 id="🍑-自定义全局应用安装目录"><a href="#🍑-自定义全局应用安装目录" class="headerlink" title="🍑 自定义全局应用安装目录"></a>🍑 自定义全局应用安装目录</h4><p>例如自定义将全局应用安装在 <code>C:\apps</code> 路径下：</p><p>就需要将该目录添加到系统变量中，步骤同上文相同：</p><ol><li>😶‍🌫️ 以管理员身份运行</li><li>😶‍🌫️ <code>$env:SCOOP_GLOBAL=&#39;C:\apps&#39;</code></li><li>😶‍🌫️ <code>[environment]::setEnvironmentVariable(&#39;SCOOP_GLOBAL&#39;,$env:SCOOP_GLOBAL,&#39;Machine&#39;)</code></li><li>😶‍🌫️ 安装指令：<code>scoop install -g &lt;app&gt;</code></li></ol><p>合起来就是：</p><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-variable">$env:SCOOP_GLOBAL</span>=<span class="hljs-string">&#x27;C:\apps&#x27;</span>[<span class="hljs-type">environment</span>]::setEnvironmentVariable(<span class="hljs-string">&#x27;SCOOP_GLOBAL&#x27;</span>,<span class="hljs-variable">$env:SCOOP_GLOBAL</span>,<span class="hljs-string">&#x27;Machine&#x27;</span>)scoop install <span class="hljs-literal">-g</span> &lt;app&gt;</code></pre></div><h3 id="🍉-使用-Scoop"><a href="#🍉-使用-Scoop" class="headerlink" title="🍉 使用 Scoop"></a>🍉 使用 Scoop</h3><p>查看 scoop 的命令：</p><div class="code-wrapper"><pre><code class="hljs powershell">scoop help</code></pre></div><p>查看命令的详细信息：</p><div class="code-wrapper"><pre><code class="hljs powershell">scoop help &lt;command&gt;<span class="hljs-comment"># for example: scoop help install </span><span class="hljs-comment"># For more detailed information on INSTALL</span></code></pre></div><p>执行 <code>scoop help install </code>：</p><div class="code-wrapper"><pre><code class="hljs powershell">Usage: scoop install &lt;app&gt; [<span class="hljs-type">options</span>]e.g. The usual way to install an app (uses your local <span class="hljs-string">&#x27;buckets&#x27;</span>):     scoop install gitTo install an app from a manifest at a URL:     scoop install https://raw.githubusercontent.com/ScoopInstaller/Main/master/bucket/runat.jsonTo install an app from a manifest on your computer     scoop install \path\to\app.jsonOptions:  <span class="hljs-literal">-g</span>, <span class="hljs-literal">--global</span>              Install the app globally  <span class="hljs-literal">-i</span>, <span class="hljs-literal">--independent</span>         Don<span class="hljs-string">&#x27;t install dependencies automatically</span><span class="hljs-string">  -k, --no-cache            Don&#x27;</span>t use the download cache  <span class="hljs-literal">-u</span>, <span class="hljs-literal">--no-update-scoop</span>     Don<span class="hljs-string">&#x27;t update Scoop before installing if it&#x27;</span>s outdated  <span class="hljs-literal">-s</span>, <span class="hljs-literal">--skip</span>                Skip hash validation (use with caution!)  <span class="hljs-literal">-a</span>, <span class="hljs-literal">--arch</span> &lt;<span class="hljs-number">32</span>bit|<span class="hljs-number">64</span>bit&gt;  Use the specified architecture, <span class="hljs-keyword">if</span> the app supports it</code></pre></div><h4 id="🍒-安装应用"><a href="#🍒-安装应用" class="headerlink" title="🍒 安装应用"></a>🍒 安装应用</h4><p>分为两种情况：</p><h5 id="🫐-为当前用户安装"><a href="#🫐-为当前用户安装" class="headerlink" title="🫐 为当前用户安装"></a>🫐 为当前用户安装</h5><p>安装路径：<code>scoop\apps</code> </p><blockquote><p><code>scoop</code> 路径默认在 <code>C:\User\username</code> 。</p><p>若是自定义安装路径，例如上文的位置，则在 <code>C:\Scoop</code> </p></blockquote><p>安装命令：</p><div class="code-wrapper"><pre><code class="hljs powershell">scoop install &lt;app&gt;<span class="hljs-comment"># for example:</span><span class="hljs-comment"># scoop install nano</span></code></pre></div><h5 id="🫐-为所有用户安装"><a href="#🫐-为所有用户安装" class="headerlink" title="🫐 为所有用户安装"></a>🫐 为所有用户安装</h5><p>默认的安装路径：<code>C:\ProgramData\scoop</code></p><p>若是如上文所示，自定义了全局应用安装目录，则安装路径：<code>C:\apps</code></p><blockquote><p>需要以<strong>管理员身份</strong>运行。</p></blockquote><p>安装命令：</p><div class="code-wrapper"><pre><code class="hljs powershell">scoop install &lt;app&gt; <span class="hljs-literal">-g</span><span class="hljs-comment"># for example:</span><span class="hljs-comment"># scoop install nano -g</span></code></pre></div><h4 id="🍒-卸载应用"><a href="#🍒-卸载应用" class="headerlink" title="🍒 卸载应用"></a>🍒 卸载应用</h4><h5 id="🫐-卸载某一程序"><a href="#🫐-卸载某一程序" class="headerlink" title="🫐 卸载某一程序"></a>🫐 卸载某一程序</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop uninstall &lt;app&gt;</code></pre></div><h5 id="🫐-卸载程序并移除配置文件"><a href="#🫐-卸载程序并移除配置文件" class="headerlink" title="🫐 卸载程序并移除配置文件"></a>🫐 卸载程序并移除配置文件</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop uninstall &lt;app&gt; <span class="hljs-literal">-p</span></code></pre></div><h5 id="🫐-卸载全局程序"><a href="#🫐-卸载全局程序" class="headerlink" title="🫐 卸载全局程序"></a>🫐 卸载全局程序</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop uninstall &lt;app&gt; <span class="hljs-literal">-g</span></code></pre></div><h5 id="🫐-更多信息"><a href="#🫐-更多信息" class="headerlink" title="🫐 更多信息"></a>🫐 更多信息</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop help uninstall</code></pre></div><h4 id="🍒-更新"><a href="#🍒-更新" class="headerlink" title="🍒 更新"></a>🍒 更新</h4><h5 id="🫐-更新-scoop-及所有-bucket-但不更新-app"><a href="#🫐-更新-scoop-及所有-bucket-但不更新-app" class="headerlink" title="🫐 更新 scoop 及所有 bucket 但不更新 app"></a>🫐 更新 scoop 及所有 bucket 但不更新 app</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop update</code></pre></div><h5 id="🫐-更新某一-app"><a href="#🫐-更新某一-app" class="headerlink" title="🫐 更新某一 app"></a>🫐 更新某一 app</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop update &lt;app&gt;</code></pre></div><h5 id="🫐-更新-scoop、bucket、app"><a href="#🫐-更新-scoop、bucket、app" class="headerlink" title="🫐 更新 scoop、bucket、app"></a>🫐 更新 scoop、bucket、app</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop update *</code></pre></div><h5 id="🫐-更新全局-app"><a href="#🫐-更新全局-app" class="headerlink" title="🫐 更新全局 app"></a>🫐 更新全局 app</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop update &lt;app&gt; <span class="hljs-literal">-g</span></code></pre></div><h5 id="🫐-更多信息-1"><a href="#🫐-更多信息-1" class="headerlink" title="🫐 更多信息"></a>🫐 更多信息</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop help update</code></pre></div><h4 id="🍒-其他有用操作"><a href="#🍒-其他有用操作" class="headerlink" title="🍒 其他有用操作"></a>🍒 其他有用操作</h4><h5 id="🫐-查看已安装-app"><a href="#🫐-查看已安装-app" class="headerlink" title="🫐 查看已安装 app"></a>🫐 查看已安装 app</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop list</code></pre></div><h5 id="🫐-查看可更新-app"><a href="#🫐-查看可更新-app" class="headerlink" title="🫐 查看可更新 app"></a>🫐 查看可更新 app</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop status</code></pre></div><h5 id="🫐-查看某-app-主页"><a href="#🫐-查看某-app-主页" class="headerlink" title="🫐 查看某 app 主页"></a>🫐 查看某 app 主页</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop home &lt;app&gt;</code></pre></div><h5 id="🫐-查看「已知库」"><a href="#🫐-查看「已知库」" class="headerlink" title="🫐 查看「已知库」"></a>🫐 查看「已知库」</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop bucket known</code></pre></div><h5 id="🫐-添加「已知库」"><a href="#🫐-添加「已知库」" class="headerlink" title="🫐 添加「已知库」"></a>🫐 添加「已知库」</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop bucket add &lt;bucket&gt;</code></pre></div><h5 id="🫐-查看已添加的库"><a href="#🫐-查看已添加的库" class="headerlink" title="🫐 查看已添加的库"></a>🫐 查看已添加的库</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop bucket list</code></pre></div><h5 id="🫐-删除已添加的库"><a href="#🫐-删除已添加的库" class="headerlink" title="🫐 删除已添加的库"></a>🫐 删除已添加的库</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop bucket <span class="hljs-built_in">rm</span> &lt;bucket&gt;</code></pre></div><h5 id="🫐-添加第三方库"><a href="#🫐-添加第三方库" class="headerlink" title="🫐 添加第三方库"></a>🫐 添加第三方库</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop bucket add &lt;bucket&gt; &lt;bucket_url&gt;</code></pre></div><h5 id="🫐-删除已安装软件的旧版本"><a href="#🫐-删除已安装软件的旧版本" class="headerlink" title="🫐 删除已安装软件的旧版本"></a>🫐 删除已安装软件的旧版本</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop cleanup *</code></pre></div><h5 id="🫐-清理软件缓存"><a href="#🫐-清理软件缓存" class="headerlink" title="🫐 清理软件缓存"></a>🫐 清理软件缓存</h5><p>通常是下载的软件安装包。</p><p>以下命令清除所有缓存，即清空 <code>Scoop</code> 目录下的 <code>cache</code> 文件夹。</p><div class="code-wrapper"><pre><code class="hljs powershell">scoop cache <span class="hljs-built_in">rm</span> *</code></pre></div><h3 id="🍉-进阶"><a href="#🍉-进阶" class="headerlink" title="🍉 进阶"></a>🍉 进阶</h3><p>更多信息请查看 <a href="https://github.com/ScoopInstaller/Scoop/wiki">官方文档</a>。</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>记录</tag>
      
      <tag>software</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学笔记 —— 支配集、覆盖集、独立集与匹配</title>
    <link href="/2022/05/27/discrete-mathematics-set-knowledge/"/>
    <url>/2022/05/27/discrete-mathematics-set-knowledge/</url>
    
    <content type="html"><![CDATA[<p style="text-align:center;color:#ff6444;font-size:1.5em;font-weight: bold;">由于没法很好的渲染出复杂的数学公式，选择了直接贴图</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/math_img/set.png"></p>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学笔记 —— 有向图的连通性</title>
    <link href="/2022/05/27/discrete-mathematics-graph-connectivity/"/>
    <url>/2022/05/27/discrete-mathematics-graph-connectivity/</url>
    
    <content type="html"><![CDATA[<p style="text-align:center;color:#ff6444;font-size:1.5em;font-weight: bold;">由于没法很好的渲染出复杂的数学公式，选择了直接贴图</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/math_img/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7.png"></p>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学笔记 —— 图的矩阵表示</title>
    <link href="/2022/05/27/discrete-mathematics-graph-matrix/"/>
    <url>/2022/05/27/discrete-mathematics-graph-matrix/</url>
    
    <content type="html"><![CDATA[<p style="text-align:center;color:#ff6444;font-size:1.5em;font-weight: bold;">由于没法很好的渲染出复杂的数学公式，选择了直接贴图</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/math_img/graph-matrix.png"></p>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学笔记 —— 欧拉图和哈密顿图</title>
    <link href="/2022/05/27/discrete-mathematics-elatu-hamilton/"/>
    <url>/2022/05/27/discrete-mathematics-elatu-hamilton/</url>
    
    <content type="html"><![CDATA[<p style="text-align:center;color:#ff6444;font-size:1.5em;font-weight: bold;">由于没法很好的渲染出复杂的数学公式，选择了直接贴图</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/math_img/elatu-hamilton.png"></p>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学笔记 —— 平面图</title>
    <link href="/2022/05/27/discrete-mathematics-plane-map/"/>
    <url>/2022/05/27/discrete-mathematics-plane-map/</url>
    
    <content type="html"><![CDATA[<p style="text-align:center;color:#ff6444;font-size:1.5em;font-weight: bold;">由于没法很好的渲染出复杂的数学公式，选择了直接贴图</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/math_img/plane-map.png"></p>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学笔记 —— 图的着色</title>
    <link href="/2022/05/27/discrete-mathematics-color-graphic/"/>
    <url>/2022/05/27/discrete-mathematics-color-graphic/</url>
    
    <content type="html"><![CDATA[<p style="text-align:center;color:#ff6444;font-size:1.5em;font-weight: bold;">由于没法很好的渲染出复杂的数学公式，选择了直接贴图</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/math_img/clolor.png"></p>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学笔记 —— 树</title>
    <link href="/2022/05/27/discrete-mathematics-tree/"/>
    <url>/2022/05/27/discrete-mathematics-tree/</url>
    
    <content type="html"><![CDATA[<p style="text-align:center;color:#ff6444;font-size:1.5em;font-weight: bold;">由于没法很好的渲染出复杂的数学公式，选择了直接贴图</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/math_img/9.1.png"></p>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>感知机学习算法</title>
    <link href="/2022/05/26/ml-perceptron/"/>
    <url>/2022/05/26/ml-perceptron/</url>
    
    <content type="html"><![CDATA[<h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><h3 id="感知机学习算法"><a href="#感知机学习算法" class="headerlink" title="感知机学习算法"></a>感知机学习算法</h3><h4 id="原始形式"><a href="#原始形式" class="headerlink" title="原始形式"></a>原始形式</h4><ul><li>感知机模型：$f(x)&#x3D;sign(\omega x + \theta)$</li><li>输入：训练集<ul><li>$T&#x3D;{(x_1, y_1),(x_2,y_2,…,(x_n, y_n))}$<ul><li>$x_i\in X&#x3D;R^n$</li><li>$y_i\in{1,-1}$</li><li>$i&#x3D;1,2,…,n$</li></ul></li><li>学习率 $\eta$：$0&lt; \eta \leq 1$</li></ul></li><li>输出：$\omega$，$\theta$</li><li>步骤：<ol><li>选定初值 $\omega_0, \theta_0$<blockquote><p>一般都是 0</p></blockquote></li><li>从训练集中选出数据 $(x_i,y_i)$</li><li>当 $y_i(\omega x_i + \theta) \leq 0$ 时，更新 $\omega, \theta$:<ul><li>$\omega \leftarrow \omega + \eta x_iy_i$</li><li>$\theta \leftarrow \theta + \eta y_i$</li></ul></li><li>继续执行第二步，直至训练集中没有误分类点</li></ol></li></ul><h2 id="数据集介绍"><a href="#数据集介绍" class="headerlink" title="数据集介绍"></a>数据集介绍</h2><ul><li><p><code>/感知机数据集/perceptron_data.txt</code></p></li><li><p>共有 98 个样本 2 个输入变量</p></li><li><p>数据格式如下图：</p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628225935.png" width = "40%"></li></ul><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul><li><code>Python</code> 版本：<code>Python 3.9</code></li><li>编辑器：<code>Jupyter Notebook</code>、<code>PyCharm</code></li><li>扩展包：<code>numpy</code>、<code>pandas</code>、<code>matplotlib</code> 等基础扩展包<blockquote><p>不可使用 <code>sklearn</code>、<code>kreas</code> 等机器学习包</p></blockquote></li></ul><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><ol><li>采用<strong>感知机学习算法</strong>建立模型</li><li><strong>神经元激活函数</strong>建议选用 <code>sign</code> 函数<blockquote><p>（数据集最后一列的标签请将 <code>0</code> 转换为 <code>-1</code>）</p></blockquote></li><li>迭代输出每一次更新后的 $\omega$ 和 $\theta$</li><li>数据集线性可分，最好求解出<strong>线性超平面</strong></li></ol><h2 id="实验代码详解"><a href="#实验代码详解" class="headerlink" title="实验代码详解"></a>实验代码详解</h2><h3 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h3><p>根据上述的感知机学习算法编写代码：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">perceptron</span>(<span class="hljs-params">data_x, data_y, eta</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    感知机学习算法</span><span class="hljs-string">    :param data_x: 样本</span><span class="hljs-string">    :param data_y: 标签</span><span class="hljs-string">    :param eta: 学习率</span><span class="hljs-string">    :return: w， θ</span><span class="hljs-string">    &quot;&quot;&quot;</span>    omega = np.zeros(data_x.shape[<span class="hljs-number">1</span>])    theta = <span class="hljs-number">0</span>    classify_count = <span class="hljs-number">0</span> <span class="hljs-comment"># 记录分类次数</span>    classify_round = <span class="hljs-number">0</span> <span class="hljs-comment"># 记录分类轮次</span>    classify_right = <span class="hljs-literal">False</span> <span class="hljs-comment"># 记录误分类点的存在</span>    new_round = <span class="hljs-literal">True</span>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> classify_right:        <span class="hljs-keyword">if</span> new_round:            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第 %d 轮：&quot;</span> % classify_round)            classify_round += <span class="hljs-number">1</span>        classify_right = <span class="hljs-literal">True</span>        new_round = <span class="hljs-literal">False</span>        <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, data_x.shape[<span class="hljs-number">0</span>]):            <span class="hljs-keyword">if</span> data_y[index] * (np.dot(omega, data_x[index]) + theta) &lt;= <span class="hljs-number">0</span>:                theta += eta * data_y[index]                omega += eta * data_x[index] * data_y[index]                classify_count += <span class="hljs-number">1</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;分类次数：%d\t θ: %.2f\t w：&quot;</span> % (classify_count, theta), omega)                <span class="hljs-comment"># 绘图</span>                table_line(data_x[:, <span class="hljs-number">0</span>], data_x[:, <span class="hljs-number">1</span>], data_y, omega, theta, classify_count)                classify_right = <span class="hljs-literal">False</span>                new_round = <span class="hljs-literal">True</span>    <span class="hljs-keyword">return</span> omega, theta</code></pre></div><h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><p>绘图主要是两个部分：</p><ol><li>训练集根据 [0, 1] 划分后的散点图</li><li>随着 $\omega, \theta$ 的变化而变化的含有超平面的图</li></ol><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_scatter_data</span>(<span class="hljs-params">x_axis, y_axis, label</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    对数据按照 label【0，1】进行分组，方便绘制不同颜色的散点图</span><span class="hljs-string">    &quot;&quot;&quot;</span>    x_red, x_blue, y_red, y_blue = [], [], [], []    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(label)):        <span class="hljs-keyword">if</span> label[index] == <span class="hljs-number">1</span>:            x_red.append(x_axis[index])            y_red.append(y_axis[index])        <span class="hljs-keyword">elif</span> label[index] == -<span class="hljs-number">1</span>:            x_blue.append(x_axis[index])            y_blue.append(y_axis[index])    <span class="hljs-keyword">return</span> [x_red, x_blue], [y_red, y_blue]<span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_table</span>(<span class="hljs-params">x_axis, y_axis, label</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    显示最开始的分组结果</span><span class="hljs-string">    &quot;&quot;&quot;</span>    axis_x, axis_y = get_scatter_data(x_axis, y_axis, label)    color = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>]    mark = [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>]    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(axis_x)):        plt.scatter(axis_x[index], axis_y[index], color=color[index], label=mark[index], alpha=<span class="hljs-number">.5</span>)    plt.xlim((-<span class="hljs-number">4</span>, <span class="hljs-number">4</span>))    plt.ylim((-<span class="hljs-number">3</span>, <span class="hljs-number">15</span>))    plt.legend()  <span class="hljs-comment"># 显示图例</span>    plt.show()<span class="hljs-keyword">def</span> <span class="hljs-title function_">table_line</span>(<span class="hljs-params">x_axis, y_axis, label, omega, theta, i</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    绘制每次迭代时的超平面，并保存图片</span><span class="hljs-string">    :param x_axis: 样本的第一列</span><span class="hljs-string">    :param y_axis: 样本第二列</span><span class="hljs-string">    :param label: 样本标签【0，1】</span><span class="hljs-string">    :param omega: w</span><span class="hljs-string">    :param theta: θ</span><span class="hljs-string">    :param i: 迭代次数</span><span class="hljs-string">    :return:</span><span class="hljs-string">    &quot;&quot;&quot;</span>    axis_x, axis_y = get_scatter_data(x_axis, y_axis, label)    color = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>]    mark = [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>]    x1 = -theta / omega[<span class="hljs-number">0</span>]    x2 = -theta / omega[<span class="hljs-number">1</span>]    <span class="hljs-comment"># 仅当可以绘制一条直线时，绘图</span>    <span class="hljs-keyword">if</span> x1 != x2:        <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(axis_x)):            plt.scatter(axis_x[index], axis_y[index], color=color[index], label=mark[index], alpha=<span class="hljs-number">.5</span>)        plt.xlim((-<span class="hljs-number">4</span>, <span class="hljs-number">4</span>))        plt.ylim((-<span class="hljs-number">3</span>, <span class="hljs-number">15</span>))        plt.axline([x1, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, x2], label=<span class="hljs-string">&#x27;超平面&#x27;</span>, color=<span class="hljs-string">&#x27;black&#x27;</span>)        plt.legend()  <span class="hljs-comment"># 显示图例</span>        <span class="hljs-comment"># 将绘制的图保存到 result 目录下，用于制作 gif</span>        plt.savefig(<span class="hljs-string">&#x27;./result/images&#x27;</span> + <span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;.jpg&#x27;</span>)        <span class="hljs-comment"># 绘制完并保存后，关闭绘图，避免所有绘图绘制在一个图上</span>        plt.close()</code></pre></div><p>为方便查看迭代过程中，随 $\omega,\theta$ 的变化而变化的超平面情况，将每次迭代后绘制超平面，然后将图片保存至  <code>result</code> 文件夹，再读取该文件夹所有文件，制作成一个 GIF，用于观看迭代变化情况。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><div class="code-wrapper"><pre><code class="hljs txt">第 0 轮：分类次数：1 θ: -0.50 w： [ 0.008806 -7.026532]分类次数：2 θ: 0.00 w： [-0.689011  -4.6952615]分类次数：3 θ: 0.50 w： [-0.485659 -1.161594]分类次数：4 θ: 1.00 w： [-0.0604425  2.298573 ]分类次数：5 θ: 0.50 w： [-0.734034 -4.289177]分类次数：6 θ: 1.00 w： [-0.1456275 -2.705667 ]分类次数：7 θ: 1.50 w： [-0.4289305  0.1688345]分类次数：8 θ: 1.00 w： [-0.140668  -5.7206265]分类次数：9 θ: 1.50 w： [-1.20291  -4.384391]分类次数：10 θ: 2.00 w： [-1.0449175 -2.6224145]分类次数：11 θ: 2.50 w： [-1.238079  -0.6277715]分类次数：12 θ: 3.00 w： [-0.639777  1.848154]分类次数：13 θ: 2.50 w： [-0.7773875 -2.9236695]分类次数：14 θ: 3.00 w： [-1.0002265 -1.275018 ]分类次数：15 θ: 3.50 w： [-0.4791155  1.7775595]分类次数：16 θ: 3.00 w： [-0.169722  -3.3829335]分类次数：17 θ: 3.50 w： [ 0.244545 -2.044911]分类次数：18 θ: 4.00 w： [0.359273 0.916058]分类次数：19 θ: 3.50 w： [ 0.8392155 -4.86161  ]分类次数：20 θ: 4.00 w： [ 1.5928545 -2.347677 ]分类次数：21 θ: 4.50 w： [1.64269   1.0702425]分类次数：22 θ: 4.00 w： [ 1.814694 -4.2885  ]分类次数：23 θ: 4.50 w： [ 2.707658  -0.4291775]分类次数：24 θ: 4.00 w： [ 2.711255  -4.9670735]分类次数：25 θ: 4.50 w： [ 3.7921    -0.2106735]分类次数：26 θ: 4.00 w： [ 3.1437585 -6.014453 ]分类次数：27 θ: 4.50 w： [ 2.4750225 -5.7802835]分类次数：28 θ: 5.00 w： [ 2.4013605 -4.3428605]分类次数：29 θ: 5.50 w： [ 3.0613325 -3.2572465]分类次数：30 θ: 6.00 w： [ 4.0894405 -0.747256 ]分类次数：31 θ: 6.50 w： [3.663624  1.4405895]分类次数：32 θ: 6.00 w： [ 4.4186475 -1.5904065]分类次数：33 θ: 6.50 w： [ 3.8689185 -0.7462695]分类次数：34 θ: 6.00 w： [ 3.1688675 -7.06066  ]分类次数：35 θ: 6.50 w： [ 4.0452885 -4.326577 ]分类次数：36 θ: 7.00 w： [ 3.70539  -3.716312]分类次数：37 θ: 7.50 w： [ 2.6209945 -3.644496 ]第 1 轮：分类次数：38 θ: 8.00 w： [ 1.9231775 -1.3132255]分类次数：39 θ: 8.50 w： [2.1265295 2.220442 ]分类次数：40 θ: 8.00 w： [ 1.7928325 -4.150284 ]分类次数：41 θ: 8.50 w： [ 2.218049 -0.690117]分类次数：42 θ: 8.00 w： [ 1.5444575 -7.277867 ]分类次数：43 θ: 8.50 w： [ 2.132864 -5.694357]分类次数：44 θ: 9.00 w： [ 1.849561  -2.8198555]分类次数：45 θ: 9.50 w： [1.8374585 0.256056 ]分类次数：46 θ: 9.00 w： [ 2.125721 -5.633405]分类次数：47 θ: 9.50 w： [ 1.063479  -4.2971695]分类次数：48 θ: 10.00 w： [ 1.2214715 -2.535193 ]分类次数：49 θ: 10.50 w： [ 1.02831 -0.54055]分类次数：50 θ: 10.00 w： [ 0.4158785 -6.33423  ]分类次数：51 θ: 10.50 w： [ 1.0141805 -3.8583045]分类次数：52 θ: 11.00 w： [ 0.7913415 -2.209653 ]分类次数：53 θ: 11.50 w： [1.3124525 0.8429245]分类次数：54 θ: 11.00 w： [ 1.621846  -4.3175685]分类次数：55 θ: 11.50 w： [ 1.736574  -1.3565995]分类次数：56 θ: 11.00 w： [ 2.4915975 -4.3875955]分类次数：57 θ: 11.50 w： [ 3.9966725 -0.1867125]分类次数：58 θ: 11.00 w： [ 3.2966215 -6.501103 ]分类次数：59 θ: 11.50 w： [ 4.1730425 -3.76702  ]第 2 轮：分类次数：60 θ: 12.00 w： [ 3.4752255 -1.4357495]分类次数：61 θ: 11.50 w： [ 3.19052  -6.210127]分类次数：62 θ: 12.00 w： [ 3.6157365 -2.74996  ]分类次数：63 θ: 12.50 w： [3.3324335 0.1245415]分类次数：64 θ: 12.00 w： [ 3.620696  -5.7649195]分类次数：65 θ: 12.50 w： [ 2.558454 -4.428684]分类次数：66 θ: 13.00 w： [ 2.7164465 -2.6667075]分类次数：67 θ: 13.50 w： [3.2375575 0.38587  ]分类次数：68 θ: 13.00 w： [ 3.546951 -4.774623]分类次数：69 θ: 13.50 w： [ 3.661679 -1.813654]分类次数：70 θ: 13.00 w： [ 2.751131 -6.955649]分类次数：71 θ: 13.50 w： [ 4.256206 -2.754766]分类次数：72 θ: 14.00 w： [ 3.8328875 -0.8302285]分类次数：73 θ: 13.50 w： [ 3.1328365 -7.144619 ]分类次数：74 θ: 14.00 w： [ 4.0092575 -4.410536 ]第 3 轮：分类次数：75 θ: 14.50 w： [ 3.3114405 -2.0792655]第 4 轮：</code></pre></div><p>超平面：</p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628225958.png"><p>迭代过程：</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628230114.png"></p><h2 id="实验心得体会"><a href="#实验心得体会" class="headerlink" title="实验心得体会"></a>实验心得体会</h2><p>将数学公式转化成代码模型还是具有一定的难度呀，光看数学公式理解起来还是比较清晰的，但是如果靠自己将公式转化为代码模型就无从下手，只得先借鉴他人的成果，比如前文中的算法步骤，才好轻松进行转换。</p><p>其次是绘图的小问题，自己的想法是先绘制出散点图，再将直线加上去，然后获取第二张图，结果发现似乎没法实现。就只能每次都绘制散点，绘制直线，同时尽可能地减少代码的重复性。</p><p>后面调用 <code>table_line()</code> 函数绘制多个图时，发现，下一张图比上一张图多了一条直线，竟是每次在上一张图的基础上进行绘制，以致于图片全部作废，经了解，需要加上 <code>ptl.close()</code> “关闭” 图表，才好绘制新的图表。</p><h2 id="实验参考"><a href="#实验参考" class="headerlink" title="实验参考"></a>实验参考</h2><ul><li><a href="https://www.cnblogs.com/zhizhan/p/5615947.html">Python–matplotlib绘图可视化知识点整理</a></li><li><a href="https://blog.csdn.net/weixin_43568160/article/details/85680497">python读取某文件下的所有图片并制作成gif图</a></li><li><a href="https://blog.csdn.net/qq_45261963/article/details/118086413">Python数据可视化之散点图(基础篇—图文并茂详细版！！！)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学笔记 —— 通路与回路</title>
    <link href="/2022/05/24/discrete-mathematics-path-circuit/"/>
    <url>/2022/05/24/discrete-mathematics-path-circuit/</url>
    
    <content type="html"><![CDATA[<p style="text-align:center;color:#ff6444;font-size:1.5em;font-weight: bold;">由于没法很好的渲染出复杂的数学公式，选择了直接贴图</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/math_img/tonglu.png"></p>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学笔记 —— 图的基本概念</title>
    <link href="/2022/05/24/discrete-mathematics-basic-concept-graph/"/>
    <url>/2022/05/24/discrete-mathematics-basic-concept-graph/</url>
    
    <content type="html"><![CDATA[<p style="text-align:center;color:#ff6444;font-size:1.5em;font-weight: bold;">由于没法很好的渲染出复杂的数学公式，选择了直接贴图</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/math_img/basic-concept-graph.png"></p>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性判别分析 —— 献血预测</title>
    <link href="/2022/05/14/ml-lda/"/>
    <url>/2022/05/14/ml-lda/</url>
    
    <content type="html"><![CDATA[<h3 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h3><p><strong>线性判别分析（LDA）</strong></p><p>LDA 的思想非常朴素: 给定训练样例，设法将样例投影到一条直线上，使得同样例的投影点尽可能接近、异类样例的投影点尽可能远离;在对新样本进行分类时，将其投影到同样的这条直线上，再根据投影点的位置来确定新样本的类别.</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628225538.png"></p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628225610.png"></p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628225634.png"></p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628225650.png"></p><h3 id="数据集介绍"><a href="#数据集介绍" class="headerlink" title="数据集介绍"></a>数据集介绍</h3><ul><li>输血服务中心数据集：<code>data/输血服务中心数据集/blood_data.txt</code></li><li>该实验是个分类问题。本数据集共有 <code>748</code> 个样本，<code>5</code> 个属性，详见 <code>data/输血服务中心数据集/blood_names.txt</code></li></ul><table><thead><tr><th align="center">属性名</th><th align="center">中文属性名</th><th align="left">意义</th></tr></thead><tbody><tr><td align="center">R</td><td align="center">近期</td><td align="left">距离上次献血的月数</td></tr><tr><td align="center">F</td><td align="center">频率</td><td align="left">捐献的总次数</td></tr><tr><td align="center">M</td><td align="center">度量</td><td align="left">捐献的总血量</td></tr><tr><td align="center">T</td><td align="center">时间</td><td align="left">距离首次献血的月数</td></tr><tr><td align="center">Donate</td><td align="center">一个二进制变量</td><td align="left">表示他&#x2F;她在是否在2007年3月献血（1：献血</td></tr></tbody></table><h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><ol><li>划分测试集（<code>600</code>）和训练集（<code>148</code>），对数据集进行线性判别分析</li><li>将模型结果的投影方向 <code>w</code> 进行输出</li><li>输出测试集的准确率 <code>acc</code></li><li>最好能够将数据的分析结果进行可视化</li><li><code>5</code> 月 <code>12</code> 日晚上 <code>12:00</code> 之前将代码（<code>.py</code> 或者 <code>.ipynb</code> 文件）、实验报告（ <code>doc</code> 或 <code>pdf</code> 文件）一并打包上传至邮箱。</li></ol><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><h4 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h4><p>本部分主要工作：</p><ol><li>从 txt 文件中读取数据集</li><li>将数据集分为 <strong>训练集</strong> 和 <strong>测试集</strong></li><li>将 <strong>训练集</strong> 和 <strong>测试集</strong> 分为 <code>x</code>， <code>y</code> 两个部分</li></ol><p>主要代码：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_data</span>(<span class="hljs-params">file_path, df_columns</span>):    <span class="hljs-comment"># 读取 txt 到 datadfram。并加入列名</span>    data = pd.read_csv(file_path, header=<span class="hljs-literal">None</span>, sep=<span class="hljs-string">&#x27;,&#x27;</span>)    data.columns = df_columns    <span class="hljs-keyword">return</span> data<span class="hljs-keyword">def</span> <span class="hljs-title function_">load_data</span>(<span class="hljs-params">file_path</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    加载数据集，并划分训练集和测试集</span><span class="hljs-string">    &quot;&quot;&quot;</span>    data_columns = [<span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-string">&#x27;T&#x27;</span>, <span class="hljs-string">&#x27;Donate&#x27;</span>]    data_df = read_data(file_path, data_columns)    <span class="hljs-comment"># 训练集</span>    training_data = data_df.head(<span class="hljs-number">600</span>)    <span class="hljs-comment"># 训练集 x, y</span>    training_x, training_y = training_data.iloc[:, :(training_data.shape[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>)], training_data.iloc[:, -<span class="hljs-number">1</span>]    <span class="hljs-comment"># 测试集</span>    testing_data = data_df.tail(<span class="hljs-number">148</span>)    <span class="hljs-comment"># 测试集 x, y</span>    testing_x, testing_y = testing_data.iloc[:, :(testing_data.shape[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>)], testing_data.iloc[:, -<span class="hljs-number">1</span>]    <span class="hljs-keyword">return</span> training_x, training_y, testing_x, testing_y</code></pre></div><h4 id="编写-LDA-算法"><a href="#编写-LDA-算法" class="headerlink" title="编写 LDA 算法"></a>编写 LDA 算法</h4><p>本部分主要是计算下列的结果：</p><ol><li>计算类内散度矩阵 $S_w$</li><li>计算类间散度矩阵 $S_b$</li><li>计算矩阵 $S_w^{-1}S_b$</li><li>计算 $S_w^{-1}S_b$ 的最大的 d 个特征值和对应的 d 个特征向量 （$w_1$, $w_2$, … $w_d$），得到投影矩阵 $W$</li></ol><p><strong>主要代码：</strong><br>将 LDA 模型封装为一个类，该类需要传入三个参数：数据特征，数据标签以及降维后的维度。</p><ul><li>数据特征：training_x</li><li>数据标签: training_y</li></ul><p>变量定义：</p><ul><li><code>self.mu</code>：样本的均值向量，$\mu$ </li><li><code>self.new_data</code>：降维后的样本</li><li><code>self.swt_sb</code>：矩阵，$S_w^{-1}*S_b$，用于计算投影矩阵</li><li><code>self.w</code>：投影矩阵</li><li><code>self.Sw</code>：类内散度矩阵 $S_w$</li><li><code>self.Sb</code>：类间散度矩阵 $S_b$</li><li><code>self.St</code>：全局散度矩阵 $S_t$</li><li><code>self.labels</code>：数据标签，<code>training_y</code> 有的类型，本实验中共两种：<code>0</code>，<code>1</code></li><li><code>self.classify</code>：第 $i$ 类的样本，$X_i$</li><li><code>self.class_mu</code>：第 $i$ 类样本的均值向量，$\mu_{i}$</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LDAModel</span>(<span class="hljs-title class_ inherited__">object</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    线性判别分析</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, data, target, d</span>) -&gt; <span class="hljs-literal">None</span>:        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        数据特征 数据标签 降维后的维度</span><span class="hljs-string">        &quot;&quot;&quot;</span>        self.data = data        self.target = target        self.d = d        self.labels = <span class="hljs-built_in">set</span>(target)        <span class="hljs-comment"># 列的平均值 μ</span>        <span class="hljs-comment"># 所有样本的均值向量</span>        self.mu = self.data.mean(<span class="hljs-number">0</span>)        self.new_data = <span class="hljs-literal">None</span>        self.swt_sb = <span class="hljs-literal">None</span>        self.w = <span class="hljs-literal">None</span>        self.Sw = <span class="hljs-literal">None</span>        self.Sb = <span class="hljs-literal">None</span>        self.St = <span class="hljs-literal">None</span>        self.classify, self.class_mu = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span></code></pre></div><p>将样本根据标签进行分类：方便 $\mu_i$ 的计算</p><ul><li>$X_1$：献血的样本集，标签 <code>1</code></li><li>$X_2$：未献血的样本集，标签 <code>0</code><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_divide_to_vectors</span>(<span class="hljs-params">self</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    功能：将传入的数据集按 target 分成不同的类别集合并求出对应集合的均值向量</span><span class="hljs-string">    &quot;&quot;&quot;</span>    self.classify, self.class_mu = &#123;&#125;, &#123;&#125;    <span class="hljs-comment"># 根据结果的值【0，1】，将训练样本分类：【0】一类，【1】一类</span>    <span class="hljs-keyword">for</span> label <span class="hljs-keyword">in</span> self.labels:        <span class="hljs-comment"># 分类</span>        self.classify[label] = self.data[self.target == label]        <span class="hljs-comment"># 均值向量(平均值)</span>        self.class_mu[label] = self.classify[label].mean(<span class="hljs-number">0</span>)</code></pre></div>计算全局散度矩阵：全局散度矩阵实际上就是类内散度矩阵和类间散度矩阵之和<br>$$S_t &#x3D; S_b+S_w&#x3D;\sum_{i &#x3D; 1}^{m}(x_i-\mu)(x_i-\mu)^T$$</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_st</span>(<span class="hljs-params">self</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    功能：计算全局散度矩阵</span><span class="hljs-string">    &quot;&quot;&quot;</span>    self.St = np.dot((self.data - self.mu).T, (self.data - self.mu))</code></pre></div><p>计算类间散度矩阵：<br>类间散度矩阵其实就是协方差矩阵乘以样本数目，即散度矩阵与协方差矩阵只是相差一个系数。<br>$$S_b &#x3D; \sum_{i&#x3D;1}^Nm_i(\mu_i-\mu)(\mu_i-\mu)^T$$</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_sb</span>(<span class="hljs-params">self</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    功能：计算类间散度矩阵</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># 创建新的数组</span>    self.Sb = np.zeros((self.data.shape[<span class="hljs-number">1</span>], self.data.shape[<span class="hljs-number">1</span>]))    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self.labels:        <span class="hljs-comment"># 获取类别i样例的集合</span>        class_i = self.classify[i]        <span class="hljs-comment"># 获取类别i的均值向量</span>        mu_i = self.class_mu[i]        self.Sb += <span class="hljs-built_in">len</span>(class_i) * np.dot((mu_i - self.mu).values.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>),                                         (mu_i - self.mu).values.reshape(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>))</code></pre></div><p>计算类内散度矩阵：<br>重定义为了每个类别的散度矩阵之和。<br>$$S_w&#x3D;S_t-S_b&#x3D;\sum_{i&#x3D;1}^NS_{w_i}&#x3D;\sum_{i&#x3D;1}^N\sum_{x\in X_i}(x-\mu_i)(x-\mu_i)^T$$</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_sw</span>(<span class="hljs-params">self</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    功能：定义类内散度矩阵</span><span class="hljs-string">    &quot;&quot;&quot;</span>    self.get_st()    self.get_sb()    <span class="hljs-comment"># St = Sw + Sb</span>    self.Sw = self.St - self.Sb</code></pre></div><p>计算 $S_w^{-1}*S_b$</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_swt_sb</span>(<span class="hljs-params">self</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    计算 Sw^(-1)*Sb</span><span class="hljs-string">    &quot;&quot;&quot;</span>    self.data_divide_to_vectors()    self.get_sw()    self.swt_sb = np.linalg.inv(self.Sw).dot(self.Sb)</code></pre></div><p>计算 $S_w^{-1}S_b$ 的特征值和特征向量，并取最大的 d 个特征值和对应的特征向量作为投影矩阵 $w$</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_w</span>(<span class="hljs-params">self</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    功能：计算w</span><span class="hljs-string">    &quot;&quot;&quot;</span>    self.get_swt_sb()    <span class="hljs-comment">#  特征值 和 特征向量</span>    <span class="hljs-comment"># eig_vectors[:i]与 eig_values相对应</span>    eig_values, eig_vectors = np.linalg.eig(self.swt_sb)    <span class="hljs-comment"># 寻找 d 个最大非零广义特征值</span>    top_d = (np.argsort(eig_values)[::-<span class="hljs-number">1</span>])[:self.d]    <span class="hljs-comment"># 用d个最大非零广义特征值组成的向量组成w</span>    self.w = eig_vectors[:, top_d]</code></pre></div><h4 id="对测试集进行预测"><a href="#对测试集进行预测" class="headerlink" title="对测试集进行预测"></a>对测试集进行预测</h4><p>主要代码：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">testing</span>():    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    功能：对测试集进行分类并返回准确率</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># 加载数据集</span>    train_x, train_y, test_x, test_y = load_data(<span class="hljs-string">&#x27;./data/blood_data.txt&#x27;</span>)    <span class="hljs-comment"># print(train_x, test_x, train_y, test_y)</span>    <span class="hljs-comment"># 创建模型</span>    lda = LDAModel(train_x, train_y, <span class="hljs-number">1</span>)    <span class="hljs-comment"># 获取投影矩阵w</span>    lda.get_result()    <span class="hljs-comment"># 对训练集进行降维</span>    train_x_handled = lda.new_data    <span class="hljs-comment"># 降维后的样本集</span>    <span class="hljs-comment"># data_df = pd.concat([pd.DataFrame(train_x_handled), train_y], axis=1)</span>    <span class="hljs-comment"># data_df.columns = [&#x27;Handled-Z1&#x27;, &#x27;Donate-Y1&#x27;]</span>    <span class="hljs-comment"># print(data_df)</span>    <span class="hljs-comment"># 获取训练集各个类别对应的高斯分布的均值和方差</span>    gauss_dist = &#123;&#125;    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> lda.labels:        category = train_x_handled[train_y == i]        <span class="hljs-comment"># 计算均值</span>        loc = category.mean()        <span class="hljs-comment"># 计算方差</span>        scale = category.std()        gauss_dist[i] = &#123;<span class="hljs-string">&#x27;loc&#x27;</span>: loc, <span class="hljs-string">&#x27;scale&#x27;</span>: scale&#125;    <span class="hljs-comment"># 测试集降维</span>    test_x_handled = np.dot(test_x, lda.w)    pred_y = np.array([judge_classification(gauss_dist, x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> test_x_handled])</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">judge_classification</span>(<span class="hljs-params">gauss_dist, x</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    功能：判断样本x属于哪个类别</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># 将样本带入各个类别的高斯分布概率密度函数进行计算</span>    judge_result = [[k, norm.pdf(x, loc=v[<span class="hljs-string">&#x27;loc&#x27;</span>], scale=v[<span class="hljs-string">&#x27;scale&#x27;</span>])] <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> gauss_dist.items()]    <span class="hljs-comment"># 寻找计算结果最大的类别</span>    judge_result.sort(key=<span class="hljs-keyword">lambda</span> s: s[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)    <span class="hljs-comment"># print(judge_result)</span>    <span class="hljs-keyword">return</span> judge_result[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">accuracy_score</span>(<span class="hljs-params">y_true, y_pred</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    Compare y_true to y_pred and return the accuracy</span><span class="hljs-string">    比较 实际值 与 预测值，并返回准确度</span><span class="hljs-string">    &quot;&quot;&quot;</span>    accuracy = np.<span class="hljs-built_in">sum</span>(y_true == y_pred, axis=<span class="hljs-number">0</span>) / <span class="hljs-built_in">len</span>(y_true)    <span class="hljs-keyword">return</span> accuracy</code></pre></div><h4 id="绘制图标"><a href="#绘制图标" class="headerlink" title="绘制图标"></a>绘制图标</h4><p>绘制训练集降维后的图表，以降维结果作为横坐标，0|1作为纵坐标。</p><p>本图重在表示降维后，两类样本的位置情况。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628225723.png"></p><div class="code-wrapper"><pre><code class="hljs python">plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;SimHei&#x27;</span>]plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span>plt.scatter(train_x_handled[train_y == <span class="hljs-number">0</span>], np.ones((<span class="hljs-number">1</span>, train_x_handled[train_y == <span class="hljs-number">0</span>].shape[<span class="hljs-number">0</span>])),            marker=<span class="hljs-string">&#x27;.&#x27;</span>, color=<span class="hljs-string">&#x27;red&#x27;</span>, label=<span class="hljs-string">&#x27;2007年3月位献血: 0&#x27;</span>, alpha=<span class="hljs-number">0.5</span>)plt.scatter(train_x_handled[train_y == <span class="hljs-number">1</span>], np.zeros((<span class="hljs-number">1</span>, train_x_handled[train_y == <span class="hljs-number">1</span>].shape[<span class="hljs-number">0</span>])),            marker=<span class="hljs-string">&#x27;^&#x27;</span>, color=<span class="hljs-string">&#x27;blue&#x27;</span>, label=<span class="hljs-string">&#x27;2007年3月献血: 1&#x27;</span>, alpha=<span class="hljs-number">0.5</span>)plt.legend()plt.title(<span class="hljs-string">&quot;训练集降维情况&quot;</span>)plt.ylabel(<span class="hljs-string">&quot;是否献血/(1/0)&quot;</span>)plt.xlabel(<span class="hljs-string">&quot;样本降维后的参数&quot;</span>)plt.show()</code></pre></div><p>绘制测试集降维后的图表，以降维结果作为横坐标，0|1作为纵坐标。</p><p>本图重在表示降维后，两类样本的位置情况。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628225740.png"></p><div class="code-wrapper"><pre><code class="hljs python">plt.scatter(test_x_handled[test_y == <span class="hljs-number">0</span>], np.ones((<span class="hljs-number">1</span>, test_x_handled[test_y == <span class="hljs-number">0</span>].shape[<span class="hljs-number">0</span>])),               marker=<span class="hljs-string">&#x27;.&#x27;</span>, color=<span class="hljs-string">&#x27;red&#x27;</span>, label=<span class="hljs-string">&#x27;2007年3月未献血: 0&#x27;</span>, alpha=<span class="hljs-number">0.5</span>)   plt.scatter(test_x_handled[test_y == <span class="hljs-number">1</span>], np.zeros((<span class="hljs-number">1</span>, test_x_handled[test_y == <span class="hljs-number">1</span>].shape[<span class="hljs-number">0</span>])),               marker=<span class="hljs-string">&#x27;^&#x27;</span>, color=<span class="hljs-string">&#x27;blue&#x27;</span>, label=<span class="hljs-string">&#x27;2007年3月献血: 1&#x27;</span>, alpha=<span class="hljs-number">0.5</span>)   plt.legend()   plt.title(<span class="hljs-string">&quot;测试集降维情况&quot;</span>)   plt.ylabel(<span class="hljs-string">&quot;是否献血/(1/0)&quot;</span>)   plt.xlabel(<span class="hljs-string">&quot;样本降维后的参数&quot;</span>)   plt.show()</code></pre></div><p>绘制测试集的预测值与真实值的比较图表。</p><p>横坐标是序号，0~148</p><p>纵坐标是 0 | -1 | +1，0表示未献血，+1 表示真实值的献血，-1表示预测值的献血</p><p>该图结果是，具有不同颜色条形的图表，当某一序号位置某颜色的条形不存在同序号位置的另一色的条形，表示该序号位置的预测值与真实值不一致。</p><p>由图可得准确率：$1-frac{\text{位置不一致的条形个数}}{148}$</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628225805.png"></p><div class="code-wrapper"><pre><code class="hljs python">y1 = test_yy2 = pred_yx = <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">148</span>)plt.scatter(x, y1, color=<span class="hljs-string">&#x27;#ff4eff&#x27;</span>, label=<span class="hljs-string">&#x27;test&#x27;</span>, alpha=<span class="hljs-number">0.5</span>)plt.scatter(x, -y2, marker=<span class="hljs-string">&#x27;^&#x27;</span>, color=<span class="hljs-string">&#x27;#ba2c01&#x27;</span>, label=<span class="hljs-string">&#x27;pred&#x27;</span>, alpha=<span class="hljs-number">0.5</span>)plt.legend()plt.title(<span class="hljs-string">&quot;真实值与预测值的比较（预测的准确率：&quot;</span> + <span class="hljs-built_in">str</span>(accuracy_score(test_y, pred_y)) + <span class="hljs-string">&quot;)&quot;</span>)plt.ylabel(<span class="hljs-string">&quot;是否献血/(1/0)&quot;</span>)plt.xlabel(<span class="hljs-string">&quot;序号&quot;</span>)plt.show()</code></pre></div><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>将投影矩阵与预测准确度写入了 <code>./output.txt</code> 中。文件内容如下：</p><div class="code-wrapper"><pre><code class="hljs txt">训练结果(w)： [[-0.59843282  0.73633892  0.00455796 -0.31569349]]预测准确度： 0.8918918918918919</code></pre></div><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p>本次实验实践了线性判别分析算法。</p><p>经过查阅资料、上手实践后，对线性判别分析（LDA）算法有了一定的了解：</p><ul><li>LDA 有二分类、多分类两种情况<blockquote><p>二分类也可是多分类的特殊情况。<br>二分类和多分类在公式表达上略有不同。<br>二者的算法思路、步骤一致。</p></blockquote></li><li>LDA 步骤：<ol><li>计算类内散度矩阵 $S_w$</li><li>计算类间散度矩阵 $S_b$</li><li>计算矩阵 $S_w^{-1}S_b$</li><li>计算 $S_w^{-1}S_b$ 的最大的 d 个特征值和对应的 d 个特征向量 （$w_1$, $w_2$, … $w_d$），得到投影矩阵 $W$</li><li>计算 降维后的样本 $Z_i &#x3D; X_i * w$</li></ol></li></ul><p>实验的实现还是基于明白数学公式，这还是实验的重难点哦。</p><p>还有一点就是，选择一个合适的图表用来表示可视化的结果也是有点难度的。</p><h3 id="实验参考"><a href="#实验参考" class="headerlink" title="实验参考"></a>实验参考</h3><ul><li><a href="https://www.cnblogs.com/wj-1314/p/10234256.html">Python机器学习笔记：线性判别分析（LDA）算法</a></li><li><a href="https://blog.csdn.net/qq_42103091/article/details/109786330">机器学习(三)：一文读懂线性判别分析（LDA）</a></li><li><a href="https://blog.csdn.net/weixin_44916097/article/details/105809242">机器学习实战笔记5——线性判别分析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>决策树 —— 隐形眼镜数据集预测</title>
    <link href="/2022/05/14/ml-decision-tree/"/>
    <url>/2022/05/14/ml-decision-tree/</url>
    
    <content type="html"><![CDATA[<h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><hr><h3 id="决策树思想"><a href="#决策树思想" class="headerlink" title="决策树思想"></a>决策树思想</h3><p>决策树学习的本质：<strong>从训练数据集中归纳出一组分类规则</strong>。</p><blockquote><ul><li><p>可能这种决策规则一个也没有</p></li><li><p>也可能有多个决策规则</p></li></ul></blockquote><p>此时需要选择一个<strong>与数据集矛盾较小</strong>的决策树规则，同时有需要很好的泛化效果。</p><h3 id="学习算法原理"><a href="#学习算法原理" class="headerlink" title="学习算法原理"></a>学习算法原理</h3><ol><li>构造<strong>根节点</strong>，将<strong>所有的训练数据集放入根节点</strong></li><li>选择一个<strong>最优特征</strong>，将训练集<strong>分割成子集</strong>，使得训练及在当前条件下有最好的分类</li><li>如果这些子集已经可能很好的分类，那么构建叶子节点；如果还不能很好的分类，继续对其分割，构造相应的节点</li><li><strong>重复（递归）</strong>进行上述步骤，直至所有训练数据集<strong>被基本正确分类</strong>，或者<strong>没有合适的特征</strong>为止</li></ol><p>经过以上过程，决策树可能对训练集有了很好的分类能力，但是对未知数据不一定同样有很好的分类效果。</p><p>所以，为了避免<strong>过拟合</strong>现象，还需要对生成的树进行<strong>剪枝</strong>，将树变得更简单，以实现更好的泛化能力。</p><p>从上面可以看出，一个决策树学习算法需要包括<strong>特征选取</strong>、<strong>决策树生成</strong>和<strong>决策树剪枝</strong>过程。</p><blockquote><p>常用的学习算法有：</p><ul><li><p><code>ID3</code> [Quinlan, 1986]：最优特征选择标准是<strong>信息增益</strong></p></li><li><p><code>ID4.5</code> [Quinlan, 1993]：最优特征选择标准是<strong>信息增益率</strong></p></li><li><p><code>CART</code> [Breiman, 1984]：最有特征选择标准是<strong>节点方差的大小</strong></p></li></ul></blockquote><h3 id="决策树学习基本算法"><a href="#决策树学习基本算法" class="headerlink" title="决策树学习基本算法"></a>决策树学习基本算法</h3><h3 id="信息增益率"><a href="#信息增益率" class="headerlink" title="信息增益率"></a>信息增益率</h3><p>增益率（gain ratio）<br>$$<br>Gain_ratio(D,a)&#x3D;\frac{Gain(D,a)}{IV(a)}<br>$$<br>其中<br>$$<br>IV(a)&#x3D;-\sum_{v&#x3D;1}^{V}\frac{|D^v|}{|D|}log_2\frac{|D^v|}{|D|}<br>$$<br>称为属性 a 的“固有值”（intrinsic value）[Quinlan, 1993]。</p><p>属性 a 的可能取值数目越多（即 V 越大），则 IV(a) 的值通常会越大。</p><blockquote><p>近看上述公式，并不是很明白增益率如何计算。查阅资料后知，分为几步：</p><ol><li>计算整体的信息熵<br>$$<br>H(X) &#x3D; -\sum_{i &#x3D; 1}^{m}p_ilog_2(p_i)<br>$$</li></ol><ul><li>$m$: 训练数据集结果的标签数</li><li>$p_i$: 第 $i$ 类标签的比例</li></ul><ol start="2"><li>计算某特征的条件熵<br>$$<br>H(X|Y)&#x3D;\sum_{y\in Y}p(y)H(X|Y&#x3D;y)<br>$$</li></ol><ul><li><p>$H(X|Y&#x3D;y)$: 该特征中某标签的条件熵<br>$$<br>H(X|Y &#x3D; y_i) &#x3D;-\sum_{i&#x3D;1}^{n}p_ilog_2(p_i)<br>$$</p></li><li><p>$n$: 在条件为该特征中某标签下，结果的标签数</p></li><li><p>$p_i$: 在条件为该特征中某标签下，第 $i$ 类结果标签的比例</p></li></ul><ol start="3"><li><p>计算某特征的信息增益<br>$$<br>g(X,Y)&#x3D;H(X)-H(X|Y)<br>$$</p></li><li><p>计算某特征的内部信息（Intrinsic Information of an Attribute）<br>其实就是<strong>特征的信息熵</strong><br>$$<br>Intl(X,Y)&#x3D;-\sum_{i&#x3D;1}^{m}\frac{|Y_i|}{|X|}log_2(\frac{|Y_i|}{|X|})<br>$$</p></li></ol><ul><li>$Y$: 表示某个特征的随机变量</li><li>$Y_i$: 该特征的第 $i$  类的个数</li><li>$X$: 表示样本的总个数</li><li>$\frac{|Y_i|}{|X|}$: 表示该特征的第 $i$ 类占样本的比例</li></ul><ol start="5"><li>计算某特征的信息增益率<br>$$<br>g(X|Y)&#x3D;\frac{g(X,Y)}{Intl(X,yY)}<br>$$</li></ol></blockquote><blockquote><p>结合实例理解请详见：<a href="https://blog.csdn.net/u010916338/article/details/94653402">信息增益率</a></p></blockquote><h3 id="决策树算法框架"><a href="#决策树算法框架" class="headerlink" title="决策树算法框架"></a>决策树算法框架</h3><ol><li><p><strong>决策树主函数</strong></p><p>各类决策树的主函数都大同小异，本质上是一个<strong>递归函数</strong>。</p><p>该函数的主要功能是按照某种规则生长出决策树的各个分支节点，并根据终止条件结束算法。</p><p>一般来讲，主函数需要完成如下几个功能：</p><ol><li>输入需要分类的数据集和类别标签</li><li>根据<strong>某种分类规则</strong>得到<strong>最优的划分特征</strong>，并创建特征的划分节点 —— 计算最优特征子函数</li><li>按照该特征的每个取值<strong>划分数据</strong>集为若干部分 —— 划分数据集子函数</li><li>根据划分子函数的计算结果构建出新的节点，作为树生长出的新分支</li><li><strong>检验是否符合递归的终止条件</strong></li><li>将划分的新节点包含的数据集和类别标签作为输入，<strong>递归执行</strong>上述步骤。</li></ol></li><li><p><strong>计算最优特征子函数</strong></p><p>计算最优特征子函数是除主函数外最重要的函数。</p><p>每种决策树之所以不同，一般都是因为<strong>最优特征选择的标准</strong>不同，不同的标准导致不同类型的决策树。如：</p><blockquote><ul><li><p><code>ID3</code> [Quinlan, 1986]：最优特征选择标准是<strong>信息增益</strong></p></li><li><p><code>ID4.5</code> [Quinlan, 1993]：最优特征选择标准是<strong>信息增益率</strong></p></li><li><p><code>CART</code> [Breiman, 1984]：最有特征选择标准是<strong>节点方差的大小</strong></p></li></ul></blockquote></li><li><p><strong>划分数据集子函数</strong></p><p>划分数据集函数的主要功能是分隔数据集，有的需要删除某个特征轴所在的数据列，返回剩余的数据集；有的干脆将数据集一分为二。</p></li><li><p><strong>分类器</strong></p><p>所有的机器学习算法都要勇于分类或回归预测。</p><p>决策树的分类器就是通过遍历整个决策树，使测试集数据找到决策树中叶子节点对应的类别标签。这个标签就是返回的结果。</p></li></ol><h2 id="数据集介绍"><a href="#数据集介绍" class="headerlink" title="数据集介绍"></a>数据集介绍</h2><hr><ul><li><p><strong>数据集</strong>：<code>隐形眼镜数据集/lenses_data.txt</code><br>共有 24 个样本:</p><ul><li>4 个<strong>输入变量</strong>(数据集中第一列为<strong>样本编号</strong>)</li><li>1 个输出变量(数据集中最后一列)</li></ul></li><li><p><strong>数据集信息</strong>:</p><ul><li>3 类结果标签：<ul><li><code>1</code>：患者应佩戴硬隐形眼镜</li><li><code>2</code>：患者应佩戴软性隐形眼镜</li><li><code>3</code>：患者不应佩戴隐形眼镜</li></ul></li><li>4 类特征及其标签<ul><li>年龄：<ul><li><code>1</code>：青年</li><li><code>2</code>：中年</li><li><code>3</code>：老年</li></ul></li><li>症状：<ul><li><code>1</code>：近视</li><li><code>2</code>：远视</li></ul></li><li>散光：<ul><li><code>1</code>：否</li><li><code>2</code>：是</li></ul></li><li>眼泪数量：<ul><li><code>1</code>：减少</li><li><code>2</code>：正常</li></ul></li></ul></li><li>详见 <code>隐形眼镜数据集/lenses_names.txt</code></li></ul></li></ul><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><hr><ul><li><code>Python</code> 版本：<code>Python 3.6</code></li><li>编辑器：<code>PyCharm</code></li><li>扩展包：<code>numpy</code>、<code>pandas</code>、<code>matplotlib</code> 等<strong>基础扩展包</strong><blockquote><p>不可使用 <code>sklearn</code>、<code>kreas</code> 等<strong>机器学习包</strong></p></blockquote></li></ul><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><hr><ol><li>采用 <code>C4.5</code> 算法建立决策树模型</li><li>将每个特征的信息增益率打印输出</li><li>输出最后建立的决策树模型结构图（可以用 <code>字典结构</code> 表示，也可以用 <code>matplotlib</code> 等图形库绘制出树形图）<blockquote><ul><li>字典表示：<img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628230841.png"></li><li>树形图表示：   <img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628231217.png" width="60%"/></li></ul></blockquote></li></ol><h2 id="实验代码详解"><a href="#实验代码详解" class="headerlink" title="实验代码详解"></a>实验代码详解</h2><hr><h3 id="读取数据文件"><a href="#读取数据文件" class="headerlink" title="读取数据文件"></a>读取数据文件</h3><p>简单的使用 <code>numpy.loadtxt</code> 读取 <code>txt</code> 的后五行数据。</p><p>一开始读取完数据后还分一下训练集、测试集的，后面发现，这数据是有规律的，就像是四类特征的标签进行了笛卡尔积运算一行，结果的标签也具有一点点的规律。</p><p>又仔细看了看<strong>实验要求</strong>，没说需要预测，只是说需要 <strong>信息增益率</strong> + <strong>决策树结构</strong>。</p><p>所以就，不分训练集和测试集。</p><h3 id="最优特征子函数-——-信息增益率计算"><a href="#最优特征子函数-——-信息增益率计算" class="headerlink" title="最优特征子函数 —— 信息增益率计算"></a>最优特征子函数 —— 信息增益率计算</h3><p>该部分主要是计算各特征的信息增益率，并进行比较，<strong>返回</strong>信息增益率最大的特征的<strong>索引</strong>。</p><p>该计算也分为几步：</p><ol><li>计算标签信息熵：对应函数 <code>get_info_entropy(x)</code></li><li>计算条件信息熵：对应函数 <code>get_conditional_info_entropy(feature, x)</code></li><li>计算信息增益率：对应函数 <code>get_info_gain_ratio(feature, x)</code></li><li><strong>获取最佳信息增益率的索引</strong>：对应函数 <code>get_best_feature(data, label, is_print)</code></li></ol><blockquote><p>计算均按照上述公式</p></blockquote><h3 id="数据集划分子函数"><a href="#数据集划分子函数" class="headerlink" title="数据集划分子函数"></a>数据集划分子函数</h3><p>该部分就是在递归时，获取作为递归参数 —— 数据集。</p><p>该数据集的特征有：</p><ul><li>缺少上一次递归时最佳特征所在的那一列</li><li>缺少的这一列的值均相同</li></ul><blockquote><p>就是：</p><p>该函数会根据最佳特征的标签的情况将数据集划分为 $m$ 类。</p><p>$m$ 是最佳特征标签的个数。</p><p>每类子数据集都是最佳特征标签相同的其他特征数据的集合。</p></blockquote><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">split_dataset</span>(<span class="hljs-params">data, index, value</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    对数据集进行分片</span><span class="hljs-string">    :param data: 需要分片的数据集</span><span class="hljs-string">    :param index: 新数据集不需要的某列的索引</span><span class="hljs-string">    :param value: 用于确定新数据集需要某行在 某列[index]对应的值</span><span class="hljs-string">    :return: 新的数据集</span><span class="hljs-string">    &quot;&quot;&quot;</span>    has_split_dataset = []    <span class="hljs-keyword">for</span> col_data <span class="hljs-keyword">in</span> data:        <span class="hljs-comment"># 选择特定行的数据进行切片</span>        <span class="hljs-keyword">if</span> col_data[index] == value:            <span class="hljs-comment"># 取 第 index 个前的所有元素</span>            has_split_col = col_data[:index].tolist()            <span class="hljs-comment"># 再加上第 index 个后面的所有元素</span>            has_split_col.extend(col_data[index + <span class="hljs-number">1</span>:].tolist())            <span class="hljs-comment"># 再将其加入 新的 数据集</span>            has_split_dataset.append(has_split_col)    <span class="hljs-keyword">return</span> np.array(has_split_dataset)</code></pre></div><h3 id="决策树主函数"><a href="#决策树主函数" class="headerlink" title="决策树主函数"></a>决策树主函数</h3><p>获取数据集中的标签数据：<code>labels = [item[-1] for item in data]</code></p><h4 id="递归终止条件"><a href="#递归终止条件" class="headerlink" title="递归终止条件"></a>递归终止条件</h4><ol><li><p>子节点的样本属于同一类标签</p><p>返回该类标签</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-number">1</span> == <span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(labels)):    <span class="hljs-keyword">return</span> labels[<span class="hljs-number">0</span>]</code></pre></div></li><li><p>子节点样本的特征标签相同，或是没有了样本</p><p> 返回出现次数最多的标签</p> <div class="code-wrapper"><pre><code class="hljs python">    <span class="hljs-comment"># 特征集为空 或是 特征集上的取值相同，停止分类</span>    <span class="hljs-comment"># 返回出现次数最多的 标签</span>    <span class="hljs-comment"># len(data[0]) == 1 就是数据集里只剩下标签，没有特征了</span>    <span class="hljs-comment"># len(set(data[:, 0])) == 1 特征集上的取值相同</span>    <span class="hljs-comment"># not feature_label 特征集空了</span>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data[<span class="hljs-number">0</span>]) == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(data[:, <span class="hljs-number">0</span>])) == <span class="hljs-number">1</span>:        <span class="hljs-keyword">return</span> most_label(labels)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">most_label</span>(<span class="hljs-params">data</span>):        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        返回，出现次数最大多的标签</span><span class="hljs-string">        &quot;&quot;&quot;</span>        label = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(data))        most = <span class="hljs-string">&#x27;&#x27;</span>        most_count = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> item_label <span class="hljs-keyword">in</span> label:            count = <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> item_data <span class="hljs-keyword">in</span> data:                <span class="hljs-keyword">if</span> item_label == item_data:                    count += <span class="hljs-number">1</span>            most = item_label <span class="hljs-keyword">if</span> count &gt; most_count <span class="hljs-keyword">else</span> most            most_count = count        <span class="hljs-keyword">return</span> most    ```Glasses<span class="hljs-number">3.</span> 特征集为空      返回出现次数最多的标签   ```python       <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> feature_label:           <span class="hljs-keyword">return</span> most_label(labels)</code></pre></div></li></ol><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><ul><li>通过最优特征子函数获取最优特征的索引</li><li>根据索引从特征集中获取最有特征</li><li>将最优特征添加到决策树中</li><li>删除特征集中的最优特征<blockquote><p>该删除并非真的删除，而是进入递归时，进入递归的特征集不包含最优特征</p></blockquote></li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 从特征标签中选择最优划分标签</span><span class="hljs-comment"># 选择最优标签</span>best_index = get_best_feature(data[:, <span class="hljs-number">0</span>:-<span class="hljs-number">1</span>], np.array(labels), <span class="hljs-literal">False</span>)<span class="hljs-comment"># 获取最优的标签</span>best_feature_label = feature_label[best_index]<span class="hljs-comment"># 根据最优特征的标签生成树</span>decision_tree = &#123;best_feature_label: &#123;&#125;&#125;<span class="hljs-comment"># 删除已使用的标签</span><span class="hljs-comment"># del (feature_label[best_index])</span></code></pre></div><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><ul><li>获取数据集中最优特征的所有数据</li><li>根据数据获取特征标签</li><li>根据特征标签创建分支</li><li>进入递归：<ul><li>划分数据集，作为递归中的数据集参数</li><li>划分特征集，作为递归中的特征集参数</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 得到训练集中所有最优特征的标签</span>feat_value = [item[best_index] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data]<span class="hljs-comment"># 去掉重复值</span><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span>(feat_value):    decision_tree[best_feature_label][value] = create_decision_tree(        split_dataset(data, best_index, value),         split_feature(feature_label, best_index))</code></pre></div><p>两个划分函数：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">split_dataset</span>(<span class="hljs-params">data, index, value</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    对数据集进行分片</span><span class="hljs-string">    :param data: 需要分片的数据集</span><span class="hljs-string">    :param index: 新数据集不需要的某列的索引</span><span class="hljs-string">    :param value: 用于确定新数据集需要某行在 某列[index]对应的值</span><span class="hljs-string">    :return: 新的数据集</span><span class="hljs-string">    &quot;&quot;&quot;</span>    has_split_dataset = []    <span class="hljs-keyword">for</span> col_data <span class="hljs-keyword">in</span> data:        <span class="hljs-comment"># 选择特定行的数据进行切片</span>        <span class="hljs-keyword">if</span> col_data[index] == value:            <span class="hljs-comment"># 取 第 index 个前的所有元素</span>            has_split_col = col_data[:index].tolist()            <span class="hljs-comment"># 再加上第 index 个后面的所有元素</span>            has_split_col.extend(col_data[index + <span class="hljs-number">1</span>:].tolist())            <span class="hljs-comment"># 再将其加入 新的 数据集</span>            has_split_dataset.append(has_split_col)    <span class="hljs-keyword">return</span> np.array(has_split_dataset)<span class="hljs-keyword">def</span> <span class="hljs-title function_">split_feature</span>(<span class="hljs-params">label, index</span>):    error_deal = []    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(label)):        <span class="hljs-keyword">if</span> i != index:            error_deal.append(label[i])    <span class="hljs-keyword">return</span> error_deal</code></pre></div><h4 id="返回决策树"><a href="#返回决策树" class="headerlink" title="返回决策树"></a>返回决策树</h4><p>当分支创建完毕后，就返回决策树。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><hr><p>实验结果输出<strong>各特征的信息增益率</strong>和<strong>决策树模型</strong>（<code>元组结构</code>）。</p><p>信息增益率：</p><div class="code-wrapper"><pre><code class="hljs txt">第 1 个特征的信息增益率为 0.02485642633702430第 2 个特征的信息增益率为 0.03951083542356582第 3 个特征的信息增益率为 0.37700523001147723第 4 个特征的信息增益率为 0.54879494069539858</code></pre></div><p>决策树模型（手动进行了格式化处理）：</p><div class="code-wrapper"><pre><code class="hljs txt">&#123;    &#x27;眼泪数量&#x27;:     &#123;        1: 3,         2:         &#123;            &#x27;散光&#x27;:             &#123;                1:                 &#123;                    &#x27;年龄&#x27;:                     &#123;                        1: 2,                         2: 2,                         3:                         &#123;                            &#x27;症状&#x27;:                             &#123;                                1: 3,                                 2: 2                            &#125;                        &#125;                    &#125;                &#125;,                 2:                 &#123;                    &#x27;症状&#x27;:                     &#123;                        1: 1,                         2:                         &#123;                            &#x27;年龄&#x27;:                             &#123;                                1: 1,                                 2: 3,                                 3: 3                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><blockquote><p>文件中显示的为：</p><p>{‘眼泪数量’: {1: 3, 2: {‘散光’: {1: {‘年龄’: {1: 2, 2: 2, 3: {‘症状’: {1: 3, 2: 2}}}}, 2: {‘症状’: {1: 1, 2: {‘年龄’: {1: 1, 2: 3, 3: 3}}}}}}}}</p></blockquote><blockquote><p>结果均输出在 <code>output.txt</code> 文件中。</p></blockquote><h2 id="实验心得体会"><a href="#实验心得体会" class="headerlink" title="实验心得体会"></a>实验心得体会</h2><hr><p>实验就，很有意思。</p><h3 id="遇到的问题及解决办法"><a href="#遇到的问题及解决办法" class="headerlink" title="遇到的问题及解决办法"></a>遇到的问题及解决办法</h3><hr><p>主要是递归终止条件上的问题，未能很好的明确递归终止的条件，经过一番查询及自己思考后，明确了四个条件：</p><ol><li><strong>子节点的样本属于同一类标签</strong>：返回该类标签</li><li><strong>子节点样本的特征标签相同</strong>：返回出现次数最多的标签</li><li><strong>子节点没有样本</strong>：返回出现次数最多的标签</li><li><strong>特征集为空</strong>：返回出现次数最多的标签</li></ol><p>总的就算两种情况下的终止条件：</p><ol><li>返回出现次数最多的标签：<strong>子节点样本的特征标签相同</strong>、<strong>子节点没有样本</strong>、<strong>特征集为空</strong></li><li>返回该类标签：<strong>子节点的样本属于同一类标签</strong></li></ol><p>还有一个问题就是，也是浪费时间比较多的问题：<strong>特征集在递归中会提前为空，以至于在子节点中的样本还没有完全分类时，就提前结束了递归，返回了决策树</strong>。</p><p>此时的实验结果是：</p><p>{‘眼泪数量’:{1: 3,2:{‘散光’:{1:{‘年龄’:{1: 2,2: 2,3:{‘症状’:{1: 3,2: 2}}}},2: 1}}}}</p><p>仔细审查后发现是特征集在里层递归改变后，外层的递归中也发生了改变。虽然发现了上述问题的原因，但是并没有明白导致该问题是因为什么。</p><p>经过一番思索获得了解决问题的方法，然后得到下面的结果：</p><p>{‘眼泪数量’: {1: 3, 2: {‘散光’: {1: {‘年龄’: {1: 2, 2: 2, 3: {‘年龄’: {1: 3, 2: 2}}}}, 2: {‘症状’: {1: 1, 2: {‘年龄’: {1: 1, 2: 3, 3: 3}}}}}}}}</p><p>{‘眼泪数量’: {1: 3, 2: {‘散光’: {1: {‘年龄’: {1: 2, 2: 2, 3: {‘症状’: {1: 3, 2: 2}}}}, 2: {‘年龄’: {1: 1, 2: {‘症状’: {1: 1, 2: 3, 3: 3}}}}}}}}</p><p>但是并不能解决问题。</p><p>后面根据自己仔细地、一步步试错，发现是特征集的数据类型，在经过删除操作后，会改变其他所有后续执行中的特征集。</p><p>这也就是为什么“特征集在递归中会提前为空，以至于在子节点中的样本还没有完全分类时，就提前结束了递归，返回了决策树”。</p><p>此时便想起特征集的内存地址都是一样的，无论什么操作都是对同一内存地址上的数据进行操作，也就导致这里动、那里变，就导致“特征集提前为空”。</p><p>然后查看特征集的数据类型 —— <strong>list，列表</strong>，一查其存储方式，果然如此</p><blockquote><p>列表如何存储？</p><p>列表本质是动态的数组，列表存储的是每个元素在内存中的地址（即引用），当列表中空白占位低于1&#x2F;3时，会在内存中开辟一块更大的空间，并将旧列表中存储的地址复制到新列表中，旧列表则被销毁，这样就实现了扩容。因为列表存储的是元素的引用这个特性，而引用所占的内存空间是相同的，这样便可以同时存放不同类型的数据了。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><ul><li><a href="https://zhuanlan.zhihu.com/p/126294494">决策树算法</a></li><li><a href="https://blog.csdn.net/sumatch/article/details/103680771">(python)列表和字典的存储方式</a></li><li><a href="https://www.jianshu.com/p/d153130b813f">决策树的基本结构及三个终止条件</a></li><li><a href="https://blog.csdn.net/u010916338/article/details/94653402">信息增益率</a></li><li><a href="https://www.cnblogs.com/EnzoDin/p/12417184.html">机器学习-决策树的基本思想</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【水博客】Ubuntu Update 失败：Release file is not valid yet</title>
    <link href="/2022/05/09/ubuntu-update-failed/"/>
    <url>/2022/05/09/ubuntu-update-failed/</url>
    
    <content type="html"><![CDATA[<p>ᕕ( ᐛ )ᕗ</p><p>(ノﾟ∀ﾟ)ノ举高高</p><p>( へ ﾟ∀ﾟ)べ摔低低</p><p>(&#96;ヮ´ ) 开摆！</p><p>↙(&#96;ヮ´ )↗ 开摆！</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>该问题是在 <code>Windows</code> 下使用 <code>Linux</code> 子系统 <code>Ubuntu</code> 时，执行了 <code>sudo apt update</code> 命令后，就出现问题：</p><p><img src="https://s1.ax1x.com/2022/05/09/OGlyCD.png"></p><div class="code-wrapper"><pre><code class="hljs awk">E: Release file <span class="hljs-keyword">for</span> https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/ubuntu/</span>dists<span class="hljs-regexp">/focal-updates/</span>InRelease is not valid yet (invalid <span class="hljs-keyword">for</span> another <span class="hljs-number">5</span>h <span class="hljs-number">35</span>min <span class="hljs-number">12</span>s). Updates <span class="hljs-keyword">for</span> this repository will not be applied.E: Release file <span class="hljs-keyword">for</span> https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/ubuntu/</span>dists<span class="hljs-regexp">/focal-backports/</span>InRelease is not valid yet (invalid <span class="hljs-keyword">for</span> another <span class="hljs-number">5</span>h <span class="hljs-number">36</span>min <span class="hljs-number">30</span>s). Updates <span class="hljs-keyword">for</span> this repository will not be applied.E: Release file <span class="hljs-keyword">for</span> https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/ubuntu/</span>dists<span class="hljs-regexp">/focal-security/</span>InRelease is not valid yet (invalid <span class="hljs-keyword">for</span> another <span class="hljs-number">5</span>h <span class="hljs-number">34</span>min <span class="hljs-number">27</span>s). Updates <span class="hljs-keyword">for</span> this repository will not be applied.</code></pre></div><p>意思就是：<strong>发布文件尚未生效（在另一个 5 小时 35 分钟 12 秒内无效）。不会应用此存储库的更新。</strong></p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>经过一番搜索后发现了问题 —— 咱 <code>Ubuntu</code> 上的时间与清华大学 <code>TUNA</code> 的软件源镜像的时间不一致，咱的系统时间比它慢了几个小时。</p><blockquote><p>错误的原因是系统上的时间和现实世界的时间不同。</p></blockquote><p>为啥会出现这种问题呢？</p><p>咱电脑安装了双系统的，<code>windows 11</code> + <code>manjaro</code>，上午的时候玩了一会 <code>manjaro</code>，整了一会后，回到 <code>windows 11</code>，发现咱的时间晚了 8 小时，但是咱没有注意到时间的变化，就安装了咱们的 <code>ubuntu</code>，因而该系统的时间也是跟着咱 <code>windows 11</code> 的时间一样，慢了 8 小时。但是这会，咱执行 <code>sudo apt update</code> 是没问题的哦。后来咱就发现电脑时间不对，就赶紧更新了电脑时间，后重新启动了 <code>ubuntu</code>，仍旧执行了 <code>sudo apt update</code> 命令，这会就出现问题了。</p><p>提示：<strong>发布文件尚未生效（在另一个 5 小时 35 分钟 12 秒内无效）。不会应用此存储库的更新。</strong></p><p>执行 <code>date</code> 命令查看时间：</p><div class="code-wrapper"><pre><code class="hljs applescript"><span class="hljs-built_in">date</span></code></pre></div><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628221558.png"></p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>想要解决问题呀，简单的改一下 <code>ubuntu</code> 的时间就好，改成和 <code>windows 11</code> 时间一样就行。</p><p>执行 <code>sudo date -s xxxxxx</code> 设置系统时间</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> date -s <span class="hljs-number">12</span>:<span class="hljs-number">40</span>:<span class="hljs-number">50</span></code></pre></div><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628221120.png"></p><blockquote><p>我这知识时间不对，因而仅修改了时间。<br>若是日期也不对就需要执行：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> date -s <span class="hljs-number">2022</span>-<span class="hljs-number">5</span>-<span class="hljs-number">9</span> <span class="hljs-number">12</span>:<span class="hljs-number">40</span>:<span class="hljs-number">50</span></code></pre></div></blockquote><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628222226.png"></p><p>OK! 问题成功解决。</p><p>(&#96;ヮ´ ) 开摆！</p><p>↙(&#96;ヮ´ )↗ 开摆！</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>水博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows PowerShell 美化</title>
    <link href="/2022/05/06/powershell-beauty/"/>
    <url>/2022/05/06/powershell-beauty/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>这是属于颜狗的胜利，丑不拉几的都不是咱们颜狗想要的，终端也是可以花里胡哨的，人家 <code>linux</code> 可以使用 <code>oh-my-zsh</code>，将他们的 terminal 打扮的花里胡哨的，咱们 <code>windows</code> 下的 <code>terminal</code> 也要站起来。所以大佬们就站出来了，他们做出来了 <code>oh-my-posh</code>，让咱们 <code>windows</code> 也可以使用漂漂亮亮的终端。</p><blockquote><p><code>windows terminal</code> 也可以装饰咱们的终端，但是，不够呀，咱们想要做成 <code>oh-my-zsh</code> 那样的漂漂亮亮。知道<strong>提示符（Prompt）</strong>也需要烧烧的。</p></blockquote><p><a href="https://ohmyposh.dev/">Oh My Posh</a> —— A prompt theme engine for any shell.</p><p><a href="https://ohmyposh.dev/">Oh My Posh</a> 正是这样一款终端 <code>Prompt</code> 个性化工具，虽然肇始于同类工具 <code>Oh My Zsh</code>，但当更新到 <code>5.0</code> 版本时，重新设计的 <code>Oh my posh</code> 已经摆脱平台的桎梏，支持了 <code>Windows、GNU/Linux（WSL）</code>、<code>macOS</code> 三个系统上的 <code>PowerShell</code>、<code>bash</code>、<code>zsh</code> 等终端。</p><p><strong>需要使用</strong> <code>WindowsTerminal</code>。</p><h3 id="安装-Oh-My-Posh"><a href="#安装-Oh-My-Posh" class="headerlink" title="安装 Oh My Posh"></a>安装 Oh My Posh</h3><p>官方文档上写到，<code>Oh My Posh</code> 在 <code>windows</code> 下有三种安装途径：<code>winget</code>、<code>scoop</code>、<code>manual</code>。本文通过 <code>scoop</code> 进行安装。</p><blockquote><p>想使用其他方法的可进官方文档查看 —— <a href="https://ohmyposh.dev/docs/installation/windows">Windows Install Oh My Posh</a></p></blockquote><h4 id="Scoop"><a href="#Scoop" class="headerlink" title="Scoop"></a>Scoop</h4><p>在安装 <code>Oh My Posh</code> 之前，还需要安装一个 <code>Windows</code> 下的包管理工具 —— <code>Scoop</code>。</p><blockquote><p><a href="https://scoop.sh/#/">Scoop</a> 是 Windows 下的一款十分强大的包管理器，可以用来下载和管理各种软件包<br>首次需要打开并运行 <code>PowerShell terminal</code> (version 5.1 or later)。</p></blockquote><p>然后使用下列命令进行安装：</p><div class="code-wrapper"><pre><code class="hljs shell">Set-ExecutionPolicy RemoteSigned -Scope CurrentUser <span class="hljs-meta prompt_"># </span><span class="language-bash">Optional: Needed to run a remote script the first time</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs shell">Invoke-WebRequest get.scoop.sh | Invoke-Expression</code></pre></div><h4 id="Oh-My-Posh"><a href="#Oh-My-Posh" class="headerlink" title="Oh My Posh"></a>Oh My Posh</h4><p>通过 <code>scoop</code> 进行安装：</p><div class="code-wrapper"><pre><code class="hljs shell">scoop install https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/oh-my-posh.json</code></pre></div><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628231646.png"></p><p>当出现图示内容（绿色）时，说明安装成功。</p><blockquote><p>除了使用官方文档提到的方式进行安装。还可以使用 <code>scoop install oh-my-posh</code> 进行安装。<br>这是 <a href="https://scoop.sh/#/apps?q=oh-my-posh">scoop apps</a>中所提到的。<br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628231715.png"><br>使用此种方法时，要跟着文档的方法走哦。<br>安装成功截图：<br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628231734.png"></p></blockquote><blockquote><p>如果想要卸载 Oh My Posh 的话，可以使用命令 <code>scoop uninstall oh-my-posh</code>，进行卸载。<br>卸载成功截图：<br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628231750.png"></p></blockquote><h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628231811.png"></p><p><a href="https://ohmyposh.dev/docs/installation/windows">Oh My Posh</a> 提示到** 要显示所有图标，我们建议使用 <code>Nerd Font</code>。**</p><p>所以咱就下载 <a href="https://www.nerdfonts.com/font-downloads">Nerd Font</a> 字体吧。</p><p>如果不适用 <code>Nerd Font</code> 的话，就会出现这种情况：</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628231833.png"></p><p>可见 icon 们均没有正常显示，而是显示的方框，这也是为什么要使用 <code>Nerd Font</code> 的原因了。</p><blockquote><p>人家自己也说了—— “To display all icons, we recommend the use of a Nerd Font.”</p></blockquote><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628231854.png"></p><p>进入官网后选择一个中意的字体下载就行。我自己使用的 <a href="https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/Hack.zip">Hack Nerd Font</a>（点击可直接下载该字体）</p><p>然后进行安装啦，打开压缩包，选择喜欢的（细、粗）字体，然后点击安装。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628231910.png"></p><blockquote><p>也可以使用 <code>scoop</code> 安装 <code>Nerd Font</code> 字体：</p><div class="code-wrapper"><pre><code class="hljs shell">scoop bucket add nerd-fonts</code></pre></div><p>再在 <a href="https://github.com/matthewjberger/scoop-nerd-fonts/tree/master/bucket">nerd fonts 字体库</a> 找到需要安装的字体。<br>然后就执行命令：</p><div class="code-wrapper"><pre><code class="hljs shell">scoop install Hack-NF</code></pre></div><p>安装完成后需要重启 Windows Terminal 才可以设置字体哦，否则会设置失败。</p></blockquote><p>最后，在 <code>windows terminal</code> 中将字体选择为 <code>Hack Nerd Font</code>，即可。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628231927.png"></p><h4 id="posh-git"><a href="#posh-git" class="headerlink" title="posh-git"></a>posh-git</h4><p><a href="https://github.com/dahlbyk/posh-git">posh-git</a> 可以在 <code>PowerShell</code> 中显示 <code>Git</code> 状态的摘要信息并自动补全 <code>Git</code> 命令。</p><p>通过 <code>scoop</code> 来安装，依次执行命令：</p><div class="code-wrapper"><pre><code class="hljs shell">scoop bucket add extras</code></pre></div><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628231945.png"></p><div class="code-wrapper"><pre><code class="hljs shell">scoop install posh-git</code></pre></div><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232008.png"></p><h4 id="Terminal-Icons"><a href="#Terminal-Icons" class="headerlink" title="Terminal-Icons"></a>Terminal-Icons</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232029.png"></p><p><a href="https://github.com/devblackops/Terminal-Icons">Terminal-Icons</a> 可以在 <code>PowerShell</code> 中显示项目图标并以颜色区分。让你的 <code>Powershell</code> 变得更加的花哨。</p><p>通过 <code>scoop</code> 来安装，依次执行命令：</p><div class="code-wrapper"><pre><code class="hljs shell">scoop bucket add extras</code></pre></div><blockquote><p>前文中已执行过该命令，此次可不在执行。</p></blockquote><div class="code-wrapper"><pre><code class="hljs shell">scoop install terminal-icons</code></pre></div><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232046.png"></p><blockquote><p>安装完成后，还贴心的提示了如何使用呢。</p></blockquote><h3 id="配置-Oh-My-Posh"><a href="#配置-Oh-My-Posh" class="headerlink" title="配置 Oh My Posh"></a>配置 Oh My Posh</h3><p>完成上述的安装后，启动 <code>PowerShell</code> 时并不会默认加载个性化后的配置，因此需要修改 <code>PowerShell</code> 配置文件来让每次启动都加载。</p><p>执行命令打开配置文件：</p><div class="code-wrapper"><pre><code class="hljs shell">notepad $PROFILE</code></pre></div><p>若提示不存在文件，且提示是否创建文件，则直接创建，否则需要手动在 <code>PowerShell</code> 目录下创建一个配置文件再进行编辑。</p><p>若需手动创建配置文件，则依次执行命令：</p><div class="code-wrapper"><pre><code class="hljs shell">mkdir ~\Documents\WindowsPowerShell<span class="hljs-meta prompt_"># </span><span class="language-bash">创建文件夹</span>echo &quot;&quot; &gt; ~\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1<span class="hljs-meta prompt_"># </span><span class="language-bash">创建配置文件</span></code></pre></div><p>最后向配置文件中添加：</p><div class="code-wrapper"><pre><code class="hljs ps1"><span class="hljs-comment"># 使用 oh my posh</span><span class="hljs-built_in">oh</span><span class="hljs-literal">-my-posh</span> init pwsh | <span class="hljs-built_in">Invoke-Expression</span><span class="hljs-comment"># 使用 Terminal-Icons</span><span class="hljs-built_in">Import-Module</span> Terminal<span class="hljs-literal">-Icons</span><span class="hljs-comment"># 使用 posh-git</span><span class="hljs-built_in">Import-Module</span> posh<span class="hljs-literal">-git</span></code></pre></div><p>最后重新启动 <code>PowerShell</code>，或者是输入命令 <code>powershell</code> 即可查看美化后的界面。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232107.png"></p><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p>完成全部安装和配置后，使用的是默认主题，如果想要切换成其它主题，可以去 <a href="https://ohmyposh.dev/docs/themes">官方主题目录</a> 查看各种主题的效果，同时这些主题也被安装在 <code>Oh My Pos</code>h 的主题目录下。</p><p>通过 <code>scoop</code> 安装后的主题目录为：</p><div class="code-wrapper"><pre><code class="hljs shell">~\scoop\apps\oh-my-posh\current\themes</code></pre></div><p>所有主题配置文件都放在这里，并以 <code>.omp.json</code> 结尾，从其它地方下载的主题配置文件也需要放在这里。</p><p>在终端中执行以下命令，就可以查看所有主题在终端中的效果：</p><div class="code-wrapper"><pre><code class="hljs shell">Get-PoshThemes ~\scoop\apps\oh-my-posh\current\themes</code></pre></div><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232123.png"></p><p>选择一个主题的名字，如 <code>paradox</code>，然后编辑 <code>PowerShell</code> 的配置文件，执行命令：</p><div class="code-wrapper"><pre><code class="hljs shell">notepad $PROFILE</code></pre></div><p>将其中的 <code>oh-my-posh init pwsh | Invoke-Expression</code> 加上 <code>--config [主题路径]</code> 参数：</p><div class="code-wrapper"><pre><code class="hljs applescript">oh-<span class="hljs-keyword">my</span>-posh init pwsh <span class="hljs-comment">--config ~\scoop\apps\oh-my-posh\current\themes\paradox.json | Invoke-Expression</span></code></pre></div><p>最后重新启动 <code>PowerShell</code>，或者是输入命令 <code>powershell</code> 即可查看美化后的界面。</p><h3 id="配置-VS-code"><a href="#配置-VS-code" class="headerlink" title="配置 VS code"></a>配置 VS code</h3><p>在 <code>VS code</code> 中也能打开 <code>PowerShell</code> 终端，但是由于没有配置终端字体，因为 icon 们还是没有正常显示，而是显示的方框。</p><p>因此需要设置 <code>VSCode</code> 的终端字体为 <code>Hack Nerd Font</code> 才能正常显示。</p><p>首先打开<strong>设置</strong>，搜索 <code>Terminal &gt; Integrated &gt; Font Family</code>。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232142.png"></p><p>然后添加 <code>Hack Nerd Font</code>。</p><p>最后重新打开终端，或是执行 <code>powershell</code>，即可查看美化界面。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232205.png"></p><h3 id="成品"><a href="#成品" class="headerlink" title="成品"></a>成品</h3><p>完成上述配置，以及对 <code>Windows Terminal</code> 的配置文件进行修改后，咱就获得了一个花哨的 <code>PowerShell</code>:</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232221.png"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://ohmyposh.dev/">Oh My Posh | A prompt theme engine for any shell</a></li><li><a href="https://scoop.sh/#/">Scoop | A command-line installer for Windows</a></li><li><a href="https://sspai.com/post/69911">Oh My Posh：全平台终端提示符个性化工具</a></li><li><a href="https://www.raimis.me/archives/80/">使用 Oh My Posh 来个性化终端</a></li><li><a href="https://blog.davidz.cn/beauty-is-productivity-windows-terminal/">颜值是第一生产力 - Windows Terminal</a></li><li><a href="https://jishuin.proginn.com/p/763bfbd716f5">果然颜值才是第一生产力……power-shell美化</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Terminal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Beauty</tag>
      
      <tag>Terminal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多元线性回归 —— 波士顿房价预测</title>
    <link href="/2022/04/30/ml-boston-housing/"/>
    <url>/2022/04/30/ml-boston-housing/</url>
    
    <content type="html"><![CDATA[<h3 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h3><p><strong>多元线性回归——最小二乘法</strong></p><h3 id="数据集介绍"><a href="#数据集介绍" class="headerlink" title="数据集介绍"></a>数据集介绍</h3><p><strong>波士顿房价数据集</strong></p><p>数据集的获得:</p><ul><li><p><a href="https://www.kaggle.com/datasets/altavish/boston-housing-dataset?resource=download">下载</a> </p></li><li><p>通过包导入</p><blockquote><p>下载获得数据集有点小问题，因而我是用的 <code>包导入</code>。</p>  <div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasetsboston = datasets.load_boston()<span class="hljs-comment"># 将房价信息转成dataFrame格式</span>df_boston_house_data = pd.DataFrame(boston.data, columns=boston.feature_names)df_boston_house_data[<span class="hljs-string">&#x27;PRICE&#x27;</span>] = boston.target<span class="hljs-comment"># 查看数据是否存在空值，从结果来看数据不存在空值。</span><span class="hljs-comment"># print(df_boston_house_data.isnull().sum())</span><span class="hljs-comment"># 查看数据大小</span><span class="hljs-comment"># print(df_boston_house_data.shape)</span><span class="hljs-comment"># 显示数据前5行</span><span class="hljs-comment"># print(df_boston_house_data.head())</span><span class="hljs-comment"># 将数据集写入csv文件</span>df_boston_house_data.to_csv(<span class="hljs-string">&quot;boston_housing_data.csv&quot;</span>, index=<span class="hljs-literal">False</span>, sep=<span class="hljs-string">&#x27;,&#x27;</span>)</code></pre></div></blockquote></li><li><p>该数据集是一个回归问题。每个类的观察值数量是均等的，共有 506 个观察，13 个输入变量（数据集中前13列）和1个输出变量（最后一列）。</p></li><li><p>每条数据包含房屋以及房屋周围的详细信息。其中包含城镇犯罪率，一氧化氮浓度，住宅平均房间数，到中心区域的加权距离以及自住房平均房价等等。</p></li></ul><table><thead><tr><th align="center">属性名</th><th align="center">解释</th><th align="center">类型</th></tr></thead><tbody><tr><td align="center">CRIM</td><td align="center">该镇的人均犯罪率</td><td align="center">连续值</td></tr><tr><td align="center">ZN</td><td align="center">占地面积超过25,000平方呎的住宅用地比例</td><td align="center">连续值</td></tr><tr><td align="center">INDUS</td><td align="center">非零售商业用地比例</td><td align="center">连续值</td></tr><tr><td align="center">CHAS</td><td align="center">是否邻近 Charles River（查尔斯河）</td><td align="center">离散值，1&#x3D;邻近；0&#x3D;不邻近</td></tr><tr><td align="center">NOX</td><td align="center">一氧化氮浓度</td><td align="center">连续值</td></tr><tr><td align="center">RM</td><td align="center">每栋房屋的平均客房数</td><td align="center">连续值</td></tr><tr><td align="center">AGE</td><td align="center">1940年之前建成的自用单位比例</td><td align="center">连续值</td></tr><tr><td align="center">DIS</td><td align="center">到波士顿5个就业中心的加权距离</td><td align="center">连续值</td></tr><tr><td align="center">RAD</td><td align="center">到径向公路的可达性指数</td><td align="center">连续值</td></tr><tr><td align="center">TAX</td><td align="center">全值财产税率</td><td align="center">连续值</td></tr><tr><td align="center">PTRATIO</td><td align="center">学生与教师的比例</td><td align="center">连续值</td></tr><tr><td align="center">B</td><td align="center">$1000(BK - 0.63)^2$，其中BK为黑人占比</td><td align="center">连续值</td></tr><tr><td align="center">LSTAT</td><td align="center">低收入人群占比</td><td align="center">连续值</td></tr><tr><td align="center">MEDV</td><td align="center">同类房屋价格的中位数</td><td align="center">连续值</td></tr></tbody></table><h3 id="实验详解"><a href="#实验详解" class="headerlink" title="实验详解"></a>实验详解</h3><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628230435.png"><br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628230614.png"></p><p>简单的说就是，本次实验需要求得是：<br>$$<br>f(x)&#x3D;w_1x_1 + w_2x_2+…+w_dx_d+b<br>$$<br>中的 $w_1,w_2,…,w_d,b(d&#x3D;13)$，然后通过这 14 个参数与测试集的前 13 个变量进行计算，求得预测的房价。</p><p>参数使用下列算式计算：<br>$$<br>w^* &#x3D; (X^TX)^{-1}X^Ty<br>$$<br>其中：</p><ul><li>$w^*$：是所求的参数组成的一列矩阵</li><li>$X$: 训练集前 13 列变量组成的矩阵</li><li>$y$: 训练集第 14 列变量组成的矩阵</li><li>$X^T$：$X$ 的转置矩阵</li></ul><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>Python 3.9</li><li>编辑器：<code>Pycharm</code></li><li>可使用 <code>numpy</code>、<code>pandas</code>、<code>matplotlib</code> 等基础扩展包，建议使用 <code>anaconda</code> 安装</li><li>不可使用 <code>sklearn</code>、<code>pytorch</code> 等机器学习包</li></ul><h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><ol><li>将数据集拆分成训练集（前 450 个样本）和测试集（后 56 个样本）</li><li>利用多元线性回归模型（<strong>最小二乘法</strong>或者<strong>梯度下降法</strong>均可）对训练数据进行拟合</li><li>对拟合得到的模型在测试集上进行测试，使用均方误差作为实验的准确结果并输出。</li></ol><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><ol><li>数据集获得<br>使用 <code>sklearn</code> 包导入数据集，但是仅仅是导入，写入 csv 文件，后续使用的数据集均是从 csv 文件读取的。<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasetsboston = datasets.load_boston()<span class="hljs-comment"># 将房价信息转成dataFrame格式</span>df_boston_house_data = pd.DataFrame(boston.data, columns=boston.feature_names)df_boston_house_data[<span class="hljs-string">&#x27;PRICE&#x27;</span>] = boston.target<span class="hljs-comment"># 查看数据是否存在空值，从结果来看数据不存在空值。</span><span class="hljs-comment"># print(df_boston_house_data.isnull().sum())</span><span class="hljs-comment"># 查看数据大小</span><span class="hljs-comment"># print(df_boston_house_data.shape)</span><span class="hljs-comment"># 显示数据前5行</span><span class="hljs-comment"># print(df_boston_house_data.head())</span><span class="hljs-comment"># 将数据集写入csv文件</span>df_boston_house_data.to_csv(<span class="hljs-string">&quot;boston_housing_data.csv&quot;</span>, index=<span class="hljs-literal">False</span>, sep=<span class="hljs-string">&#x27;,&#x27;</span>)</code></pre></div></li><li>读取数据集<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_data</span>(<span class="hljs-params">file_path</span>): <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string"> 从文件路径中读取数据集</span><span class="hljs-string"> :param file_path: 文件路径</span><span class="hljs-string"> :return: 返回一个 dataFrame</span><span class="hljs-string"> &quot;&quot;&quot;</span> <span class="hljs-keyword">return</span> pd.read_csv(file_path, sep=<span class="hljs-string">&#x27;,&#x27;</span>)</code></pre></div></li><li>数据集拆分为训练集和测试集<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_training_data</span>(<span class="hljs-params">df, num</span>): <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string"> 从 df 中获得训练集</span><span class="hljs-string"> :param num:</span><span class="hljs-string"> :param df:</span><span class="hljs-string"> :return:</span><span class="hljs-string"> &quot;&quot;&quot;</span> <span class="hljs-comment"># 取测试集的前450项</span> df_training = df.head(num) <span class="hljs-keyword">return</span> df_training <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_test_data</span>(<span class="hljs-params">df, num</span>): <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string"> 从 df 中获取测试集</span><span class="hljs-string"> :param df:</span><span class="hljs-string"> :param num:</span><span class="hljs-string"> :return:</span><span class="hljs-string"> &quot;&quot;&quot;</span> <span class="hljs-comment"># 取数据集的后50项</span> df_test = df.tail(num) <span class="hljs-keyword">return</span> df_test</code></pre></div></li><li>计算学习的模型<br>通过公式进行计算。<br>$$w^* &#x3D; (X^TX)^{-1}X^Ty$$<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">model_calculation</span>(<span class="hljs-params">df_x, df_y</span>): <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string"> 计算模型</span><span class="hljs-string"> :param df_x:</span><span class="hljs-string"> :param df_y:</span><span class="hljs-string"> :return:</span><span class="hljs-string"> &quot;&quot;&quot;</span> <span class="hljs-comment"># 定义大小为 450 的全1数组，用于在 X 矩阵前插入一列全 1 的数</span> one_matrix = np.full(<span class="hljs-built_in">len</span>(df_x), <span class="hljs-number">1</span>, dtype=<span class="hljs-built_in">int</span>) <span class="hljs-comment"># X 第一列插入 一列 1，获得 X 矩阵</span> x_matrix = np.insert(dataframe_to_matrix(df_x), <span class="hljs-number">0</span>, values=one_matrix, axis=<span class="hljs-number">1</span>) <span class="hljs-comment"># y 矩阵</span> y_matrix = dataframe_to_matrix(df_y) <span class="hljs-comment"># X，y 通过计算获得 β 参数</span> beta = np.dot(np.linalg.inv(np.dot(x_matrix.T, x_matrix)), np.dot(x_matrix.T, y_matrix))  <span class="hljs-keyword">return</span> beta</code></pre></div></li><li>通过模型获得房价预测值<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_estimate</span>(<span class="hljs-params">beta, df_test</span>): <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string"></span><span class="hljs-string"> :param beta: β的矩阵</span><span class="hljs-string"> :param df_test: 测试集</span><span class="hljs-string"> :return: 返回预测价格的矩阵（数组）</span><span class="hljs-string"> &quot;&quot;&quot;</span> <span class="hljs-comment"># 先定义预测值的数组，大小等于测试样例大小，用0填充</span> estimate = np.full(<span class="hljs-built_in">len</span>(df_test), <span class="hljs-number">0</span>, dtype=<span class="hljs-built_in">int</span>) <span class="hljs-comment"># 定义大小为56的全1数组，用于在 X 矩阵前插入一列全 1 的数</span> one_matrix = np.full(<span class="hljs-built_in">len</span>(df_test), <span class="hljs-number">1</span>, dtype=<span class="hljs-built_in">int</span>) <span class="hljs-comment"># 将测试集中的前13项作为 矩阵 X 的数</span> test_matrix = dataframe_to_matrix(get_not_last_column(df_test)) <span class="hljs-comment"># X 第一列插入 一列 1</span> test_matrix = np.insert(test_matrix, <span class="hljs-number">0</span>, values=one_matrix, axis=<span class="hljs-number">1</span>) <span class="hljs-comment"># print(np.size(test_matrix, 0))</span> <span class="hljs-comment"># X 中每一行同 β进行计算，获得预测的价格</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(np.size(test_matrix, <span class="hljs-number">0</span>)):     estimate[i] = np.dot(beta, test_matrix[i]) <span class="hljs-comment"># print(estimate)</span> <span class="hljs-keyword">return</span> estimate</code></pre></div></li><li>绘制房价实际值和预测值的比较图<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 绘制预测值与真实值图</span> <span class="hljs-comment"># 规定字体，避免乱码</span> plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">u&#x27;SimHei&#x27;</span>] plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span> plt.plot(true_value_price, color=<span class="hljs-string">&quot;r&quot;</span>, label=<span class="hljs-string">&quot;实际价格&quot;</span>)  <span class="hljs-comment"># 颜色表示</span> plt.plot(estimate_value_price, color=(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), label=<span class="hljs-string">&quot;预测价格&quot;</span>) plt.xlabel(<span class="hljs-string">&quot;测试序号&quot;</span>)  <span class="hljs-comment"># x轴命名表示</span> plt.ylabel(<span class="hljs-string">&quot;价格&quot;</span>)  <span class="hljs-comment"># y轴命名表示</span> plt.title(<span class="hljs-string">&quot;实际值与预测值折线图&quot;</span>) plt.legend()  <span class="hljs-comment"># 增加图例</span> plt.show()  <span class="hljs-comment"># 显示图片</span></code></pre></div></li></ol><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628230727.png"></p><p>分析：</p><p>上述结果仅是一次学习的结果，可见 50 组实际值与预测值之间出入较大，大部分的实际值与预测值之间存在较大的差别。</p><p>不过好在获得了想要的结果。</p><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p>本次实验是机器学习中的第一次尝试，简单又不是难度。</p><p>简单在于，了解实验如何运作后，实现起来还是特别简单的，确实不需要什么数学，当然，前提是，能够看懂如何从数学转换到 python 的代码。</p><p>难度在于，“万事开头难”，以及需要看懂最小二乘法是怎么运作的。</p><p>最后，机器学习还是非常的有趣，值得一直取尝试。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://blog.csdn.net/qq_39384184/article/details/112464468">数理统计：波士顿房地产业的多元线性回归分析</a><blockquote><p>用于看懂<strong>最小二乘法</strong>的使用</p><p>就是看懂如何利用<strong>最小二乘法</strong>预测房价</p></blockquote></li><li><a href="https://blog.csdn.net/qq_43299522/article/details/108704221">机器学习入门实践——线性回归模型（波士顿房价预测）</a><blockquote><p>为实验的实现提供了思路： 如何绘图、数据集来源（之前有发现下载的数据集存在问题，如读取困难或存在错值）</p></blockquote></li><li><a href="https://blog.csdn.net/xwmrqqq/article/details/115354091">Python 矩阵基本运算【numpy】</a> <blockquote><p>python 中矩阵的计算</p></blockquote></li><li><a href="https://blog.csdn.net/windyhigh/article/details/105374996">Python实现最小二乘法的详细步骤</a> <blockquote><p>最小二乘法的使用？</p></blockquote></li></ul><h3 id="实验完整代码"><a href="#实验完整代码" class="headerlink" title="实验完整代码"></a>实验完整代码</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasets<span class="hljs-comment"># 数据集下载地址：https://www.kaggle.com/datasets/altavish/boston-housing-dataset?resource=download</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_boston_house_data</span>():    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    从包中加载波士顿房价数据集</span><span class="hljs-string">    （本不知道有这种包，但是发现下载的数据集在操作上都存在一些问题，因而找到这种方法）</span><span class="hljs-string">    :return:</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># 加载波士顿房价数据集信息</span>    boston = datasets.load_boston()    <span class="hljs-comment"># 将房价信息转成dataFrame格式</span>    df_boston_house_data = pd.DataFrame(boston.data, columns=boston.feature_names)    df_boston_house_data[<span class="hljs-string">&#x27;PRICE&#x27;</span>] = boston.target    <span class="hljs-comment"># 查看数据是否存在空值，从结果来看数据不存在空值。</span>    <span class="hljs-comment"># print(df_boston_house_data.isnull().sum())</span>    <span class="hljs-comment"># 查看数据大小</span>    <span class="hljs-comment"># print(df_boston_house_data.shape)</span>    <span class="hljs-comment"># 显示数据前5行</span>    <span class="hljs-comment"># print(df_boston_house_data.head())</span>    <span class="hljs-comment"># 将数据集写入csv文件</span>    df_boston_house_data.to_csv(<span class="hljs-string">&quot;boston_housing_data.csv&quot;</span>, index=<span class="hljs-literal">False</span>, sep=<span class="hljs-string">&#x27;,&#x27;</span>)    <span class="hljs-comment"># return df_boston_house_data</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_data_describe</span>(<span class="hljs-params">df</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string"></span><span class="hljs-string">    :param df:</span><span class="hljs-string">    :return:</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># 查看数据的描述信息，在描述信息里可以看到每个特征的均值，最大值，最小值等信息</span>    df.describe()<span class="hljs-keyword">def</span> <span class="hljs-title function_">read_data</span>(<span class="hljs-params">file_path</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    从文件路径中读取数据集</span><span class="hljs-string">    :param file_path: 文件路径</span><span class="hljs-string">    :return: 返回一个 dataFrame</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-keyword">return</span> pd.read_csv(file_path, sep=<span class="hljs-string">&#x27;,&#x27;</span>)<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_training_data</span>(<span class="hljs-params">df, num</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    从 df 中获得训练集</span><span class="hljs-string">    :param num:</span><span class="hljs-string">    :param df:</span><span class="hljs-string">    :return:</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># 取测试集的前450项</span>    df_training = df.head(num)    <span class="hljs-comment"># print(df_training)</span>    <span class="hljs-keyword">return</span> df_training<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_test_data</span>(<span class="hljs-params">df, num</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    从 df 中获取测试集</span><span class="hljs-string">    :param df:</span><span class="hljs-string">    :param num:</span><span class="hljs-string">    :return:</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># 取数据集的后50项</span>    df_test = df.tail(num)    <span class="hljs-comment"># print(df_test)</span>    <span class="hljs-keyword">return</span> df_test<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_last_column</span>(<span class="hljs-params">df</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    获取df最后一列的数据</span><span class="hljs-string">    :param df:</span><span class="hljs-string">    :return:</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># print(df.iloc[:, -1])</span>    <span class="hljs-keyword">return</span> df.iloc[:, -<span class="hljs-number">1</span>]<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_not_last_column</span>(<span class="hljs-params">df</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    获取df的除最后一列的所有数据</span><span class="hljs-string">    :param df:</span><span class="hljs-string">    :return:</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># print(len(df))</span>    <span class="hljs-comment"># print(df.iloc[:, :(df.shape[1] - 1)])</span>    <span class="hljs-keyword">return</span> df.iloc[:, :(df.shape[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>)]<span class="hljs-keyword">def</span> <span class="hljs-title function_">dataframe_to_matrix</span>(<span class="hljs-params">df</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    将df转换为多维矩阵</span><span class="hljs-string">    其实就是转为 numpy 数组</span><span class="hljs-string">    :param df: 需要转换的 df</span><span class="hljs-string">    :return:</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-keyword">return</span> df.to_numpy()<span class="hljs-keyword">def</span> <span class="hljs-title function_">model_calculation</span>(<span class="hljs-params">df_x, df_y</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    计算模型</span><span class="hljs-string">    :param df_x: 训练集的前13列</span><span class="hljs-string">    :param df_y: 训练集的第14列</span><span class="hljs-string">    :return:</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># 定义大小为 450 的全1数组，用于在 X 矩阵前插入一列全 1 的数</span>    one_matrix = np.full(<span class="hljs-built_in">len</span>(df_x), <span class="hljs-number">1</span>, dtype=<span class="hljs-built_in">int</span>)    <span class="hljs-comment"># X 第一列插入 一列 1，获得 X 矩阵</span>    x_matrix = np.insert(dataframe_to_matrix(df_x), <span class="hljs-number">0</span>, values=one_matrix, axis=<span class="hljs-number">1</span>)    <span class="hljs-comment"># y 矩阵</span>    y_matrix = dataframe_to_matrix(df_y)    <span class="hljs-comment"># X，y 通过计算获得 β 参数</span>    beta = np.dot(np.linalg.inv(np.dot(x_matrix.T, x_matrix)), np.dot(x_matrix.T, y_matrix))    <span class="hljs-comment"># print(beta)</span>    <span class="hljs-keyword">return</span> beta<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_estimate</span>(<span class="hljs-params">beta, df_test</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string"></span><span class="hljs-string">    :param beta: β的矩阵</span><span class="hljs-string">    :param df_test: 测试集</span><span class="hljs-string">    :return: 返回预测价格的矩阵（数组）</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># 先定义预测值的数组，大小等于测试样例大小，用0填充</span>    estimate = np.full(<span class="hljs-built_in">len</span>(df_test), <span class="hljs-number">0</span>, dtype=<span class="hljs-built_in">int</span>)    <span class="hljs-comment"># 定义大小为56的全1数组，用于在 X 矩阵前插入一列全 1 的数</span>    one_matrix = np.full(<span class="hljs-built_in">len</span>(df_test), <span class="hljs-number">1</span>, dtype=<span class="hljs-built_in">int</span>)    <span class="hljs-comment"># 将测试集中的前13项作为 矩阵 X 的数</span>    test_matrix = dataframe_to_matrix(get_not_last_column(df_test))    <span class="hljs-comment"># X 第一列插入 一列 1</span>    test_matrix = np.insert(test_matrix, <span class="hljs-number">0</span>, values=one_matrix, axis=<span class="hljs-number">1</span>)    <span class="hljs-comment"># print(np.size(test_matrix, 0))</span>    <span class="hljs-comment"># X 中每一行同 β进行计算，获得预测的价格</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(np.size(test_matrix, <span class="hljs-number">0</span>)):        estimate[i] = np.dot(beta, test_matrix[i])    <span class="hljs-comment"># print(estimate)</span>    <span class="hljs-keyword">return</span> estimate<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    path = <span class="hljs-string">&#x27;boston_housing_data.csv&#x27;</span>    <span class="hljs-comment"># 读取csv文件，存入 df</span>    df_housing_data = read_data(path)    <span class="hljs-comment"># 获取训练集</span>    df_training_data = get_training_data(df_housing_data, <span class="hljs-number">450</span>)    <span class="hljs-comment"># 获取测试集</span>    df_test_data = get_test_data(df_housing_data, <span class="hljs-number">56</span>)    <span class="hljs-comment"># 获取训练来的 参数</span>    beta_matrix = model_calculation(get_not_last_column(df_training_data), get_last_column(df_training_data))    <span class="hljs-comment"># 测试集与训练结果参数计算获得 预测价格</span>    estimate_value_price = get_estimate(beta_matrix, df_test_data)    <span class="hljs-comment"># 实际价格</span>    true_value_price = dataframe_to_matrix(get_last_column(df_test_data))    <span class="hljs-comment"># 绘制预测值与真实值图</span>    <span class="hljs-comment"># 规定字体，避免乱码</span>    plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">u&#x27;SimHei&#x27;</span>]    plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span>    plt.plot(true_value_price, color=<span class="hljs-string">&quot;r&quot;</span>, label=<span class="hljs-string">&quot;实际价格&quot;</span>)  <span class="hljs-comment"># 颜色表示</span>    plt.plot(estimate_value_price, color=(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), label=<span class="hljs-string">&quot;预测价格&quot;</span>)    plt.xlabel(<span class="hljs-string">&quot;测试序号&quot;</span>)  <span class="hljs-comment"># x轴命名表示</span>    plt.ylabel(<span class="hljs-string">&quot;价格&quot;</span>)  <span class="hljs-comment"># y轴命名表示</span>    plt.title(<span class="hljs-string">&quot;实际值与预测值折线图&quot;</span>)    plt.legend()  <span class="hljs-comment"># 增加图例</span>    plt.show()  <span class="hljs-comment"># 显示图片</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 下 VS code 配置 C/C++ 环境</title>
    <link href="/2022/04/19/vscode-env-c-new/"/>
    <url>/2022/04/19/vscode-env-c-new/</url>
    
    <content type="html"><![CDATA[<h2 id="阅读本文后应该可以顺利的在-Windows-系统下配置好-VS-code-的-C-x2F-C-环境。"><a href="#阅读本文后应该可以顺利的在-Windows-系统下配置好-VS-code-的-C-x2F-C-环境。" class="headerlink" title="阅读本文后应该可以顺利的在 Windows 系统下配置好 VS code 的 C&#x2F;C++ 环境。"></a>阅读本文后应该可以顺利的在 Windows 系统下配置好 VS code 的 C&#x2F;C++ 环境。</h2><p>若是继续快速配置环境，可直接到 <strong><a href="#%E5%8F%AF%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">可直接使用的配置文件</a></strong> 处复制代码到对应文件，然后即可使用。</p><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>默认已经安装好 <code>VS code</code> 和 Windows 下的 <code>C/C++</code> 编译器 —— <code>MinGW</code>。</p><p>若是未能安装，那就自行安装吧。<del>（自己找教程去）</del></p><p>(&#96;ヮ´ ) 开摆！</p><p>安装好了的话，那就开整。</p><p>ᕕ( ᐛ )ᕗ</p><h3 id="所需插件"><a href="#所需插件" class="headerlink" title="所需插件"></a>所需插件</h3><p>配置环境只需要两个插件：</p><ul><li><code>C/C++</code> : 让 <code>VS code</code> 支持 <code>C/C++</code> 语法和编译调试</li><li><code>C/C++ Extension Pack</code> : 暂时不知道</li></ul><h3 id="基础环境配置"><a href="#基础环境配置" class="headerlink" title="基础环境配置"></a>基础环境配置</h3><p>配置好 <code>C/C++</code> 环境大致也就需要几个步骤：</p><h4 id="使用-VS-code-打开一个文件夹作为工作路径"><a href="#使用-VS-code-打开一个文件夹作为工作路径" class="headerlink" title="使用 VS code 打开一个文件夹作为工作路径"></a>使用 <code>VS code</code> 打开一个文件夹作为<strong>工作路径</strong></h4><p>   该文件夹可以包含子文件夹，或是创建子文件夹，配置好环境后，该文件夹会多一个 <code>.vscode</code>，该文件夹会有几个 <code>json</code> 文件。</p><h4 id="在该文件夹目录中创建-C-C-文件，并进行编辑"><a href="#在该文件夹目录中创建-C-C-文件，并进行编辑" class="headerlink" title="在该文件夹目录中创建 C/C++ 文件，并进行编辑"></a>在该文件夹目录中创建 <code>C/C++</code> 文件，并进行编辑</h4><p>   简单的编辑一下就好，比如输出个 Hello World。</p><h4 id="首先进行配置生成任务"><a href="#首先进行配置生成任务" class="headerlink" title="首先进行配置生成任务"></a>首先进行配置生成任务</h4><p>   选择已经编辑好的 C&#x2F;C++ 文件，点击顶部菜单栏的 <code>终端(T) &gt; 配置任务</code>。</p><p>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172419.png"></p><p>   在选择 <code>C/C++: gcc.exe 生成活动文件</code>。</p><blockquote><p>因为自己使用 <code>C</code> 文件进行配置任务，因为配置任务时显示的是 <code>gcc.exe</code>。<br>若是使用 <code>C++</code> 文件进行配置任务，会显示 <code>g++.exe</code>。<br><code>gcc.exe</code> 是 <code>C</code> 的编译器<br><code>g++.exe</code> 是 <code>C++</code> 的编译器，但是也可以编译 <code>C</code><br>不过这一点没什么大问题，都可以在后续的 <code>json</code> 文件中修改</p></blockquote><p>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172452.png"></p><p>   之后会自动生成一个 <code>tasks.json</code> 文件，位于 <code>.vacode</code> 文件夹，如图：</p><p>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172512.png"></p><p>   进入 <code>tasks.json</code>:</p><p>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172535.png"></p><p>   其中：</p><ul><li><p>type: 要自定义的任务类型<br>  可支持类型： <code>cppbuild</code>, <code>shell</code>, <code>process</code>.</p></li><li><p>label: 任务名称。即是你将在任务列表中看到的值（就是上上上图中可见的：C&#x2F;C++：gcc.exe 生成活动文件）；你可以给它取任何你喜欢的名字。</p><blockquote><p>该值还和后续调试任务有关</p></blockquote></li><li><p>command: 执行编译器或编译脚本的路径。</p></li><li><p>args: 其他要传给编译器或者编译脚本的参数。</p></li><li><p><del>options：其他命令选项。</del></p><ul><li><del>cwd: 已执行程序或脚本的当前工作目录。如果省略，则使用当前代码的工作区根。</del></li></ul></li><li><p>problemMatcher: 要使用的问题匹配程序。可以是一个字符串或一个问题匹配程序定义，也可以是一个字符串数组和多个问题匹配程序。</p></li><li><p>group: build: 将任务标记为可通过“运行生成任务”命令访问的生成任务。</p></li><li><p>detail: 任务的其他详细信息。</p></li></ul><p>   <code>tasks.json</code>:<br>   <div class="code-wrapper"><pre><code class="hljs json">  <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.0.0&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;tasks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppbuild&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C/C++: gcc.exe 生成活动文件&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:/MinGW/bin/gcc.exe&quot;</span><span class="hljs-punctuation">,</span>                    <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;-fdiagnostics-color=always&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 彩色警告</span><span class="hljs-string">&quot;-g&quot;</span><span class="hljs-punctuation">,</span>                         <span class="hljs-comment">// 编译器编译时，产生调试信息</span><span class="hljs-string">&quot;$&#123;file&#125;&quot;</span><span class="hljs-punctuation">,</span>                    <span class="hljs-comment">// 当前文件名(含有文件路径)</span><span class="hljs-string">&quot;-o&quot;</span><span class="hljs-punctuation">,</span>                         <span class="hljs-comment">// 编译时输出的位置</span><span class="hljs-string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>                                         <span class="hljs-comment">// 编译输出的可执行文件</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;$gcc&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;detail&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;编译器: C:/MinGW/bin/gcc.exe&quot;</span>   <span class="hljs-punctuation">&#125;</span>   <span class="hljs-punctuation">]</span>  <span class="hljs-punctuation">&#125;</span></code></pre></div></p><p>   然后点击 <code>终端(T) &gt; 运行生成任务</code>，如图：</p><blockquote><p>当然可以使用快捷键 <code>Shift + Ctrl + B</code>，快速 <code>运行生成任务</code>。</p></blockquote><p>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172556.png"></p><p>   此时，VS code 下部的终端就会显示 <code>Executing task</code>， 即开始编译 C 文件并获得 exe 文件。</p><blockquote><p>从图中可见，运行的任务将 tasks.json 中的部分内容显示出来。<br>如：</p><ul><li>label</li><li>编译的指令<blockquote><p>成功执行指令后，会显示<code>生成已成功完成</code>。<br>未能成功执行时，则会显示<code>错误信息</code>。</p></blockquote></li></ul></blockquote><p>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172612.png"></p><p>   成功之后，在文件夹中会多出对应的 exe 文件，如图：</p><p>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172629.png"></p><p>   强调一下，将上述任务完成后，我们只是利用 tasks.json 配置文件将 C 文件编译成了可执行的 exe 文件后续没有执行 该 exe 文件。想要查看运行结果的话：有两种办法：</p><ul><li>在 VS code 的终端中输入相应的指令以执行文件</li><li>到对应的文件夹中找到该 exe 文件，直接执行。</li></ul><p>   若是需要对代码进行调试，就需要配置接下来的 <code>launch.json</code> 文件。</p><h4 id="其次进行配置调试任务"><a href="#其次进行配置调试任务" class="headerlink" title="其次进行配置调试任务"></a>其次进行配置调试任务</h4><p>   点击 <code>运行(R) &gt; 添加配置</code>，如图:</p><p>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172731.png"></p><p>   再次点击图中选项</p><blockquote><p>由于不明原因，我这点击该选项后，直接生成了 launch.json 文件，但是是空的，和其他教程不一样，不过问题不大，就是配置复杂了一点。<br>↙(&#96;ヮ´ )↗ 开摆！</p></blockquote><p>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172748.png"><br>   生成 launch.json 文件。<br>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172803.png"></p><p>   空的？没事，点击右边的 <code>添加配置</code>，选择 <code>C/C++: (gdb) 启动</code>。</p><blockquote><p>之所以选择该选项，是在我尝试了各选项的配置后做出的决定。<br>原因吗：</p><ul><li>功能刚好，基本满足要求</li><li>没有复杂 <del>（可能无用的）</del> 的配置选项</li></ul></blockquote><p>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172825.png"></p><p>   然后生成的配置文件大致如图所示，不过还不能直接用，还需要修改其中部分字段。<br>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172846.png"></p><p>   各字段的作用：</p><ul><li><code>name</code>: 配置名称，用于显示在启动配置的下拉菜单中。</li><li><code>type</code>: 配置类型。</li><li><code>request</code>: 请求配置类型。可是 <code>启动</code> 或 <code>附加</code>，对应 <code>launch</code> 和 <code>attach</code>。</li><li><code>program</code>: 程序可执行的完整路径。</li><li><code>args</code>: 传递给程序的命令行参数。</li><li><code>stopAtEntry</code>: 可选参数。如果是为 <code>true</code>，则调试程序就会在目标的入口点处停止。如果传递了 <code>processId</code>，则不起任何作用。</li><li><code>cwd</code>: 目标的工作目录。</li><li><code>environment</code>: 要添加到程序环境的环境变量。</li><li><code>externalConsole</code>: 如果为 <code>true</code>，则为调试对象启动控制台；为 <code>false</code>，则会在 <code>linux</code> 和 <code>Windows</code> 上显示在集成控制台中。<blockquote><p>意思就是：<br><code>true</code>: 额外开启一个控制台来显示结果。<br><code>false</code>: 直接在 VS code 的集成终端显示结果。 </p></blockquote></li><li><code>MIMode</code>: 指示 <code>MIDebugEngine</code> 要连接到的控制台调试程序。允许的值，<code>gdb</code>、<code>lldb</code>。</li><li><code>miDubuggerPath</code>: <code>MI</code> 调试程序（如 <code>gdb</code>）的路径。如若未指定（如 <code>gdb.exe</code>），将首先在路径中搜索调试程序。</li><li><code>setupCommands</code>: 为了安装基础调试程序而执行一个或多个 <code>GDB/LLDB</code> 命令。<ul><li><code>description</code>: 此命令的可选说明。</li><li><code>text</code>: 要执行的调试命令。</li><li><code>ignoreFailures</code>: 如果为 <code>true</code>，则会忽略该命令执行失败。默认值：<code>false</code>。</li></ul></li></ul><p>   对 <code>program</code>、<code>miDebuggerPath</code>、<code>externalConsole</code> 等字段进行修改后。<br>   可得正常使用的 <code>launch.json</code>:</p><blockquote><p>在该文件中，加了一新的字段 <code>preLaunchTask</code>，用于调试时从新生成 exe 文件，并根据新的 exe 文件进行调试。<br>否则，在对代码进行修改后，直接使用调试功能，你会发现，执行的是之前的程序，而非修改后的程序。</p><p>preLaunchTask: 调试会话开始前要运行的任务。</p></blockquote>   <div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 使用 IntelliSense 了解相关属性。 </span> <span class="hljs-comment">// 悬停以查看现有属性的描述。</span> <span class="hljs-comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span> <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>     <span class="hljs-punctuation">&#123;</span>         <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(gdb) 启动&quot;</span><span class="hljs-punctuation">,</span>         <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppdbg&quot;</span><span class="hljs-punctuation">,</span>         <span class="hljs-attr">&quot;preLaunchTask&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C/C++: gcc.exe 生成活动文件&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 在 launch 之前的任务名，</span>                                                        <span class="hljs-comment">// 即 在launch 之前先执行 tasks.json 的任务</span>                                                        <span class="hljs-comment">// 用于调试时从新生成 exe 文件，并根据新的 exe 文件进行调试</span>                                                        <span class="hljs-comment">// 因而该字段内容需和 tasks.json 中的 label 一样，如此才能正确的先生成再调试</span>         <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span>         <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="hljs-punctuation">,</span>         <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>         <span class="hljs-attr">&quot;stopAtEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span>         <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="hljs-punctuation">,</span>         <span class="hljs-attr">&quot;environment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>         <span class="hljs-attr">&quot;externalConsole&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>         <span class="hljs-attr">&quot;MIMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gdb&quot;</span><span class="hljs-punctuation">,</span>         <span class="hljs-attr">&quot;miDebuggerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:/MinGW/bin/gdb.exe&quot;</span><span class="hljs-punctuation">,</span>         <span class="hljs-attr">&quot;setupCommands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>               <span class="hljs-punctuation">&#123;</span>                  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;为 gdb 启用整齐打印&quot;</span><span class="hljs-punctuation">,</span>                  <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span><span class="hljs-punctuation">,</span>                  <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span>               <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>               <span class="hljs-punctuation">&#123;</span>                  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span>  <span class="hljs-string">&quot;将反汇编风格设置为 Intel&quot;</span><span class="hljs-punctuation">,</span>                  <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="hljs-punctuation">,</span>                  <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span>                <span class="hljs-punctuation">&#125;</span>            <span class="hljs-punctuation">]</span>        <span class="hljs-punctuation">&#125;</span>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>   此时会到 C 文件，就可以点击 <code>运行(R) &gt; 启动调试</code> 来调试程序，快捷键：<code>F5</code>，或是 <code>运行(R) &gt; 以非调试模式运行</code> 来运行程序（不调试），快捷键：<code>Ctrl + F5</code>。结果如图：</p><p>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172909.png"></p><p>至此，Windows 系统下 VS code 的 C&#x2F;C++ 环境算是配置完成了。</p><p>好耶！</p><p>ᕕ( ᐛ )ᕗ</p><h3 id="进阶环境配置"><a href="#进阶环境配置" class="headerlink" title="进阶环境配置"></a>进阶环境配置</h3><p>我所谓的进阶配置，主要指的是，对 <code>tasks.json</code> 中使用更多的变量参数。</p><h4 id="预定义变量-Predefined-variables"><a href="#预定义变量-Predefined-variables" class="headerlink" title="预定义变量 Predefined variables"></a>预定义变量 Predefined variables</h4><p>支持以下预定义变量：</p><ul><li><code>$&#123;workspaceFolder&#125;</code> - 在 <code>VS Code</code> 中打开的文件夹的路径</li><li><code>$&#123;workspaceFolderBasename&#125;</code> - 在 <code>VS Code</code> 中打开的文件夹的名称，不带任何斜线 (&#x2F;)</li><li><code>$&#123;file&#125;</code> - 当前打开的文件</li><li><code>$&#123;fileWorkspaceFolder&#125;</code> - 当前打开文件的工作区文件夹</li><li><code>$&#123;relativeFile&#125;</code> - 当前打开的相对于 <code>workspaceFolder</code> 的文件</li><li><code>$&#123;relativeFileDirname&#125;</code> - 当前打开文件相对于 <code>workspaceFolder</code> 的目录名</li><li><code>$&#123;fileBasename&#125;</code> - 当前打开文件的基本名称</li><li><code>$&#123;fileBasenameNoExtension&#125;</code> - 当前打开的文件的基本名称，没有文件扩展名</li><li><code>$&#123;fileDirname&#125;</code> - 当前打开文件的目录名</li><li><code>$&#123;fileExtname&#125;</code> - 当前打开文件的扩展名</li><li><code>$&#123;cwd&#125;</code> - 启动 <code>VS Code</code> 时任务运行器的当前工作目录</li><li><code>$&#123;lineNumber&#125;</code> - 活动文件中当前选定的行号</li><li><code>$&#123;selectedText&#125;</code> - 活动文件中当前选定的文本</li><li><code>$&#123;execPath&#125;</code> - 正在运行的 <code>VS Code</code> 可执行文件的路径</li><li><code>$&#123;defaultBuildTask&#125;</code> - 默认构建任务的名称</li><li><code>$&#123;pathSeparator&#125;</code> - 操作系统用来分隔文件路径中的组件的字符</li></ul><h5 id="预定义变量示例-Predefined-variables-examples"><a href="#预定义变量示例-Predefined-variables-examples" class="headerlink" title="预定义变量示例 Predefined variables examples"></a>预定义变量示例 Predefined variables examples</h5><p>假设您有以下要求：</p><ol><li>位于 <code>/home/your-username/your-project/folder/file.ext</code> 的文件在您的编辑器中打开；</li><li>目录 <code>/home/your-username/your-project</code> 作为您的根工作区打开。</li></ol><p>因此，每个变量都将具有以下值：</p><ul><li><code>$&#123;workspaceFolder&#125;</code> - <code>/home/your-username/your-project</code></li><li><code>$&#123;workspaceFolderBasename&#125;</code> - <code>你的项目</code></li><li><code>$&#123;file&#125;</code> - <code>/home/your-username/your-project/folder/file.ext</code></li><li><code>$&#123;fileWorkspaceFolder&#125;</code> - <code>/home/your-username/your-project</code></li><li><code>$&#123;relativeFile&#125;</code> - <code>folder/file.ext</code></li><li><code>$&#123;relativeFileDirname&#125;</code> - <code>folder</code></li><li><code>$&#123;fileBasename&#125; - file.ext</code></li><li><code>$&#123;fileBasenameNoExtension&#125;</code> - <code>file</code></li><li><code>$&#123;fileDirname&#125;</code> - <code>/home/your-username/your-project/folder</code></li><li><code>$&#123;fileExtname&#125;</code> - <code>.ext</code></li><li><code>$&#123;lineNumber&#125;</code> - 光标的行号</li><li><code>$&#123;selectedText&#125;</code> - 在代码编辑器中选择的文本</li><li><code>$&#123;execPath&#125;</code> - Code.exe 的位置</li><li><code>$&#123;pathSeparator&#125;</code> - <code>/</code> 在 macOS 或 linux 上，<code>\</code> 在 Windows 上</li></ul><blockquote><p>Tip:<br>在 tasks.json 和 launch.json 的字符串值中使用 IntelliSense 以获取预定义变量的完整列表</p></blockquote><h5 id="每个工作区文件夹范围内的变量-Variables-scoped-per-workspace-folder"><a href="#每个工作区文件夹范围内的变量-Variables-scoped-per-workspace-folder" class="headerlink" title="每个工作区文件夹范围内的变量 Variables scoped per workspace folder"></a>每个工作区文件夹范围内的变量 Variables scoped per workspace folder</h5><p>通过将根文件夹的名称附加到变量（用冒号分隔），可以访问工作区的同级根文件夹。 如果没有根文件夹名称，则该变量的作用域为使用它的同一文件夹。</p><p>例如，在具有文件夹 <code>Server</code> 和 <code>Client</code> 的多根工作区中，<code>$&#123;workspaceFolder:Client</code>} 指的是 <code>Client</code> 根的路径。</p><h4 id="环境变量-Environment-variables"><a href="#环境变量-Environment-variables" class="headerlink" title="环境变量 Environment variables"></a>环境变量 Environment variables</h4><p>您还可以通过 <code>$&#123;env:Name&#125;</code> </p><p>语法（例如，<code>$&#123;env:USERNAME&#125;</code>）引用环境变量。</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Launch Program&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/app.js&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;$&#123;env:USERNAME&#125;&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span></code></pre></div><h3 id="可直接使用的配置文件"><a href="#可直接使用的配置文件" class="headerlink" title="可直接使用的配置文件"></a>可直接使用的配置文件</h3><blockquote><p>PS:<br>该配置文件暂时仅是支持单个文件的编译<br>多个文件的编译请详细阅读本篇文章</p></blockquote><p>简要介绍一下两个文件表示的工作流程：</p><ul><li><code>tasks.json</code> 是将 C&#x2F;C++ 文件编译成 exe 文件，其路径与 C&#x2F;C++ 文件相同，即在同一文件夹</li><li><code>launch.json</code> 会先将文件编译成 exe 可执行文件，然后再进行调试</li></ul><p>所以，使用流程：</p><ul><li>在工作文件夹下创建 <code>.vscode</code> 文件夹，</li><li>再在 <code>.vscide</code> 下创建俩文件，并将下述代码复制进去<ul><li><code>tasks.json</code></li><li><code>launch.json</code></li></ul></li><li>按 <code>F5</code> 进行调试</li><li>按 <code>Ctrl + F5</code> 非调试运行</li></ul><p><code>tasks.json</code>:</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.0.0&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;tasks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppbuild&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;g++.exe 生成活动文件&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:/MinGW/bin/g++.exe&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 编译器路径</span>                                            <span class="hljs-comment">// 需要自行修改</span>                     <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;-fdiagnostics-color=always&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;-g&quot;</span><span class="hljs-punctuation">,</span>                         <span class="hljs-string">&quot;$&#123;file&#125;&quot;</span><span class="hljs-punctuation">,</span>                    <span class="hljs-string">&quot;-o&quot;</span><span class="hljs-punctuation">,</span>                         <span class="hljs-comment">// 编译时输出的位置</span><span class="hljs-string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>                                          <span class="hljs-comment">// 编译输出的可执行文件</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;$gcc&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;detail&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;编译器: C:/MinGW/bin/g++.exe&quot;</span>   <span class="hljs-punctuation">&#125;</span>   <span class="hljs-punctuation">]</span>   <span class="hljs-punctuation">&#125;</span></code></pre></div><p><code>launch.json</code>:</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-comment">// 使用 IntelliSense 了解相关属性。 </span>    <span class="hljs-comment">// 悬停以查看现有属性的描述。</span>    <span class="hljs-comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>        <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(gdb) 启动&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppdbg&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;preLaunchTask&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;g++.exe 生成活动文件&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 在 launch 之前的任务名，</span>                                                           <span class="hljs-comment">// 即 在launch 之前先执行 tasks.json 的任务</span>                                                           <span class="hljs-comment">// 用于调试时从新生成 exe 文件，并根据新的 exe 文件进行调试</span>                                                           <span class="hljs-comment">// 因而该字段内容需和 tasks.json 中的 label 一样，如此才能正确的先生成再调试</span>            <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;environment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;externalConsole&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;MIMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gdb&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;miDebuggerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:/MinGW/bin/gdb.exe&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 调试器的路径</span>                                                      <span class="hljs-comment">// 需要自行修改</span>            <span class="hljs-attr">&quot;setupCommands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>                  <span class="hljs-punctuation">&#123;</span>                     <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;为 gdb 启用整齐打印&quot;</span><span class="hljs-punctuation">,</span>                     <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span><span class="hljs-punctuation">,</span>                     <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span>                  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>                  <span class="hljs-punctuation">&#123;</span>                     <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span>  <span class="hljs-string">&quot;将反汇编风格设置为 Intel&quot;</span><span class="hljs-punctuation">,</span>                     <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="hljs-punctuation">,</span>                     <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span>                   <span class="hljs-punctuation">&#125;</span>               <span class="hljs-punctuation">]</span>           <span class="hljs-punctuation">&#125;</span>       <span class="hljs-punctuation">]</span>   <span class="hljs-punctuation">&#125;</span></code></pre></div><p>ᕕ( ᐛ )ᕗ</p><p>现在你就可以畅想 vscode 的 C 语言编程了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://code.visualstudio.com/docs/cpp/config-mingw#_build-helloworldcpp">Visual Studio Code 官方文档 | GCC on Windows</a></li><li><a href="https://code.visualstudio.com/docs/editor/variables-reference">Visual Studio Code 官方文档 | Variables Reference</a></li><li><a href="https://blog.51cto.com/u_14202100/5188327">【开发环境】Ubuntu 中使用 VSCode 开发 C&#x2F;C++ ⑤ ( tasks.json 中的 args 数组配置分析 | 编译并执行 C++ 程序 )</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
      <tag>VS code</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【水博客】VS code Markdown 导出 PDF 时，数学公式未能正确导出</title>
    <link href="/2022/04/18/vscode-markdown-pdf-math-latex-error/"/>
    <url>/2022/04/18/vscode-markdown-pdf-math-latex-error/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>本次出现的是问题是在写作业时发现的。</p><p>虽然已经用 <code>MarkDown</code> 很久了，也时常将 MD 文件导出成 PDF，但是之前使用的都是实时渲染的软件，如 <code>Typora</code> 等，来完成上述的工作，所以就没有出现本文博客需要解决的问题。</p><p>后续由于 <code>Typora</code> 收费 <del>（当然你还可以去官网找 <code>1.0</code> 版本之前的版本，是不收费）</del>，以及其导出的 PDF 并不是很合我的审美<del>（颜狗去死吧）</del>，，我就放弃使用 <code>Typora</code>，经过几天的查找后，还是发现 <code>VS code</code> + 插件导出的 PDF 最好看，也非常符合我的审美。所以就开始使用 VS code 导出 PDF。</p><p>每次都是使用实时渲染的软件写好文档，然后保存 MD 文件，再用 <code>VS code</code> 打开 + 导出，就很棒。</p><p>但是今天就翻车了，因为在 MD 中使用了<strong>数学公式</strong>，再使用相同的方法导出时，就出了问题 —— 数学公式未能正确导出，还是 MD 语法的表示形式。如图：</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628173919.png"></p><p>就挺懵逼的。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>然后就求助于万能的搜索引擎。开始查找解决办法。</p><p>先讲述一个失败的方法，不不不，也不是失败的方法，就是导出来的文件不符合我的审美，我就直接拒绝了它。</p><h3 id="方法一（不喜欢）"><a href="#方法一（不喜欢）" class="headerlink" title="方法一（不喜欢）"></a>方法一（不喜欢）</h3><ul><li><p>安装两个插件：</p><ul><li><code>Markdown Preview Enhance</code>：预览插件</li><li><code>Markdown + Math</code>：支持数学公式插件</li></ul></li><li><p>然后使用上述插件预览</p></li><li><p>预览页面鼠标右键，选择导出为 html 文件</p></li><li><p>浏览器打开 html 文件，右键选择打印</p></li></ul><p>问题是可以解决，但是过程复杂了，而且排版和界面不好看呀。</p><p>( ᑭ&#96;д´)ᓀ))д´)ᑫ</p><h3 id="方法二（完美）"><a href="#方法二（完美）" class="headerlink" title="方法二（完美）"></a>方法二（完美）</h3><p>所以就去寻找另外的方法。</p><p>ᕕ( ᐛ )ᕗ</p><p>还是需要两个插件哈，不过都是之前用着的插件，用于 VS code 使用 <code>Markdown</code>。</p><ul><li><p><code>Markdown All in One</code></p><p>该插件提供了一些 <code>Markdown</code> 书写过程中非常便捷性的一些操作，同时支持了 <code>latex</code> 公式，能够让你的 <code>VS code markdown Preview</code> 识别你所书写的公式。</p></li><li><p><code>Markdown PDF</code></p><p> 该插件提供了将 <code>Markdown</code> 文件输出为可预览的不同格式文件，包括 <code>html</code>， <code>pdf</code> 等。</p><p> <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628173942.png"></p></li></ul><p>光安装两插件还不足及解决问题，接下来就需要给加点小动作了。</p><p>ᕕ( ᐛ )ᕗ</p><p>找到 <code>Markdown PDF</code> 插件中的一个文件 —— <code>template.html</code>。</p><p>文件路径：<code>C://Users/&lt;username&gt;/.vscode/extensions/yzane.markdown-pdf-1.4.1/template/template.html</code></p><blockquote><p>实在找不到可以使用 <code>everything</code> 搜索一下。</p><ul><li><a href="https://www.voidtools.com/zh-cn/">everything</a></li></ul></blockquote><p>然后使用编辑器，如 <code>VS code</code> 打开该文件，在如图位置加入两行代码。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/x-mathjax-config&quot;</span>&gt;</span><span class="language-javascript"> <span class="hljs-title class_">MathJax</span>.<span class="hljs-property">Hub</span>.<span class="hljs-title class_">Config</span>(&#123; <span class="hljs-attr">tex2jax</span>: &#123;<span class="hljs-attr">inlineMath</span>: [[<span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-string">&#x27;$&#x27;</span>]]&#125;, <span class="hljs-attr">messageStyle</span>: <span class="hljs-string">&quot;none&quot;</span> &#125;);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628174007.png"></p><p>最后再重新导出 PDF 就可以啦。</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628174029.png"></p><p>可见问题完美解决。</p><p>好耶。又水了一篇。</p><p>ᕕ( ᐛ )ᕗ</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>法一：<a href="https://blog.csdn.net/weijifen000/article/details/84257434">vscode下markdown转PDF</a></li><li>法二：<a href="https://blog.csdn.net/qq_18506419/article/details/103461825">VScode中Markdown PDF无法正确输出包含公式的pdf解决方案</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>水博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>VS code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【水博客】解决 Windows Powershell 中 SSH 远程连接失败问题</title>
    <link href="/2022/04/12/cannot-ssh-connect-with-ps/"/>
    <url>/2022/04/12/cannot-ssh-connect-with-ps/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>终端出现：</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628225106.png"></p><blockquote><p>上图使用的是他人的问题图片，自己这边忘记截图了。</p></blockquote><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!</p><p>就是：</p><p>警告：远程主机标识已更改！</p><p>此报错是由于远程的主机的公钥发生了变化导致的。 </p><p>ssh 服务是通过公钥和私钥来进行连接的，它会把每个曾经访问过计算机或服务器的公钥（public key），记录在 <code>~/.ssh/known_hosts</code> 中，当下次访问曾经访问过的计算机或服务器时，ssh 就会核对公钥，如果和上次记录的不同，<code>OpenSSH</code> 会发出警告。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>使用命令清楚所连接的 IP：</p><div class="code-wrapper"><pre><code class="hljs shell">ssh-keygen -R xx.xx.xx.xx<span class="hljs-meta prompt_"># </span><span class="language-bash">xx.xx.xx.xx 是需要使用 ssh 连接的 ip</span></code></pre></div><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628225125.png"></p><p>然后重新连接：</p><div class="code-wrapper"><pre><code class="hljs shell">ssh name@xx.xx.xx.xx -p 22<span class="hljs-meta prompt_"># </span><span class="language-bash">name：用户名</span><span class="hljs-meta prompt_"># </span><span class="language-bash">xx.xx.xx.xx: ip</span><span class="hljs-meta prompt_"># </span><span class="language-bash">-p 22：使用端口 22</span></code></pre></div><p>这是会出现有一局：</p><p>Are you sure you want to continue connecting (yes&#x2F;no)?</p><p>输入：yes，并按回车。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628225148.png"></p><p>然后就能够成功建立远程连接，后续输入 <code>用户名</code> + <code>密码</code> 登录系统就行。</p><p>最后，在终端断开 ssh 连接而不关闭终端的方法：</p><ul><li>方法一：<code>Ctrl + D</code></li><li>方法二：输入 <code>logout</code> (部分情况下需要多次输入)</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/wangguchao/article/details/85614914">问题解决——SSH时出现WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!</a></li><li><a href="https://blog.csdn.net/weixin_39366112/article/details/78175873">在终端ssh的断开方法</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>水博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
      <tag>SSH</tag>
      
      <tag>PowerShell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows Terminal 使用及美化记录</title>
    <link href="/2022/04/06/terminal-useing/"/>
    <url>/2022/04/06/terminal-useing/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>用来记录使用 Windows Terminal 一路上遇到的问题以及解决的办法。</p><p>写本文时，运行 Windows Terminal 的环境：</p><ul><li>Windows 11</li><li>自带的 Windows Terminal</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>Windows 10<br>  Windows 10 可以从系统自带的 MicroSoft Store 进行下载安装，搜索 Windows Terminal，点击安装即可。</li><li>Windows 11<br>  Windows 11 直接自带 Windows Terminal，并将其作为默认的命令行工具——无论是 PowerShell 还是 CMD，或者是用户自己后续安装的如 Git Bash 等等均会直接使用 Windows Terminal 进行打开，怎么说就，十分舒适。</li></ul><p>总所周知，Windows Terminal 是可以进行美化的，而这意味着什么？</p><p>我们可以将不忍直视的 CMD 或者 Git Bash 界面做成让我们自己赏心悦目的样子，可以极大的愉悦我们的心情。</p><h2 id="Windows-Terminal-美化"><a href="#Windows-Terminal-美化" class="headerlink" title="Windows Terminal 美化"></a>Windows Terminal 美化</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>简单的说就是，Windows Terminal 通过修改<strong>配置文件</strong>中的内容，获得不一样的视觉效果。</p><p>配置文件包含三块部分：</p><ol><li>常规</li><li>外观 —— 设置字体、窗口样式、配色方案、透明度、背景图片等</li><li>高级</li></ol><h3 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h3><blockquote><p>Windows 10、早期的 Windows 11 的 Terminal 的配置文件还是分为上述的三部分<br>不过，在 22 年 4 月份的时候，Terminal 的配置文件部分就发生了一点变化。<br>首先就是界面部分变得和 Windows 11 设置一样的 UI 风格<br>其次，常规部分变成了如图所示样子：<br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232410.png"><br>外观 + 高级则隶属于其他设置（内容大致没有变化）。</p></blockquote><blockquote><p>本文根据当前样式进行介绍。</p></blockquote><p>该部分共有 6 个字段：</p><ul><li><p>名称：下拉列表中显示的配置文件名称。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232435.png"></p></li><li><p>命令行：在配置文件中所使用的可执行文件。</p><p> 简单说就是，需要用到的命令行的可执行文件（路径），如：</p><ul><li><code>cmd</code>：就是 <code>cmd.exe</code></li><li><code>git</code>：就是 <code>git.exe</code></li></ul><p> 等等。</p></li><li><p>启动目录：加载配置文件时启动的目录。</p><blockquote><p>用人话说就是：打开该命令行后，所在的文件路径。<br>默认值：<code>&quot;%USERPROFILE%&quot;</code>，该值是用户名的文件夹，即：<br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232455.png"></p></blockquote><blockquote><p>备注：<br>反斜杠需要转义。 例如，应以 <code>C:\\Users\\USERNAME\\Documents</code> 的形式输入 <code>C:\Users\USERNAME\Documents</code>。</p></blockquote></li><li><p>图标：配置文件中所使用的图标的表情符号或图像文件位置。</p><blockquote><p>这将设置在选项卡、下拉菜单、跳转列表和选项卡切换器中显示的图标。<br>由此就可以将图标设置成喜欢的样子，例如：</p></blockquote><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232521.png"></p><p>将 powershell 的图标设置成这个样子了。</p></li><li><p>选项卡标题：将配置文件名称替换为标题，以在启动时传递给外壳。</p><blockquote><p>设置后就会如图所示，标题一直是<code>cmd</code>、<code>powershell</code>。</p></blockquote><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232542.png"><br><del>似乎没有那么好看了，不过这是看情况的</del></p></li><li><p>从下拉菜单中隐藏：如果启用，配置文件将不会显示在配置文件列表中。</p><blockquote><p>这可用于<strong>隐藏</strong> <code>默认配置文件</code> 和 <code>动态生成的配置文件</code>，同时将他们保留在设置文件中。</p></blockquote><p>  <img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232556.png"></p></li></ul><p>更多关于该部分的信息，请详见 <a href="https://docs.microsoft.com/zh-cn/windows/terminal/customize-settings/profile-general"><strong>Windows 终端中的常规配置文件设置</strong></a>。</p><h3 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h3><p>外观是咱们 Windows Terminal 美化的主战场，主要就是自定义修改<strong>字体</strong>、<strong>配色方案</strong>、<strong>背景图片</strong>、<strong>亚克力效果</strong>（透明度）等等。</p><p>共有两种修改方式：</p><ol><li>使用图形界面的设置 —— 就是进入 Windows Terminal 的设置里一点点的调整</li><li>修改配置文件（JSON文件）—— 这个会比第一种复杂不少，因为是需要自己文件中的一点点设置啦</li></ol><p>不过两者各有所长，至少配置文件可以用来保存设置好的美化方案，方便分享或是重装系统后的恢复。</p><p>通过修改上述的几点设置后，咱们的终端界面就会有很大的不同了，看起来就有那么一点点的赏心悦目。</p><p>现在从配色方案、字体、背景图片、亚克力效果进行说明。</p><p>更多关于该部分的信息，请详见 <a href="https://docs.microsoft.com/zh-cn/windows/terminal/customize-settings/profile-appearance"><strong>Windows 终端中的外观配置文件设置</strong></a>。</p><blockquote><p>注意：<br>可设置选项请以所使用的 Windows Terminal 显示的为主。</p></blockquote><h4 id="配色方案"><a href="#配色方案" class="headerlink" title="配色方案"></a>配色方案</h4><p>配色方案就好比一个主题，有着不同的风格（颜色），可以使得咱们的 Terminal 看起来具有别样的美感，同时也可以根据个人的喜好，获取自己别样的美学享受。<del>瞎扯ing</del></p><p>但是，使用、获取一个配色方案很简单，使用、获取一个合适的配色方案就不是那么简单了。</p><blockquote><p>一个合适的配色方案需要考虑到多种因素，如背景图片、亚克力效果等等。<br>他们有机组合在一起才可以获取一个美观、清楚、清晰的美化效果。<br>不然呀，就会发现，某某地方怎么不清楚、看不到了呢？整体看着那么别扭呢？<br>不过，俺也就在这简单的说一说，具体怎么实现美观、清楚、清晰的效果，俺还不知道，后续更新去了。</p></blockquote><p>Windows Terminal 中有几个默认的配色方案可供使用：</p><ul><li><code>Campbell</code><br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232612.png"></li><li><code>Campbell Powershell</code><br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232636.png"></li><li><code>One Half Dark</code><br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232650.png"></li><li><code>One Half Light</code><br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232710.png"></li><li><code>Solarized Dark</code><br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232727.png"></li><li><code>Solarized Light</code><br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232742.png"></li><li><code>Tango Dark</code><br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232757.png"></li><li><code>Tango Light</code><br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232811.png"></li><li><code>Vintage</code><br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232826.png"></li></ul><p>如果默认的配色方案没法满足你的需求，还可以自己设置想要的配色方案哦（有时候可能会有一点点困难）。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232840.png"></p><p>选择合适的终端颜色、系统颜色，再保存，就拥有自己喜欢的配色方案了。</p><p>不过具体的效果就不知道如何了。</p><p>如果自己设置的配色方案还是没法满足自己的需要，咋办？</p><p>没事，有大佬们设计了很多很多种华丽的配色方案: <a href="https://windowsterminalthemes.dev/">Windows Terminal Themes</a></p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232855.png"></p><p>一共有几十共不同的配色方案，一种配色方案还有 <code>Dark</code>，<code>Light</code> 两种选择，共有一款会是你喜欢的，或者是适合你的。</p><h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><p>字体，字体选择也会对终端的界面有很大的改变。</p><p>这里没有太多好说的，主要是需要使用<strong>等宽字体</strong>，不要使用中文字体，如宋体、幼圆、黑体。</p><p>这是使用了<strong>黑体</strong>的结果，就一个字 —— 丑。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232915.png"></p><p>不过 terminal 也提供了很多不错的字体，如 <code>Cascadia Code</code>、<code>Cascadia Mono</code>、<code>Consolas</code> 等等。</p><p>当然你还可以自己安装你喜欢的字体，如 <a href="https://www.jetbrains.com/zh-cn/lp/mono/">JetBrains Mono</a>。</p><blockquote><p>该字体有很多种系列，如细体、特细、细、正常、中等、半粗体、粗体、超粗体，同时还有对应的斜体。<br>怎么说，就很丰富。</p></blockquote><p>而我自己使用的字体，是 <a href="https://www.nerdfonts.com/font-downloads">Nerd Font</a> 字体系列中的 <a href="https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/Hack.zip">Hack Nerd Font</a>。（点击后会直接下载该字体哦)</p><blockquote><p>该系列的字体会比 JetBrains 的字体好一点，因为他们有图标，可以显示某些主题的一下图标。</p></blockquote><p>可以自己找到喜欢的字体，然后安装，就可以设置该字体作为终端的字体了。</p><h4 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h4><p>背景图片可以让你的终端看起来更加的花里胡哨。</p><p>你可以选择自己想要的图片，或者是桌面壁纸。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232959.png"></p><p>选择使用背景图片后，还可以设置图片的一些属性：</p><ul><li>背景图像拉升模式</li><li>背景图像对齐</li><li>背景图像不透明度</li></ul><p>可自行调试上述的属性。</p><blockquote><p>注意：<br>使用背景图片使用时，要注意与配色方案的协调性——就是避免背景图片的某些部分影响了文字的可读性，就如上图中，是灰色的字体，部分地方因为背景图片而看的不甚清楚。<br>当图片会影响到文字的阅读时，可能需要更换其他合适的图片，或者是调整<strong>背景图像不透明度</strong>，这一属性，使得终端看起来舒服些。</p></blockquote><h4 id="亚克力效果、透明效果"><a href="#亚克力效果、透明效果" class="headerlink" title="亚克力效果、透明效果"></a>亚克力效果、透明效果</h4><p>设置该配置文件的窗口透明度。效果如下：</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628233024.png"></p><blockquote><p>可以看见窗口下层关于 <code>Windows Terminal Themes</code> 的内容。<br>透明度也是需要适当设置的，不然也会影响文字的阅读。<br>这一点也是需要和配色方案协调起来，比如某些颜色的字更容易看清楚。<br>不过更多的是与 terminal 下层的窗口有关系，它的颜色很容易影响文字的阅读。<br>所以，最好还是合理的hi用该透明的效果。</p></blockquote><p>不过还有<strong>亚克力效果</strong>可以缓解上述问题：当启用亚克力效果时，终端会创建一个模糊的背景——应用一个半透明的纹理。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628233052.png"></p><blockquote><p>如图，窗口下层依然是关于 <code>Windows Terminal Themes</code> 的内容，但是仅能隐约的看到相关内容。</p></blockquote><h3 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h3><p>看了一下，似乎没有什么和美化有关的内容，所以就不在此叙述。</p><p>更多关于该部分的信息，请详见 <a href="https://docs.microsoft.com/zh-cn/windows/terminal/customize-settings/profile-advanced"><strong>Windows 终端中的高级配置文件设置</strong></a>。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>本篇文章仅仅只是介绍了 Windows Terminal 对于终端的美化，设置图片、字体、配色方案、透明度之类的。</p><p>或许你也发现，文中配图的 powershell 不太一样，这是因为我使用了 <a href="https://ohmyposh.dev/">oh my posh</a>(A prompt theme engine for any shell.)</p><p>会在下篇文章介绍 oh my posh 的使用。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://docs.microsoft.com/zh-cn/windows/terminal/">Windows Terminal 官方文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Terminal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Beauty</tag>
      
      <tag>Terminal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【水博客】解决 Github Pages + hexo 网页无法显示图片问题</title>
    <link href="/2022/04/06/cannot-display-pictrue/"/>
    <url>/2022/04/06/cannot-display-pictrue/</url>
    
    <content type="html"><![CDATA[<p class="note note-primary">2022-06-28 更新：现已不使用该文章提示的方法托管博文图片，而是使用 github + picgo ~~+ coding~~，不过 coding 出了点小问题。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>md 文件中加入图片链接后，在网页上无法显示图片。  </p><!--more--><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><p>找到一个免费的图床——如 <a href="https://imgtu.com/">路过图床</a>。</p></li><li><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628224255.png"></p></li><li><p>将需要放置在 <code>MarkDown</code> 文件中的图片上传到图床中，结果如下：<br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628224341.png"></p></li><li><p>选择上述合适的语句，粘贴到 <code>MarkDown</code> 文件中合适的位置（要配合使用 MD 语法哦）。<br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628224400.png"></p></li><li><p>解决后的效果<br> <img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628224424.png"></p><p> 就成功显示了。<br> 完美<del>（暂时）</del>解决问题，前提是电脑联网了或者图床没跑路。</p></li></ol><h3 id="紫薯布丁"><a href="#紫薯布丁" class="headerlink" title="紫薯布丁"></a>紫薯布丁</h3><p>不保证方法百分百解决您的问题，仅仅提供一个方案（能解决我的问题的方案），无法解决的话，请您继续百度以查看他人的方法。  </p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.dazhuanlan.com/2019/10/16/5da647c849379/">github+hexo博客无法显示图片解决办法</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>水博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 语言 —— 链表的创建</title>
    <link href="/2021/03/29/C-create-link/"/>
    <url>/2021/03/29/C-create-link/</url>
    
    <content type="html"><![CDATA[<h2 id="单链表的创建"><a href="#单链表的创建" class="headerlink" title="单链表的创建"></a>单链表的创建</h2><p>编辑时间：2021-3-29</p><p>创建的方法——（有无头结点）头插法、（有无头结点）尾插法。</p><h4 id="定义链表结点"><a href="#定义链表结点" class="headerlink" title="定义链表结点"></a>定义链表结点</h4><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span>    <span class="hljs-type">int</span> data;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span>&#125;;</code></pre></div><h4 id="有头结点"><a href="#有头结点" class="headerlink" title="有头结点"></a>有头结点</h4><h5 id="1-头插法"><a href="#1-头插法" class="headerlink" title="1.头插法"></a>1.头插法</h5><p>从一个空链表开始，重复读入数据，生成新的结点，将读入的数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头结点之后，直至读入结束标志。</p><blockquote><p>链表中数据的关系：</p><p>先读取的数据离头结点越远。  链表输出数据的顺序与输入顺序相反。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//形参采用二重指针形式</span><span class="hljs-type">void</span> <span class="hljs-title function_">createNode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode **head)</span>&#123;    *head = (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode)); <span class="hljs-comment">//head分配地址</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">temp</span>;</span>                                      <span class="hljs-comment">//声明指针temp，用于指向新生成的链表结点</span>    (*head)-&gt;next = <span class="hljs-literal">NULL</span>;                                       <span class="hljs-comment">//head初始化为空</span>    temp = *head;                                               <span class="hljs-comment">//temp指向尾部的结点</span>    <span class="hljs-type">int</span> n; <span class="hljs-comment">//链表长度</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">node</span> =</span> (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;input:&quot;</span>);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;node-&gt;data);        node-&gt;next = temp-&gt;next; <span class="hljs-comment">//将node-&gt;next指向链表首元结点</span>                                 <span class="hljs-comment">//插入第一个结点时，node-&gt;next = NULL</span>        temp-&gt;next = node;       <span class="hljs-comment">// head-&gt;next再指向node</span>                                 <span class="hljs-comment">//完成将node插入到头结点之后</span>    &#125;&#125;<span class="hljs-comment">//node-&gt;next = temp-&gt;next</span><span class="hljs-comment">//temp-&gt;next = node</span><span class="hljs-comment">//两句顺序不能交换，交换后会失去head后面的结点</span><span class="hljs-comment">//故而先将head之后的结点链接到node之后</span><span class="hljs-comment">//再将node链接到head-&gt;next</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//返回头结点</span><span class="hljs-keyword">struct</span> ListNode *<span class="hljs-title function_">create</span><span class="hljs-params">()</span>&#123;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">head</span>;</span>    head = (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode)); <span class="hljs-comment">//head分配地址</span>    head-&gt;next = <span class="hljs-literal">NULL</span>;                                         <span class="hljs-comment">//head初始化为空</span>    <span class="hljs-type">int</span> n;                                                     <span class="hljs-comment">//链表长度</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">node</span> =</span> (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;input:&quot;</span>);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;node-&gt;data);        node-&gt;next = head-&gt;next;         head-&gt;next = node;           &#125;    <span class="hljs-keyword">return</span> head;&#125;</code></pre></div><h5 id="2-尾插法"><a href="#2-尾插法" class="headerlink" title="2.尾插法"></a>2.尾插法</h5><p>将新结点 插到当前单链表的表尾上。增加一个尾指针Tial， 使之指向当前单链表的表尾。</p><p>保证了输入数据的顺序与链表顺序的相同。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//形参采用二重指针形式</span><span class="hljs-type">void</span> <span class="hljs-title function_">createNode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode **head)</span>&#123;    *head = (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode)); <span class="hljs-comment">//head分配地址</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">Tail</span>;</span>                                     <span class="hljs-comment">//Tial尾指针</span>    Tail = *head;    <span class="hljs-type">int</span> n;                                                     <span class="hljs-comment">//链表长度</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">node</span> =</span> (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;input:&quot;</span>);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;node-&gt;data);        Tail-&gt;next = node;<span class="hljs-comment">//新结点接在Tail后面</span>        Tail = node;      <span class="hljs-comment">//尾指针指向新结点，新结点作为链表尾部</span>    &#125;    Tail-&gt;next = <span class="hljs-literal">NULL</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//返回头结点</span><span class="hljs-keyword">struct</span> ListNode *<span class="hljs-title function_">create</span><span class="hljs-params">()</span>&#123;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">head</span>;</span>    head = (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode)); <span class="hljs-comment">//head分配地址</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">Tail</span> =</span> head;    <span class="hljs-type">int</span> n;                                                     <span class="hljs-comment">//链表长度</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">node</span> =</span> (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;input:&quot;</span>);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;node-&gt;data);        Tail-&gt;next = node;<span class="hljs-comment">//新结点接在Tail后面</span>        Tail = node;      <span class="hljs-comment">//尾指针指向新结点，新结点作为链表尾部</span>    &#125;    Tail-&gt;next = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">return</span> head;&#125;</code></pre></div><h4 id="无头结点"><a href="#无头结点" class="headerlink" title="无头结点"></a>无头结点</h4><h5 id="1-头插法-1"><a href="#1-头插法-1" class="headerlink" title="1.头插法"></a>1.头插法</h5><p>输入顺序与输出顺序相反</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">create_noHeadNode_HeadInsert</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode **head)</span>&#123;    <span class="hljs-comment">//头插法</span>    (*head) = (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));    (*head) = <span class="hljs-literal">NULL</span>;    <span class="hljs-type">int</span> n; <span class="hljs-comment">//链表长度</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">node</span> =</span> (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;node-&gt;data);        node-&gt;next = (*head);        (*head) = node;    &#125;&#125;</code></pre></div><h5 id="2-尾插法-1"><a href="#2-尾插法-1" class="headerlink" title="2.尾插法"></a>2.尾插法</h5><p>输入顺序与输出顺序相同</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">create_noHeadNode_TailInsert</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode **head)</span>&#123;    <span class="hljs-comment">//尾插法</span>    (*head) = (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));    <span class="hljs-comment">//(*head)-&gt;next = NULL;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">tail</span> =</span> (*head);<span class="hljs-comment">//tail为尾结点</span>    <span class="hljs-type">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">node</span> =</span> (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;node-&gt;data);        tail-&gt;next = node;        tail = node;    &#125;    (*head) = (*head)-&gt;next;<span class="hljs-comment">//head结点没有存储上数据，故直接让其指向储有第一个数据的head-&gt;next</span>    tail-&gt;next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//尾结点下一个为空</span>&#125;</code></pre></div><h4 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h4><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Students</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-comment">//char name[20];</span>    <span class="hljs-type">int</span> age;    <span class="hljs-type">float</span> marks;&#125; Student;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-type">int</span> data;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">next</span>;</span>&#125;;<span class="hljs-comment">//有头结点</span><span class="hljs-keyword">struct</span> ListNode *<span class="hljs-title function_">create</span><span class="hljs-params">()</span>;               <span class="hljs-comment">//尾插法</span><span class="hljs-type">void</span> <span class="hljs-title function_">createNode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode **head)</span>; <span class="hljs-comment">//头插法</span><span class="hljs-type">void</span> <span class="hljs-title function_">printNode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode *head)</span>;<span class="hljs-comment">//无头结点</span><span class="hljs-type">void</span> <span class="hljs-title function_">createNode_nohead</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode **head)</span>; <span class="hljs-comment">//头插法</span><span class="hljs-type">void</span> <span class="hljs-title function_">create_nohead</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode **head)</span>;     <span class="hljs-comment">//尾插法</span><span class="hljs-type">void</span> <span class="hljs-title function_">PrintNode_Nohead</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode *head)</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">HeadI</span>, *<span class="hljs-title">TailI</span>;</span>     <span class="hljs-comment">//有头结点</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">noHeadI</span>, *<span class="hljs-title">noTailI</span>;</span> <span class="hljs-comment">//无头结点</span>    <span class="hljs-comment">//创建链表</span>    createNode(&amp;HeadI);    printNode(HeadI);    TailI = create();    printNode(TailI);    createNode_nohead(&amp;noHeadI);    PrintNode_Nohead(noHeadI);    create_nohead(&amp;noTailI);    PrintNode_Nohead(noTailI);    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">PrintNode_Nohead</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode *head)</span>&#123;    <span class="hljs-keyword">while</span> (head)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, head-&gt;data);        head = head-&gt;next;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);&#125;<span class="hljs-comment">//头插法</span><span class="hljs-type">void</span> <span class="hljs-title function_">createNode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode **head)</span>&#123;    *head = (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode)); <span class="hljs-comment">//head分配地址</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">temp</span>;</span>                                      <span class="hljs-comment">//声明指针temp，用于指向新生成的链表结点</span>    (*head)-&gt;next = <span class="hljs-literal">NULL</span>;                                       <span class="hljs-comment">//head初始化为空</span>    temp = *head;                                               <span class="hljs-comment">//temp指向尾部的结点</span>    <span class="hljs-type">int</span> n;                                                      <span class="hljs-comment">//链表长度</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">node</span> =</span> (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;input:&quot;</span>);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;node-&gt;data);        node-&gt;next = temp-&gt;next; <span class="hljs-comment">//将node-&gt;next指向链表头结点之后的内容</span>        temp-&gt;next = node;       <span class="hljs-comment">// head-&gt;next再指向node</span>                                 <span class="hljs-comment">//完成将node插入到头结点之后</span>    &#125;&#125;<span class="hljs-comment">//尾插法</span><span class="hljs-keyword">struct</span> ListNode *<span class="hljs-title function_">create</span><span class="hljs-params">()</span>&#123;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">head</span>;</span>    head = (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode)); <span class="hljs-comment">//head分配地址</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">Tail</span> =</span> head;    <span class="hljs-type">int</span> n; <span class="hljs-comment">//链表长度</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">node</span> =</span> (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;input:&quot;</span>);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;node-&gt;data);        Tail-&gt;next = node;        Tail = node;    &#125;    Tail-&gt;next = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">return</span> head;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">printNode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode *head)</span>&#123;    <span class="hljs-keyword">while</span> (head-&gt;next)    &#123;        head = head-&gt;next;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, head-&gt;data);    &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">createNode_nohead</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode **head)</span>&#123;    <span class="hljs-comment">//头插法</span>    (*head) = (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));    (*head) = <span class="hljs-literal">NULL</span>;    <span class="hljs-type">int</span> n; <span class="hljs-comment">//链表长度</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">node</span> =</span> (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;node-&gt;data);        node-&gt;next = (*head);        (*head) = node;    &#125;    <span class="hljs-comment">//(*head)-&gt;next = NULL;</span>&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">create_nohead</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode **head)</span>&#123;    <span class="hljs-comment">//尾插法</span>    (*head) = (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));    <span class="hljs-comment">//(*head)-&gt;next = NULL;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">tail</span> =</span> (*head);    <span class="hljs-type">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">node</span> =</span> (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;node-&gt;data);        tail-&gt;next = node;        tail = node;    &#125;    (*head) = (*head)-&gt;next;    tail-&gt;next = <span class="hljs-literal">NULL</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>马基期末小作文之生活的意义</title>
    <link href="/2021/01/26/mean-of-life/"/>
    <url>/2021/01/26/mean-of-life/</url>
    
    <content type="html"><![CDATA[<p><strong>庚子年的冬天，寂寥而悲壮，萧索而又豪迈。</strong>万家阖门闭户，息交绝游；道路不通，商旅不行，喇叭声咽，都在空城……一场突如其来的灾难改变了世界的面貌，也在潜移默化中改变着人们对于生活的认识，使得人们开始重新审视、思考生活的意义。 </p><p><strong>围炉夜话一家亲——生活的意义在于相守。</strong>你或许流连于校园，或许穿梭于职场，或许像候鸟一样，南来北往，辗转流徙，抑或疲于奔命于流水线上，为口腹计，为稻粱谋……仰事俯畜的艰辛，让我们往往忽略了身边人，世间情。疫情，让全国人民居家隔离，蜗居于方丈之室。每一个人，每一个家庭，从来没有像今天一样，关心粮食和蔬菜，关心平淡而真实的家事。无奈于离别，无奈与生死不由己，也更加懂得了珍惜。疫情像一把重锤将不少人敲醒，只要家人朋友安好，任何一种生活都不再是狗血一地，而是真情一片。</p><p><strong>明月何曾是两乡——生活的意义在于相助。</strong>人民性是马克思主义最鲜明的品格，新冠肺炎疫情防控狙击战，是一场人民战争。此时此刻，每个普通中国人都在为这场战争努力付出、默默奋斗。网格员，不顾个人安危，稽查人户，测量体温，宣讲防护知识；志愿者，二十四小时值守，帐篷，红马甲，在风雪中，俨然爱的火焰。巡逻队，宵禁夜巡，一句“早点回家”，让人顿觉暖意融融。严重的疫情犹如一场战争，需要全社会一致行动。以习近平同志为核心的党中央及时部署、有力防控，从采取最全面最严格最彻底的防控措施，到前所未有地采取大规模隔离措施，前所未有地调集全国资源开展大规模医疗救治，都体现了全社会“团结”抗疫的磅礴力量。</p><p><strong>异域风月也同天——生活的意义在于相处。</strong>“天下有大勇者，卒然临之而不惊，无故加之而不怒”，面对无预之灾，中国坚决果断，及时阻止了疫情的世界传播；面对某些国家的无端指责，从容不迫，集中精力投入到世界抗疫之中。病毒变异，全球疫情的局面更加严峻，迫切需要世界各国在大是大非面前做出选择：推进多边协调还是奉行单边主义？人类命运共同体理念给予了最好的借鉴。要团结，不要分裂，团结互助是打赢疫情防控全球战最直接、最有效的途径。生活本就是人与人，人与自然之间的相处，放下隔阂和偏见，放下自私和贪婪，去拥抱人类共同更美好的未来。</p><p><strong>全国人民，为政者，一号令，课吏职，抗疫守土；为民者，令行禁止，舍小我，明大义，公忠体国。亲友相守，邻舍相助，人物相处，我们并非孑然独行，生活的意义便在于此了吧。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Write</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Write</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VS code 配置 C/C++环境 (版本过低)</title>
    <link href="/2020/12/12/vscode-env-c-old/"/>
    <url>/2020/12/12/vscode-env-c-old/</url>
    
    <content type="html"><![CDATA[<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>该文章过时了。<del>不不不，只是内容不够完美，被我放弃了</del></p><p>后续更新了一篇比较细致的 <code>Windows</code> 下 <code>VS code</code> 配置 <code>C/C++</code> 环境。</p><p>详见 <a href="https://muxiner.github.io/2022/4/19/muxinervscode_using_gcc_with_mingw/"></a></p><h2 id="本文暂时只是给我自己回忆配置过程的，内容仅供参考，莫较真。-x3D-x3D"><a href="#本文暂时只是给我自己回忆配置过程的，内容仅供参考，莫较真。-x3D-x3D" class="headerlink" title="本文暂时只是给我自己回忆配置过程的，内容仅供参考，莫较真。 &#x3D; &#x3D;"></a><del>本文暂时只是给我自己回忆配置过程的，内容仅供参考，莫较真。 &#x3D; &#x3D;</del></h2><p>此片博文用于记录 <code>Vs code</code> 里 <code>C\C++ 环境</code> 的配置，方便以后自己能够配好环境，而不是复制原来已经配好的。</p><p>配置环境需要准备的东西—— <code>VScode</code> 、 <code>MinGW</code> 。  </p><p><code>MinGW</code> ，是 <code>Minimalist GNUfor Windows</code> 的缩写。它是一个可自由使用和自由发布的 <code>Windows</code> 特定头文件和使用GNU工具集导入库的集合，允许你在 <code>GNU/Linux和Windows</code> 平台生成本地的 <code>Windows</code> 程序而不需要第三方C运行时（ <code>C Runtime</code> ）库。<code>MinGW</code> 是一组包含文件和端口库，其功能是允许控制台模式的程序使用微软的标准C运行时（ <code>C Runtime</code> ）库（ <code>MSVCRT.DLL</code> ）,该库在所有的 <code>NT OS</code> 上有效，在所有的 <code>Windows 95</code> 发行版以上的 <code>Windows OS</code> 有效，使用基本运行时，你可以使用 <code>GCC</code> 写控制台模式的符合美国标准化组织（ <code>ANSI</code> ）程序，可以使用微软提供的 C 运行时（ <code>C Runtime</code> ）扩展，与基本运行时相结合，就可以有充分的权利既使用 <code>CRT(C Runtime)</code> 又使用 <code>WindowsAPI</code> 功能。</p><p><code>VS code</code> 下载地址 —— <a href="https://code.visualstudio.com/">Visual Studio Code</a></p><p><code>MinGW</code> 下载地址 —— <a href="https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/">MinGW</a></p><p>安装教程暂时不写，看其他人的 —— <a href="https://blog.csdn.net/wxh0000mm/article/details/100666329">MinGW的安装教程</a>。</p><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p>右键 <code>我的电脑</code>选择<code>属性</code>，然后如图操作，配置环境变量。(用户变量，系统变量都操作一次,主要是系统变量)</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628004329.png"></p><p><code>C:\MinGW\bin</code> —— 是 <code>gcc.exe</code> 的路径。如图：</p><blockquote><p><strong>注意：</strong>我们需要填入环境变量的路径是我们自己安装 <code>MinGW</code> 的路径下的，含有编译器的文件夹的路径，编译器有 <code>gcc.exe</code> , <code>g++.exe</code>。上述 <code>C:\MinGW\bin</code> 只是一个例子，自己的情况请先翻找对应文件（<code>MinGW</code> 安装路径）。<br><strong>注意：</strong>仅适用于 windows 系统。</p></blockquote><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628004736.png"></p><h4 id="安装C-x2F-C-扩展"><a href="#安装C-x2F-C-扩展" class="headerlink" title="安装C&#x2F;C++扩展"></a>安装C&#x2F;C++扩展</h4><p>打开 VS code，找到如图所示：<br><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628004852.png"></p><p>扩展-输入 <code>C\C++</code> - 选择 <code>C\C++</code> - 点击 <code>install</code>, 以安装C\C++扩展。</p><p>如果想要字体变成简体中文，那么搜索 <code>chinese</code>，找到如图的扩展安装并重启VScode即可。<br><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628004922.png"></p><h4 id="配置C-x2F-C-环境"><a href="#配置C-x2F-C-环境" class="headerlink" title="配置C&#x2F;C++环境"></a>配置C&#x2F;C++环境</h4><p>用 <code>VS code</code> 打开用来放置文件的文件夹，可直接通过欢迎界面的 <code>Open folder</code> 打开，也可通过菜单栏的 <code>File--&gt;Open Folder</code> 打开。</p><p>新建一个HelloWorld.c并编写：</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628005242.png"></p><h5 id="配置编译器-我的方法"><a href="#配置编译器-我的方法" class="headerlink" title="配置编译器(我的方法)"></a>配置编译器(我的方法)</h5><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628005335.png"></p><p>如图创建 <code>.vscode</code> <code>Csource</code> 文件夹，前者用来存放环境的配置文件，后者用来存放 C 语言文件。</p><p>在 <code>.vscode</code> 中创建 <code>launch.json</code> , <code>tasks.json</code>。</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628005400.png"></p><p>复制下面代码到 <code>launch.json</code></p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-comment">// 使用 IntelliSense 了解相关属性。 </span>    <span class="hljs-comment">// 悬停以查看现有属性的描述。</span>    <span class="hljs-comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>        <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;g++.exe - 生成和调试活动文件&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppdbg&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/Weexe\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-comment">// workspacefolder为.vscode所在的文件夹,将要进行调试的程序的路径</span>            <span class="hljs-comment">//这个参数要和tasks.json一样,因为调试时的exe文件我们时保存在另一个路径中</span>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;environment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;externalConsole&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;MIMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gdb&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;miDebuggerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:\\MinGW\\bin\\gdb.exe&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//gdb.exe所在路径</span>            <span class="hljs-attr">&quot;setupCommands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>                <span class="hljs-punctuation">&#123;</span>                    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;为 gdb 启用整齐打印&quot;</span><span class="hljs-punctuation">,</span>                    <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span><span class="hljs-punctuation">,</span>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span>                <span class="hljs-punctuation">&#125;</span>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;preLaunchTask&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;g++.exe build active file&quot;</span>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>复制下面代码到 <code>tasks.json</code></p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-comment">// 有关 tasks.json 格式的文档，请参见</span>    <span class="hljs-comment">// https://go.microsoft.com/fwlink/?LinkId=733558</span>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.0.0&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;tasks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>        <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;shell&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;g++.exe build active file&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:\\MinGW\\bin\\g++.exe&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//g++.exe所在路径</span>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>                <span class="hljs-string">&quot;-g&quot;</span><span class="hljs-punctuation">,</span>                <span class="hljs-string">&quot;$&#123;file&#125;&quot;</span><span class="hljs-punctuation">,</span>                <span class="hljs-string">&quot;-o&quot;</span><span class="hljs-punctuation">,</span>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/Weexe\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:\\MinGW\\bin&quot;</span>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>                <span class="hljs-string">&quot;$gcc&quot;</span>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                <span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span>                <span class="hljs-attr">&quot;isDefault&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span>            <span class="hljs-punctuation">&#125;</span>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>文件夹暂时和上图相同。然后方可正常的运行C程序。</p><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>编写本文时，对于 C\C++ 环境配置还不是很熟，因此上述内容或多或少存在问题，后续会更新详细教程。</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
      <tag>VS code</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP：BOMB实验</title>
    <link href="/2020/12/09/csapp-bomb/"/>
    <url>/2020/12/09/csapp-bomb/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="实验开始"><a href="#实验开始" class="headerlink" title="实验开始"></a>实验开始</h3><p>炸弹实验是<code>CSAPP</code>的第二个实验，涉及到了<code>反汇编</code>、<code>读懂汇编语言</code>、<code>Linux下GDB的使用</code>及<code>C语言</code>，其中的读懂汇编语言是重难点，完整的看懂了一个函数的汇编语言时，炸弹也迎刃而解。</p><p>每个人得到的BOMB都是不一样的，大体上是每种类型的炸弹都有不同的题目，共六个<code>PHASE</code> + 一个<code>SECRET_PHASE</code>, 也就是七个炸弹。具体内容后面再说。每个人的BOMB都不一样，但是大体就那么几个在哪排列组合，所以花时间使用BAIDU GOOGLE的话还是可以找到原题的，但是并没有什么卵用，直接抄的话。按我们老师说就是学术剽窃，就是学术作弊。当然可以借鉴一下，毕竟不认真研究一下汇编，是真的不怎么好做这BOMB实验。最好还是自己慢慢看懂汇编，翻译成原来的C语言代码，再得到密码解除炸弹，这样子的收获才是最大的。</p><p>实验的资料自己都有哦，懂得都懂。  </p><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><h4 id="实验概述"><a href="#实验概述" class="headerlink" title="实验概述"></a>实验概述</h4><ul><li>逆向工程拆除“二进制炸弹”程序  </li><li>增强对程序机器级表示、汇编语言、调试器和逆向工程等理解。  </li><li>一个“Binary Bombs”（二进制炸弹，简称炸弹）是一个Linux可执行C程序，包含phase1~phase6共6个阶段。  </li><li>炸弹运行各阶段要求输入一个字符串，若输入符合程序预期，该阶段炸弹被“拆除”，否则“爆炸” 。  </li><li>你需要拆除尽可能多的炸弹。</li></ul><h4 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h4><p>每个炸弹阶段考察机器级语言程序不同方面，难度递增  </p><ul><li>阶段1：字符串比较</li><li>阶段2：循环</li><li>阶段3：条件&#x2F;分支：含switch语句</li><li>阶段4：递归调用和栈</li><li>阶段5：指针</li><li>阶段6：链表&#x2F;指针&#x2F;结构</li><li>隐藏阶段：第4阶段之后附加特定字符串后出现</li></ul><p>好家伙，老师提供的PPT里就直接说明了，以上内容，尤其是隐藏阶段，即SECRET_PHASE，在哪出现和出现的条件。 &#x3D; &#x3D;  </p><h4 id="实验技能"><a href="#实验技能" class="headerlink" title="实验技能"></a>实验技能</h4><ul><li>拆弹装备：<ul><li>熟练使用gdb调试器和objdump；</li><li>单步跟踪调试每一阶段的机器代码；</li><li>理解汇编语言代码的行为或作用；</li><li>“推断”拆除炸弹所需的目标字符串。</li><li>在各阶段的开始代码前和引爆炸弹函数前设置断点，便于调试。</li></ul></li><li>实验语言：C语言，at&amp;t汇编语言</li><li>实验环境：32位 linux</li></ul><h4 id="实验文件说明"><a href="#实验文件说明" class="headerlink" title="实验文件说明"></a>实验文件说明</h4><ul><li>炸弹文件包：（每个人的不一样）</li><li>$tar vxf bomb_2017.tar<ul><li>bomb：   bomb的可执行程序。</li><li>bomb.c：bomb程序的main函数。</li><li>README</li></ul></li><li>bomb：是一个linux下可执行程序，需要0或1个命令行参数<ul><li>不带参数运行，输出欢迎信息后，期待你按行输入                拆弹字符串，错误炸弹引爆退出，正确提示进入下一关。</li><li>带参数运行，从拆弹者的密码文件中读取用户密码</li></ul></li><li>bomb.c：bomb主程序，帮助拆弹者了解代码框架，没有细节</li></ul><h4 id="拆弹方式"><a href="#拆弹方式" class="headerlink" title="拆弹方式"></a>拆弹方式</h4><ul><li>方法1：$.&#x2F;bomb <ul><li>根据提示，逐阶段手工输入拆弹字符串（见演示）</li><li>较为繁琐，重复工作多</li></ul></li></ul><p><a href="https://imgtu.com/i/qveCUf"><img src="https://s1.ax1x.com/2022/04/06/qveCUf.md.png" alt="qveCUf.md.png"></a></p><ul><li>方法2：$.&#x2F;bomb ans.txt     （推荐）<ul><li>ans.txt为拆弹密码文本文件，名字可以自定义<ul><li>文本文件，每个拆弹字符串一行，回车结束，最多7行</li><li>除此之外不要包含任何其它字符</li></ul></li><li>程序会检查每一阶段的拆弹密码字符串来决定炸弹拆除成败。</li></ul></li></ul><p><a href="https://imgtu.com/i/qveSbt"><img src="https://s1.ax1x.com/2022/04/06/qveSbt.md.png" alt="qveSbt.md.png"></a></p><p>这样子是真的快！ </p><div class="code-wrapper"><pre><code class="hljs terminal">$ ./bomb ans.txt</code></pre></div><h3 id="开始拆弹"><a href="#开始拆弹" class="headerlink" title="开始拆弹"></a>开始拆弹</h3><p>首先反汇编<code>bomb</code></p><div class="code-wrapper"><pre><code class="hljs ter">$ objdump –d bomb &gt; asm.txt</code></pre></div><p>对bomb进行反汇编并将汇编代码输出到asm.txt中。  </p><p>然后查看汇编文件<code>asm.txt</code>。寻找<code>phase</code>所在的汇编代码段。 </p><h4 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase_1"></a>Phase_1</h4><p>在<code>asm.txt</code>的<code>main</code>函数中找到如下语句<br>这里为<code>phase1</code>函数在<code>main()</code>函数中被调用的位置：</p><div class="code-wrapper"><pre><code class="hljs text">8048a9a:c7 04 24 01 00 00 00 movl   $0x1,(%esp)8048aa1:e8 ea fd ff ff       call   8048890 &lt;__printf_chk@plt&gt;8048aa6:c7 04 24 08 00 00 00 movl   $0x8,(%esp)8048aad:e8 7e fd ff ff       call   8048830 &lt;exit@plt&gt;8048ab2:e8 7c 06 00 00       call   8049133 &lt;initialize_bomb&gt;8048ab7:c7 04 24 cc a1 04 08 movl   $0x804a1cc,(%esp)8048abe:e8 2d fd ff ff       call   80487f0 &lt;puts@plt&gt;8048ac3:c7 04 24 08 a2 04 08 movl   $0x804a208,(%esp)8048aca:e8 21 fd ff ff       call   80487f0 &lt;puts@plt&gt;8048acf:e8 7d 07 00 00       call   8049251 &lt;read_line&gt;8048ad4:89 04 24             mov    %eax,(%esp)8048ad7:e8 b4 00 00 00       call   8048b90 &lt;phase_1&gt;                                                  //phase_1的位置，往下翻找即可8048adc:e8 6e 08 00 00       call   804934f &lt;phase_defused&gt;8048ae1:c7 04 24 34 a2 04 08 movl   $0x804a234,(%esp)</code></pre></div><p>然后再就是<code>phase_1</code>:  </p><div class="code-wrapper"><pre><code class="hljs text">08048b90 &lt;phase_1&gt;: 8048b90:55                   push   %ebp 8048b91:89 e5                mov    %esp,%ebp 8048b93:83 ec 18             sub    $0x18,%esp //开栈 8048b96:c7 44 24 04 84 a2 04 movl   $0x804a284,0x4(%esp)                                            //将0x804a284的内容存放到esp+4的位置 8048b9d:08  8048b9e:8b 45 08             mov    0x8(%ebp),%eax                                           //esp+8，从调用函数处取第一个参数放到eax寄中 8048ba1:89 04 24             mov    %eax,(%esp)                                           //传送到esp寄存器 8048ba4:e8 19 05 00 00       call   80490c2 &lt;strings_not_equal&gt;                                           //入口函数， 判断字符串是否相等（判断esp+4和esp+8的字符串是否相等） 8048ba9:85 c0                test   %eax,%eax                                           //当两个字符串相等时返回eax=0 8048bab:74 05                je     8048bb2 &lt;phase_1+0x22&gt;                                           //是否引爆炸弹的条件（eax=0跳到leave，否则引爆炸弹，因此通关的条件是eax=0） 8048bad:e8 25 06 00 00       call   80491d7 &lt;explode_bomb&gt; 8048bb2:c9                   leave   8048bb3:c3                   ret</code></pre></div><p>根据以上分析可知，程序先将输入的参数存放到<code>ebp+8</code>的位置，接着传送到<code>esp</code>中，然后函数在<code>0x804a284</code>这个地址取值，放到<code>esp+8</code>中。最后传送到<code>eax</code>进行比较，如果相等，返回<code>eax = 0</code>，跳到<code>leave</code>结束，不相等则返回<code>1</code>，同时调用引爆炸弹的函数。因此只要查看<code>0x804a284</code>这个地址的内容就能找到密码！用<code>GDB调试工具</code>进行查看：<br><a href="https://imgtu.com/i/qvZLCD"><img src="https://s1.ax1x.com/2022/04/06/qvZLCD.md.png" alt="qvZLCD.md.png"></a></p><p>还可以使用方法二：</p><div class="code-wrapper"><pre><code class="hljs mipsasm">Objdump --start-<span class="hljs-keyword">address=0x804a0fc </span>–s <span class="hljs-keyword">bomb </span>  <span class="hljs-comment">#方法2</span></code></pre></div><p>建议慎用 T T<br><a href="https://imgtu.com/i/qvZHUK"><img src="https://s1.ax1x.com/2022/04/06/qvZHUK.md.png" alt="qvZHUK.md.png"></a><br>密码是出来了，但是多了一长串的后面地址的内容。</p><p><code>phase_1</code>的密码：  </p><blockquote><p>Public speaking is very easy.  </p></blockquote><p>将其放入<code>ans.txt</code>中再<code>./bomb ans.txt</code>可得：<br><a href="https://imgtu.com/i/qvZ7E6"><img src="https://s1.ax1x.com/2022/04/06/qvZ7E6.md.png" alt="qvZ7E6.md.png"></a></p><p>一下简要介绍GBD在本次拆炸弹中的使用：</p><h5 id="GDB工具的使用"><a href="#GDB工具的使用" class="headerlink" title="GDB工具的使用"></a>GDB工具的使用</h5><p>terminal输入gdb bomb，即是调试bomb这个程序，显示如下：</p><div class="code-wrapper"><pre><code class="hljs text">b xxx   //在XX处设置断点ni      //单步执行机器指令x/2s    //查看地址中的两个字符串x/d     //查看地址中的整数</code></pre></div><div class="code-wrapper"><pre><code class="hljs text">GNU gdb (GDB) 7.2-ubuntuCopyright (C) 2010 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;i686-linux-gnu&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;..../bomb/bomblab/src/bomb...done.gdb) b main        #在main函数的开始处设置断点   Breakpoint 1 at 0x80489a5: file bomb.c, line 45.(gdb) r                  #从gdb里运行bomb程序Starting program:./bomb/bomblab/src/bomb                               # 运行后，暂停在断点1处Breakpoint 1, main (argc=1, argv=0xbffff3f4) at bomb.c:4545    if (argc == 1) &#123; (gdb) ni                #单步执行机器指令0x080489a845    if (argc == 1) &#123;  (gdb) ni46infile = stdin;   #这里可以看到执行到哪一条C语句(gdb) ni73    input = read_line();             /* Get input                   */(gdb) ni                /*如果是命令行输入，这里输入你的拆弹字符串*/74    phase_1(input);                  /* Run the phase               */(gdb) x/2s 0x804a284       #查看地址0x804a0fc处两个字符串：0x804a284:&quot;Public speaking is very easy.&quot;0x804a2a2:&quot;%d %c %d&quot; (gdb) q                          #退出gdb               ```  #### Phase_2可知此次是关于循环的，不多BB直接上汇编：```text08048bb4 &lt;phase_2&gt;: 8048bb4:55                   push   %ebp 8048bb5:89 e5                mov    %esp,%ebp 8048bb7:56                   push   %esi 8048bb8:53                   push   %ebx                                           //esi和ebx为调用者保存寄存器，因为后面的循环用到了者两个寄存器，因此要压栈保存 8048bb9:83 ec 30             sub    $0x30,%esp                                            //esp - 48开栈 8048bbc:8d 45 e0             lea    -0x20(%ebp),%eax 8048bbf:89 44 24 04          mov    %eax,0x4(%esp)                                           //以上两句将ebp-32处的地址借助eax传给esp+4处 8048bc3:8b 45 08             mov    0x8(%ebp),%eax 8048bc6:89 04 24             mov    %eax,(%esp)                                           //以上两句将ebp+8处的地址传给esp 8048bc9:e8 33 06 00 00       call   8049201 &lt;read_six_numbers&gt;                                           //输入6个数 8048bce:83 7d e0 01          cmpl   $0x1,-0x20(%ebp)                                           //(ebp - 32)- 1 = 0 8048bd2:74 1e                je     8048bf2 &lt;phase_2+0x3e&gt;                                           //引爆炸弹的条件，不为1则引爆炸弹。因此ebp-32处要为1，从前面看，这是存放输入参数的位置 8048bd4:e8 fe 05 00 00       call   80491d7 &lt;explode_bomb&gt; 8048bd9:eb 17                jmp    8048bf2 &lt;phase_2+0x3e&gt; 8048bdb:8b 43 fc             mov    -0x4(%ebx),%eax 8048bde:01 c0                add    %eax,%eax 8048be0:39 03                cmp    %eax,(%ebx)                                           //以上三句将(ebx-4)传给eax，eax = eax*2                                            eax - ebx = 0就跳转，反之不为0，引爆炸弹 8048be2:74 05                je     8048be9 &lt;phase_2+0x35&gt; 8048be4:e8 ee 05 00 00       call   80491d7 &lt;explode_bomb&gt; 8048be9:83 c3 04             add    $0x4,%ebx                                           //ebx上移4，ebx+4 8048bec:39 f3                cmp    %esi,%ebx                                           // esi - ebx ！= 0 8048bee:75 eb                jne    8048bdb &lt;phase_2+0x27&gt; 8048bf0:eb 08                jmp    8048bfa &lt;phase_2+0x46&gt;                                           //当esi=ebx时跳出循环，反之继续循环。 8048bf2:8d 5d e4             lea    -0x1c(%ebp),%ebx                                           //ebp - 28传给ebx(调用者帧保存) 8048bf5:8d 75 f8             lea    -0x8(%ebp),%esi                                           //ebp - 8 传给esi(调用者帧保存) 8048bf8:eb e1                jmp    8048bdb &lt;phase_2+0x27&gt; 8048bfa:83 c4 30             add    $0x30,%esp 8048bfd:5b                   pop    %ebx 8048bfe:5e                   pop    %esi 8048bff:5d                   pop    %ebp 8048c00:c3                   ret</code></pre></div><p>栈图如下：<br><a href="https://imgtu.com/i/qvZd3Q"><img src="https://s1.ax1x.com/2022/04/06/qvZd3Q.png" alt="qvZd3Q.png"></a><br>分析：<br>显然是一个首项为1，公比为2的等比数列。</p><p>第二关密码：</p><blockquote><p>1 2 4 8 16 32</p></blockquote><h4 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase_3"></a>Phase_3</h4><p>可知本关与switch有关，有分支，故而代码较长，解题选一种情况即可（看了才知道的）。<br>继续上汇编代码：</p><div class="code-wrapper"><pre><code class="hljs text">08048c01 &lt;phase_3&gt;: 8048c01:55                   push   %ebp 8048c02:89 e5                mov    %esp,%ebp 8048c04:83 ec 38             sub    $0x38,%esp                                           // esp-56开栈 8048c07:8d 45 f4             lea    -0xc(%ebp),%eax 8048c0a:89 44 24 10          mov    %eax,0x10(%esp)                                           //ebp-12 借助eax传给esp + 16 8048c0e:8d 45 ef             lea    -0x11(%ebp),%eax 8048c11:89 44 24 0c          mov    %eax,0xc(%esp)                                           //ebp-17借助eax传给esp+12 8048c15:8d 45 f0             lea    -0x10(%ebp),%eax 8048c18:89 44 24 08          mov    %eax,0x8(%esp)                                           //ebp-16借助eax传给esp+8 8048c1c:c7 44 24 04 a2 a2 04 movl   $0x804a2a2,0x4(%esp)                                           //将0x804a2a2的内容传给esp+8                                           //GDB查看发现是%d%c%d 8048c23:08</code></pre></div><p>0x804a2a2这个地址有点熟悉哦，感觉在哪见过——<br><a href="https://imgtu.com/i/qvZd3Q"><img src="https://s1.ax1x.com/2022/04/06/qvZd3Q.png" alt="qvZd3Q.png"></a><br>好家伙，查0x804a284的时候就出现0x804a2a2了，还是进入GDB再看看。<br><a href="https://imgtu.com/i/qvZa9g"><img src="https://s1.ax1x.com/2022/04/06/qvZa9g.png" alt="qvZa9g.png"></a><br>好家伙，确实是这样，需要我们输入<code>%d %c %d</code>,两个整数，一个字符。（所以这也是这个的原因）</p><blockquote><p>lea    -0x11(%ebp),%eax<br>mov    %eax,0xc(%esp)<br>&#x2F;&#x2F;ebp-17借助eax传给esp+12</p></blockquote><p>第二个参数只占一个一个字节。（这里之前想了好久。。。。。。）<br>继续看汇编：</p><div class="code-wrapper"><pre><code class="hljs text">8048c24:8b 45 08             mov    0x8(%ebp),%eax8048c27:89 04 24             mov    %eax,(%esp)                                          // ebp-8借助eax传给esp8048c2a:e8 31 fc ff ff       call   8048860 &lt;__isoc99_sscanf@plt&gt;                                          //读入函数，将你输入的参数按指定格式读到相应的地址8048c2f:83 f8 02             cmp    $0x2,%eax                                          //eax接受ssacnf函数的返回值，说明sscanf函数的返回值是参数个数，如果大于2跳过炸弹，否则引爆炸弹。8048c32:7f 05                jg     8048c39 &lt;phase_3+0x38&gt;8048c34:e8 9e 05 00 00       call   80491d7 &lt;explode_bomb&gt;8048c39:83 7d f0 07          cmpl   $0x7,-0x10(%ebp)8048c3d:0f 87 e9 00 00 00    ja     8048d2c &lt;phase_3+0x12b&gt;                                          //以上两句说明ebp-16不能超过7，否则就引爆炸弹。8048c43:8b 45 f0             mov    -0x10(%ebp),%eax                                          //ebp-16赋给eax8048c46:ff 24 85 c0 a2 04 08 jmp    *0x804a2c0(,%eax,4)                                          //间接跳转，跳到*0x804a2c0这个地址，这是第三关的核心代码！</code></pre></div><p>详细分析：<br>ja : 无符号大于则跳转; 代表ebp-16中的内容只能小于等于7，大于等于0，再看上面的代码易知ebp-16是第一个参数，故设第一个参数为i，再往下看可知：</p><blockquote><p>i &#x3D; 0, 1, 2, 3, 4, 5, 6, 7</p></blockquote><p>所以就会有8个不同的密码！</p><blockquote><p>-0x10(%ebp),%eax &#x2F;&#x2F;ebp-16赋给eax</p></blockquote><p>即第一个参数赋给eax。</p><blockquote><p>jmp    *0x804a2c0(,%eax,4)</p></blockquote><p>用GDB查看*0x804a2c0,可知这个指针指向0x8048c4d。即使当i&#x3D;1的情况。<br>仔细一看发现后面的汇编大体相似，应该就是i取值不同时的不同情况。</p><div class="code-wrapper"><pre><code class="hljs text">8048c4d:b8 6d 00 00 00       mov    $0x6d,%eax                                          // eax = 0x6d8048c52:81 7d f4 f0 01 00 00 cmpl   $0x1f0,-0xc(%ebp)8048c59:0f 84 d7 00 00 00    je     8048d36 &lt;phase_3+0x135&gt;                                          // ebp-12 = 0x1f0 跳转，反之爆炸。8048c5f:e8 73 05 00 00       call   80491d7 &lt;explode_bomb&gt;8048c64:b8 6d 00 00 00       mov    $0x6d,%eax                                          // eax = 0x6d8048c69:e9 c8 00 00 00       jmp    8048d36 &lt;phase_3+0x135&gt;</code></pre></div><p>edp-12是第三个参数，为496</p><div class="code-wrapper"><pre><code class="hljs llvm"><span class="hljs-number">8048</span>d<span class="hljs-number">2</span><span class="hljs-keyword">c</span>:e<span class="hljs-number">8</span> a<span class="hljs-number">6</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       <span class="hljs-keyword">call</span>   <span class="hljs-number">80491</span>d<span class="hljs-number">7</span> &lt;explode_bomb&gt;<span class="hljs-number">8048</span>d<span class="hljs-number">31</span>:b<span class="hljs-number">8</span> <span class="hljs-number">77</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x77</span><span class="hljs-punctuation">,</span><span class="hljs-variable">%eax</span><span class="hljs-number">8048</span>d<span class="hljs-number">36</span>:<span class="hljs-number">3</span>a <span class="hljs-number">45</span> ef             cmp    <span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">11</span>(<span class="hljs-variable">%ebp</span>)<span class="hljs-punctuation">,</span><span class="hljs-variable">%al</span>                                          // 比较ebp<span class="hljs-number">-17</span> 和 al寄存器中的值，相等结束，反之爆炸。<span class="hljs-number">8048</span>d<span class="hljs-number">39</span>:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">8048</span>d<span class="hljs-number">40</span> &lt;phase_<span class="hljs-number">3</span><span class="hljs-number">+0</span><span class="hljs-keyword">x</span><span class="hljs-number">13</span>f&gt;<span class="hljs-number">8048</span>d<span class="hljs-number">3</span>b:e<span class="hljs-number">8</span> <span class="hljs-number">97</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       <span class="hljs-keyword">call</span>   <span class="hljs-number">80491</span>d<span class="hljs-number">7</span> &lt;explode_bomb&gt;<span class="hljs-number">8048</span>d<span class="hljs-number">40</span>:<span class="hljs-keyword">c</span><span class="hljs-number">9</span>                   leave  <span class="hljs-number">8048</span>d<span class="hljs-number">41</span>:<span class="hljs-keyword">c</span><span class="hljs-number">3</span>                   <span class="hljs-keyword">ret</span></code></pre></div><p>al寄存器是eax的低8位，举例</p><blockquote><p>mov eax 12345678h<br>mov al 78h<br>AX是EAX的低16位<br>AH是ax的高8位，而AL是ax的低8位  </p></blockquote><p>差不多这个意思。</p><blockquote><p>cmp    -0x11(%ebp),%al<br>je     8048d40 &lt;phase_3+0x13f&gt;</p></blockquote><p>就是第二个参数等于al中的内容，即上面eax的内容（eax &#x3D; 0x6d）<br>定义 char B;<br>B是第二个参数，B &#x3D; 0x6d。<br>查ASCII码表知   B &#x3D; m。<br><a href="https://imgtu.com/i/qvZYAf"><img src="https://s1.ax1x.com/2022/04/06/qvZYAf.md.png" alt="qvZYAf.md.png"></a></p><p>所以其中一个密码为<br>0 m 496</p><p>以下分析方法同上，就不做重复的分析：</p><div class="code-wrapper"><pre><code class="hljs text"> 8048c6e:b8 6f 00 00 00       mov    $0x6f,%eax 8048c73:81 7d f4 5a 01 00 00 cmpl   $0x15a,-0xc(%ebp) 8048c7a:0f 84 b6 00 00 00    je     8048d36 &lt;phase_3+0x135&gt; 8048c80:e8 52 05 00 00       call   80491d7 &lt;explode_bomb&gt; 8048c85:b8 6f 00 00 00       mov    $0x6f,%eax 8048c8a:e9 a7 00 00 00       jmp    8048d36 &lt;phase_3+0x135&gt; 8048c8f:b8 70 00 00 00       mov    $0x70,%eax 8048c94:83 7d f4 64          cmpl   $0x64,-0xc(%ebp) 8048c98:0f 84 98 00 00 00    je     8048d36 &lt;phase_3+0x135&gt; 8048c9e:e8 34 05 00 00       call   80491d7 &lt;explode_bomb&gt; 8048ca3:b8 70 00 00 00       mov    $0x70,%eax 8048ca8:e9 89 00 00 00       jmp    8048d36 &lt;phase_3+0x135&gt; 8048cad:b8 68 00 00 00       mov    $0x68,%eax 8048cb2:83 7d f4 3d          cmpl   $0x3d,-0xc(%ebp) 8048cb6:74 7e                je     8048d36 &lt;phase_3+0x135&gt; 8048cb8:e8 1a 05 00 00       call   80491d7 &lt;explode_bomb&gt; 8048cbd:b8 68 00 00 00       mov    $0x68,%eax 8048cc2:eb 72                jmp    8048d36 &lt;phase_3+0x135&gt; 8048cc4:b8 6f 00 00 00       mov    $0x6f,%eax 8048cc9:81 7d f4 02 02 00 00 cmpl   $0x202,-0xc(%ebp) 8048cd0:74 64                je     8048d36 &lt;phase_3+0x135&gt; 8048cd2:e8 00 05 00 00       call   80491d7 &lt;explode_bomb&gt; 8048cd7:b8 6f 00 00 00       mov    $0x6f,%eax 8048cdc:eb 58                jmp    8048d36 &lt;phase_3+0x135&gt; 8048cde:b8 6e 00 00 00       mov    $0x6e,%eax 8048ce3:81 7d f4 d5 00 00 00 cmpl   $0xd5,-0xc(%ebp) 8048cea:74 4a                je     8048d36 &lt;phase_3+0x135&gt; 8048cec:e8 e6 04 00 00       call   80491d7 &lt;explode_bomb&gt; 8048cf1:b8 6e 00 00 00       mov    $0x6e,%eax 8048cf6:eb 3e                jmp    8048d36 &lt;phase_3+0x135&gt; 8048cf8:b8 74 00 00 00       mov    $0x74,%eax 8048cfd:81 7d f4 97 01 00 00 cmpl   $0x197,-0xc(%ebp) 8048d04:74 30                je     8048d36 &lt;phase_3+0x135&gt; 8048d06:e8 cc 04 00 00       call   80491d7 &lt;explode_bomb&gt; 8048d0b:b8 74 00 00 00       mov    $0x74,%eax 8048d10:eb 24                jmp    8048d36 &lt;phase_3+0x135&gt;8048d12:b8 74 00 00 00       mov    $0x74,%eax8048d17:81 7d f4 9b 01 00 00 cmpl   $0x19b,-0xc(%ebp)8048d1e:74 16                je     8048d36 &lt;phase_3+0x135&gt;8048d20:e8 b2 04 00 00       call   80491d7 &lt;explode_bomb&gt;8048d25:b8 74 00 00 00       mov    $0x74,%eax8048d2a:eb 0a                jmp    8048d36 &lt;phase_3+0x135&gt;</code></pre></div><p>所以第三关密码为：<br>0 m 496<br>1 o 346<br>2 p 100<br>3 h 61<br>4 o 514<br>5 n 213<br>6 t 407<br>7 t 411<br>任选一组即可过关。  </p><h4 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h4><p>我们可知phase_4与递归的调用有关，不看不知道，一看吓一跳，递归在汇编里看着就是真的恶心啊。（主要还是自己看不明白（主要还是汇编学的不是很透彻））。<br>不多比比继续直接看代码：</p><div class="code-wrapper"><pre><code class="hljs text">08048da4 &lt;phase_4&gt;: 8048da4:55                   push   %ebp 8048da5:89 e5                mov    %esp,%ebp 8048da7:83 ec 28             sub    $0x28,%esp                                           //esp-40开栈 8048daa:8d 45 f4             lea    -0xc(%ebp),%eax 8048dad:89 44 24 0c          mov    %eax,0xc(%esp)                                           //ebp-12借助eax传给esp+12 8048db1:8d 45 f0             lea    -0x10(%ebp),%eax 8048db4:89 44 24 08          mov    %eax,0x8(%esp)                                           //ebp-16借助eax传给esp+8 8048db8:c7 44 24 04 57 a4 04 movl   $0x804a457,0x4(%esp)                                           //使用GDB查看知需要输入两个整型 %d %d 8048dbf:08  8048dc0:8b 45 08             mov    0x8(%ebp),%eax 8048dc3:89 04 24             mov    %eax,(%esp)                                           //ebp+8借助eax传给esp 8048dc6:e8 95 fa ff ff       call   8048860 &lt;__isoc99_sscanf@plt&gt;                                           8048dcb:83 f8 02             cmp    $0x2,%eax                                           //判断参数个数是否为2，不为2，爆炸 8048dce:75 06                jne    8048dd6 &lt;phase_4+0x32&gt; 8048dd0:83 7d f0 0e          cmpl   $0xe,-0x10(%ebp)                                           //(ebp-16)-14 &lt;= 0 跳转，反之爆炸                                           //可知参数一是一个小于等于14的无符号型整数 8048dd4:76 05                jbe    8048ddb &lt;phase_4+0x37&gt; 8048dd6:e8 fc 03 00 00       call   80491d7 &lt;explode_bomb&gt;</code></pre></div><p>设参数一为A， 所以0 &lt;&#x3D; A &lt;&#x3D; 14  </p><div class="code-wrapper"><pre><code class="hljs text">8048ddb:c7 44 24 08 0e 00 00 movl   $0xe,0x8(%esp)                                          //exp+8 = 148048de2:00 8048de3:c7 44 24 04 00 00 00 movl   $0x0,0x4(%esp)                                          //esp+4 = 08048dea:00 8048deb:8b 45 f0             mov    -0x10(%ebp),%eax8048dee:89 04 24             mov    %eax,(%esp)                                          // ebp-16赋值给esp(参数1赋给esp)8048df1:e8 4c ff ff ff       call   8048d42 &lt;func4&gt;//进入递归</code></pre></div><p>进入递归Func4函数时传入了三个参数，即14，0，A（参数1）。<br> <div class="code-wrapper"><pre><code class="hljs text">8048df6:83 f8 06             cmp    $0x6,%eax                                          //eax是递归函数的返回值且为6，不为6，爆炸。8048df9:75 06                jne    8048e01 &lt;phase_4+0x5d&gt;8048dfb:83 7d f4 06          cmpl   $0x6,-0xc(%ebp)                                          //(ebp-12) - 6 = 0                                          // ebp-12是参数2，即参数2为6。                                          // 参数2为6时，结束，反之爆炸。8048dff:74 05                je     8048e06 &lt;phase_4+0x62&gt;8048e01:e8 d1 03 00 00       call   80491d7 &lt;explode_bomb&gt;8048e06:c9                   leave  8048e07:c3                   ret</code></pre></div><br> 分析到这里时，我们已经知道了<code>参数1</code>的范围<code>[0, 14]</code>, <code>参数2</code>为<code>6</code>。<br> 其实我们擦不多就可以结束phase4的分析了，差不多可以知道密码了。<br> 我们可以一个一个地带进去试验  即输入<code>i 6</code>,其中<code>i = 0, 1, 2, ..., 14</code>。<br> 最后我们可以得到第四关地密码：<br> <code>6 6  </code></p><p> 但是投机取巧并不好，万一有人问道——递归函数（func4）时怎么样的呢<br> 那么你就回答不上来了。  所以我们还要继续分析，知道全部熟络于心。<br> 但是下面的递归是真的难，真的花时间。  </p><p> 现在我们开始func4的分析：<br> <div class="code-wrapper"><pre><code class="hljs text">08048d42 &lt;func4&gt;: 8048d42:55                   push   %ebp 8048d43:89 e5                mov    %esp,%ebp 8048d45:56                   push   %esi 8048d46:53                   push   %ebx 8048d47:83 ec 10             sub    $0x10,%esp                                           //esp-16开栈 8048d4a:8b 55 08             mov    0x8(%ebp),%edx //ebp+8赋给edx，记为参数A 8048d4d:8b 45 0c             mov    0xc(%ebp),%eax //ebp+12赋给eax，记为参数B 8048d50:8b 5d 10             mov    0x10(%ebp),%ebx //ebp+16赋给ebx，记为参数C                                            8048d53:89 d9                mov    %ebx,%ecx //ebx赋给ecx 8048d55:29 c1                sub    %eax,%ecx //ecx=ecx-eax=C-B 8048d57:89 ce                mov    %ecx,%esi //ecx赋给esi 8048d59:c1 ee 1f             shr    $0x1f,%esi //esi逻辑右移31位 8048d5c:01 f1                add    %esi,%ecx //ecx=ecx+esi 8048d5e:d1 f9                sar    %ecx //ecx算术右移1位，就是C/2。 8048d60:01 c1                add    %eax,%ecx //ecx=ecx+eax</code></pre></div><br>上述汇编是对参数进行了算术运算。  </p><div class="code-wrapper"><pre><code class="hljs text">8048d62:39 d1                cmp    %edx,%ecx                                          //if(edx &lt;= ecx) 跳转到 8048d7d，否则顺序执行。8048d64:7e 17                jle    8048d7d &lt;func4+0x3b&gt;8048d66:83 e9 01             sub    $0x1,%ecx                                          // ecx=ecx-18048d69:89 4c 24 08          mov    %ecx,0x8(%esp)8048d6d:89 44 24 04          mov    %eax,0x4(%esp)8048d71:89 14 24             mov    %edx,(%esp)                                          //构造func4的参数8048d74:e8 c9 ff ff ff       call   8048d42 &lt;func4&gt;                                          //进入递归8048d79:01 c0                add    %eax,%eax                                          //eax=eax+eax                                          //递归返回值加倍8048d7b:eb 20                jmp    8048d9d &lt;func4+0x5b&gt;8048d7d:b8 00 00 00 00       mov    $0x0,%eax                                          //eax=08048d82:39 d1                cmp    %edx,%ecx                                          if(edx &gt;= ecx) 递归终止，否则顺序执行。8048d84:7d 17                jge    8048d9d &lt;func4+0x5b&gt;8048d86:89 5c 24 08          mov    %ebx,0x8(%esp)8048d8a:83 c1 01             add    $0x1,%ecx                                          //ecx=ecx+18048d8d:89 4c 24 04          mov    %ecx,0x4(%esp)8048d91:89 14 24             mov    %edx,(%esp)                                          //构造func4的参数8048d94:e8 a9 ff ff ff       call   8048d42 &lt;func4&gt;                                          //进入递归8048d99:8d 44 00 01          lea    0x1(%eax,%eax,1),%eax                                          //eax=eax*2+1                                          //递归返回值加倍后加一8048d9d:83 c4 10             add    $0x10,%esp8048da0:5b                   pop    %ebx8048da1:5e                   pop    %esi8048da2:5d                   pop    %ebp8048da3:c3                   ret</code></pre></div><p>最终可得C语言函数func4：  </p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func4</span><span class="hljs-params">(<span class="hljs-type">int</span> ebx, <span class="hljs-type">int</span> eax, <span class="hljs-type">int</span> edx)</span>&#123;    <span class="hljs-type">int</span> esi = (ebx - eax) &gt;&gt; <span class="hljs-number">31</span>;    <span class="hljs-type">int</span> ecx = (ebx - eax + esi) &gt;&gt; <span class="hljs-number">1</span>;    ecx = ecx + eax;    <span class="hljs-keyword">if</span> (edx == ecx)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (edx &gt; ecx)        <span class="hljs-keyword">return</span> func4(ebx, ecx + <span class="hljs-number">1</span>, edx) * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> func4(ecx - <span class="hljs-number">1</span>, eax, edx) * <span class="hljs-number">2</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">14</span>; i++)    &#123;        <span class="hljs-keyword">if</span> (func4(<span class="hljs-number">14</span>, <span class="hljs-number">0</span>, i) == <span class="hljs-number">6</span>)        &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);            getchar();            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;    getchar();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>于是可得需要输入的第一个参数为<code>6</code>。<br>故phase_4的密码为：<br>6 6  </p><h4 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h4><div class="code-wrapper"><pre><code class="hljs text">08048e08 &lt;phase_5&gt;: 8048e08:55                   push   %ebp 8048e09:89 e5                mov    %esp,%ebp 8048e0b:83 ec 28             sub    $0x28,%esp                                       //esp-40开栈 8048e0e:8d 45 f4             lea    -0xc(%ebp),%eax 8048e11:89 44 24 0c          mov    %eax,0xc(%esp) 8048e15:8d 45 f0             lea    -0x10(%ebp),%eax 8048e18:89 44 24 08          mov    %eax,0x8(%esp)                                       //两个参数的赋值，分别为参数1，参数2，可知本关需要输入两个参数 8048e1c:c7 44 24 04 57 a4 04 movl   $0x804a457,0x4(%esp)                                       //使用GDB可知为%d %d，故需要输入两个整型参数 8048e23:08  8048e24:8b 45 08             mov    0x8(%ebp),%eax 8048e27:89 04 24             mov    %eax,(%esp) 8048e2a:e8 31 fa ff ff       call   8048860 &lt;__isoc99_sscanf@plt&gt; 8048e2f:83 f8 01             cmp    $0x1,%eax 8048e32:7f 05                jg     8048e39 &lt;phase_5+0x31&gt; 8048e34:e8 9e 03 00 00       call   80491d7 &lt;explode_bomb&gt;                                       //这一段的意思就是（前几关说过）                                       //需要输入大于一个的参数个数，否则爆炸 8048e39:8b 45 f0             mov    -0x10(%ebp),%eax                                       //参数1赋给eax 8048e3c:83 e0 0f             and    $0xf,%eax                                       //按位与操作，即eax = eax &amp; 0xf                                       //按位与后eax 必然小于等于 0x0000 000f 8048e3f:89 45 f0             mov    %eax,-0x10(%ebp)                                       //eax 赋给ebp-16 8048e42:83 f8 0f             cmp    $0xf,%eax                                       //if ((ebp-16) - 15 == 0) 爆炸，否则顺序执行。                                       //故经过按位与和比较后可知参数1小于15                                        8048e45:74 28                je     8048e6f &lt;phase_5+0x67&gt; 8048e47:b9 00 00 00 00       mov    $0x0,%ecx 8048e4c:ba 00 00 00 00       mov    $0x0,%edx 8048e51:83 c2 01             add    $0x1,%edx                                       //令ecx = 0; edx = 0;                                       // edx += 1;循环的次数 8048e54:8b 04 85 e0 a2 04 08 mov    0x804a2e0(,%eax,4),%eax                                       //使用GDB知0x804a2e0为一维数组的首地址                                       //操作为 eax = array[eax]                                       //首次的eax = 输入的参数一</code></pre></div><p>经GDB得数组为<code>array[16]=&#123;10,2,14,7,8,12,15,11,0,4,1,13,3,9,6,5&#125;</code>。</p><div class="code-wrapper"><pre><code class="hljs text">8048e5b:01 c1                add    %eax,%ecx                                      //ecx = ecx + array[eax]8048e5d:83 f8 0f             cmp    $0xf,%eax                                      //当eax!=15时继续循环，否则跳出循环。                                      //跳出循环时eax=158048e60:75 ef                jne    8048e51 &lt;phase_5+0x49&gt;8048e62:89 45 f0             mov    %eax,-0x10(%ebp)                                      //(ebp-16)=eax8048e65:83 fa 0f             cmp    $0xf,%edx                                      //当循环次数小于15次时顺序执行，否则爆炸。8048e68:75 05                jne    8048e6f &lt;phase_5+0x67&gt;8048e6a:3b 4d f4             cmp    -0xc(%ebp),%ecx                                      //if (参数2 == ecx) 结束，否则爆炸。8048e6d:74 05                je     8048e74 &lt;phase_5+0x6c&gt;8048e6f:e8 63 03 00 00       call   80491d7 &lt;explode_bomb&gt;8048e74:c9                   leave  8048e75:c3                   ret</code></pre></div><p> 分析：<br> 分析得参数2 &#x3D; 循环时数组元素的和，即sum +&#x3D; array[eax]，开始进行循环时 eax &#x3D; array[参数1]，循环时eax的取值为 0 - 14，循环结束时 eax &#x3D; 15，15是读取数组得来的。想要知道参数1的值就需要逆向推理求sum的过程，由<code>0x804a2e0(,%eax,4),%eax</code>可得也就是<code>eax=array[eax]</code>，所以就是当eax&#x3D;15是逆向运算，直到eax为参数1即可结束，参数2也是循环过程中所得array[eax]的和。<br> 逆向过程：</p><blockquote><p>array[6] &#x3D; 15;<br>array[14] &#x3D; 6;<br>array[2] &#x3D; 14;<br>array[1] &#x3D; 2;<br>array[10] &#x3D; 1;<br>array[0] &#x3D; 10;<br>array[8] &#x3D; 0;<br>array[4] &#x3D; 8;<br>array[9] &#x3D; 4;<br>array[13] &#x3D; 9;<br>array[11] &#x3D; 13;<br>array[7] &#x3D; 11;<br>array[3] &#x3D; 7;<br>array[12] &#x3D; 3;<br>以上时循环时的变化<br>array[参数1] &#x3D; 12;<br>看数组知array[5] &#x3D; 12 所以参数1 &#x3D; 5</p></blockquote><p>所以参数2为上述数组元素之和 &#x3D; 115，参数1 &#x3D; 5。<br>phase_5密码：<br>5 115  </p><h4 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h4><p>phase_6是一个关于链表的关卡，需要输入6个数字。</p><div class="code-wrapper"><pre><code class="hljs text">08048e76 &lt;phase_6&gt;: 8048e76:55                   push   %ebp 8048e77:89 e5                mov    %esp,%ebp 8048e79:56                   push   %esi 8048e7a:53                   push   %ebx                                       ////以上两个为调用者保存寄存器，后面的循环用到，故压栈保存(寄存器数量有限，要将原来的状态保存，因为要复原） 8048e7b:83 ec 40             sub    $0x40,%esp                                       //esp-64开栈 8048e7e:8d 45 c8             lea    -0x38(%ebp),%eax 8048e81:89 44 24 04          mov    %eax,0x4(%esp)                                       //ebp-56借助eax传给esp+4 8048e85:8b 45 08             mov    0x8(%ebp),%eax 8048e88:89 04 24             mov    %eax,(%esp)                                       //ebp+8 借助eax传给esp 8048e8b:e8 71 03 00 00       call   8049201 &lt;read_six_numbers&gt;                                       ////读入6个数 8048e90:be 00 00 00 00       mov    $0x0,%esi //清零 8048e95:8b 44 b5 c8          mov    -0x38(%ebp,%esi,4),%eax                                       // eax = (ebp-64) + 4*esi                                       //当前esi=0，亦即把ebp-64赋给eax，对于不同的esi，就是从ebp-64向上找第esi个数赋给eax。 8048e99:83 e8 01             sub    $0x1,%eax //eax -= 1 8048e9c:83 f8 05             cmp    $0x5,%eax                                         //if (5 &gt;= eax-1) 跳转，否则爆炸                                       //jbe是无符号数操作，故推知eax的范围为1-6 8048e9f:76 05                jbe    8048ea6 &lt;phase_6+0x30&gt; 8048ea1:e8 31 03 00 00       call   80491d7 &lt;explode_bomb&gt; 8048ea6:83 c6 01             add    $0x1,%esi                                        //esi += 1;                                       //(取第二个数） 8048ea9:83 fe 06             cmp    $0x6,%esi                                        //if (esi - 6 != 0) 跳转，否则顺序执行                                        //判断取的数是否超过6个，若大于6个引爆炸弹。从而推知循环结束的条件是esi=6。 8048eac:75 07                jne    8048eb5 &lt;phase_6+0x3f&gt; 8048eae:bb 00 00 00 00       mov    $0x0,%ebx //ebx = 0 8048eb3:eb 3a                jmp    8048eef &lt;phase_6+0x79&gt; 8048eb5:89 f3                mov    %esi,%ebx // ebx = esi 8048eb7:8b 44 9d c8          mov    -0x38(%ebp,%ebx,4),%eax                                       //eax = (ebp-64) + 4*ebx 8048ebb:39 44 b5 c4          cmp    %eax,-0x3c(%ebp,%esi,4)                                       // if (eax - ((ebx-64) + 4*esi)!=0)跳转，否则爆炸 8048ebf:75 05                jne    8048ec6 &lt;phase_6+0x50&gt; 8048ec1:e8 11 03 00 00       call   80491d7 &lt;explode_bomb&gt; 8048ec6:83 c3 01             add    $0x1,%ebx //ebx+=1 8048ec9:83 fb 05             cmp    $0x5,%ebx //if (5 &lt;= ebx) 跳转，否则顺序执行 8048ecc:7e e9                jle    8048eb7 &lt;phase_6+0x41&gt; 8048ece:66 90                xchg   %ax,%ax //交换16位寄存器中的内容 8048ed0:eb c3                jmp    8048e95 &lt;phase_6+0x1f&gt; 8048ed2:8b 52 08             mov    0x8(%edx),%edx // edx+8赋给edx 8048ed5:83 c0 01             add    $0x1,%eax //eax += 1 8048ed8:39 c8             p-&gt;  cmp    %ecx,%eax //if (ecx - eax != 0) 跳转，否则顺序执行 8048eda:75 f6                jne    8048ed2 &lt;phase_6+0x5c&gt; 8048edc:eb 05                jmp    8048ee3 &lt;phase_6+0x6d&gt; 8048ede:ba 3c c1 04 08       mov    $0x804c13c,%edx                                       //0x804c13c中的内容赋给edx                                       //用GDB查看发现它是链表表头的首地址，推知第六关是对链表进行操作 8048ee3:89 54 b5 e0          mov    %edx,-0x20(%ebp,%esi,4)                                       //（ebp-32）+ sei*4 = edx 8048ee7:83 c3 01             add    $0x1,%ebx //ebx+=1 8048eea:83 fb 06             cmp    $0x6,%ebx //ebx = 6跳转，否则顺序执行 8048eed:74 17                je     8048f06 &lt;phase_6+0x90&gt; 8048eef:89 de                mov    %ebx,%esi //ebx赋给esi 8048ef1:8b 4c 9d c8          mov    -0x38(%ebp,%ebx,4),%ecx                                        //ecx=(ebp-64)+4*ebx 8048ef5:83 f9 01             cmp    $0x1,%ecx                                       //if(1&lt;=ecx)跳转，否则顺序执行 8048ef8:7e e4                jle    8048ede &lt;phase_6+0x68&gt; 8048efa:b8 01 00 00 00       mov    $0x1,%eax // eax=1 8048eff:ba 3c c1 04 08       mov    $0x804c13c,%edx                                        //0x804c13c中的值赋给edx                                       //用GDB查看发现它是链表表头的首地址，推知第六关是对链表进行操作 8048f04:eb cc                jmp    8048ed2 &lt;phase_6+0x5c&gt; 8048f06:8b 5d e0             mov    -0x20(%ebp),%ebx                                        //ebp-32赋给ebx 8048f09:8d 45 e4             lea    -0x1c(%ebp),%eax                                       //ebp-28赋给eax 8048f0c:8d 75 f8             lea    -0x8(%ebp),%esi                                       //ebp-8赋给esi 8048f0f:89 d9                mov    %ebx,%ecx                                         //ebx赋给ecx 8048f11:8b 10                mov    (%eax),%edx                                       //edx = eax中的内容 8048f13:89 51 08             mov    %edx,0x8(%ecx)                                        //edx赋给ecx+8 8048f16:83 c0 04             add    $0x4,%eax //eax += 4 8048f19:39 f0                cmp    %esi,%eax                                        // esi = eax跳转，否则顺序执行 8048f1b:74 04                je     8048f21 &lt;phase_6+0xab&gt; 8048f1d:89 d1                mov    %edx,%ecx//edx赋给ecx 8048f1f:eb f0                jmp    8048f11 &lt;phase_6+0x9b&gt; 8048f21:c7 42 08 00 00 00 00 movl   $0x0,0x8(%edx)                                       //edx+8=0 8048f28:be 05 00 00 00       mov    $0x5,%esi                                       //esi=5 8048f2d:8b 43 08             mov    0x8(%ebx),%eax                                       //ebx+8赋给eax 8048f30:8b 00                mov    (%eax),%eax                                       //eax = eax中的内容 8048f32:39 03                cmp    %eax,(%ebx)                                       // eax &lt;= ebx中的内容 跳转，否则爆炸 8048f34:7e 05                jle    8048f3b &lt;phase_6+0xc5&gt; 8048f36:e8 9c 02 00 00       call   80491d7 &lt;explode_bomb&gt; 8048f3b:8b 5b 08             mov    0x8(%ebx),%ebx                                       //ebx+8 赋给ebx 8048f3e:83 ee 01             sub    $0x1,%esi //esi-1 &gt; 0跳回到循环中 8048f41:75 ea                jne    8048f2d &lt;phase_6+0xb7&gt; 8048f43:83 c4 40             add    $0x40,%esp 8048f46:5b                   pop    %ebx 8048f47:5e                   pop    %esi 8048f48:5d                   pop    %ebp 8048f49:c3                   ret</code></pre></div><p> 将上面分析得<br> 用GDB查看链表中的内容是（链表首地址是0x804c13c,下一个链表地址是上一个链表的地址+12）<br><a href="https://imgtu.com/i/qvZ8Bt"><img src="https://s1.ax1x.com/2022/04/06/qvZ8Bt.png" alt="qvZ8Bt.png"></a></p><blockquote><p>1 0x146<br>2 0x2dc<br>3 0x2f7<br>4 0x0a3<br>5 0x26c<br>6 0x225</p></blockquote><p>从小到大排序得  </p><blockquote><p>4 0x0a3<br>1 0x14f<br>6 0x225<br>5 0x26c<br>2 0x2dc<br>3 0x2fc</p></blockquote><p>故phase_6得密码为<br>4 1 6 5 2 3  </p><h4 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h4><p>由于老师、助教提供的实验、资料，他们在介绍实验的PPT里说明了——还有这个<code>secret_phase</code>关卡，也说明了——进入第七关需要在第四关后面输入一个字符串。<br>所以减少了的工作，但是我们还是要明白为什么是这样。  （还是实验前我并没有认真看PPT或者是我忘记了提示过还有个隐藏关卡，所以做到phase_6时，看着对应的汇编代码发现下面还有个<code>secret_phase</code>）  </p><p>当我们发现了还有个隐藏关卡时，发现了第一个问题——怎么进入<code>secret_phase</code>，毕竟输入完前六关的密码时，炸弹就全部解开了，没给我们输入什么的机会。所以该怎么进入呢。  </p><p>前六个都是在Main函数中顺序排好的，那我们就去看看main函数对应汇编代码会不会有线索。然而并没有发现与<code>secret_phase</code>有关的内容，但是发现每个phase_x后都有一个<code>phase_defused</code>。</p><div class="code-wrapper"><pre><code class="hljs text">call   xxxxxxx &lt;phase_x&gt;call   xxxxxxx &lt;phase_defused&gt;</code></pre></div><p>那么能否进入隐藏关卡是否与其有关呢。于是在查看<code>phase_defused</code>的汇编代码，发现<code>80493c9:e8 cf fb ff ff       call   8048f9d &lt;secret_phase&gt;</code>，这不就出现了嘛，那就看看里面是什么意思。</p><div class="code-wrapper"><pre><code class="hljs text">0804934f &lt;phase_defused&gt;: 804934f:55                   push   %ebp 8049350:89 e5                mov    %esp,%ebp 8049352:81 ec 88 00 00 00    sub    $0x88,%esp                                       //esp-128开栈 8049358:65 a1 14 00 00 00    mov    %gs:0x14,%eax</code></pre></div><p> 这意味着从地址gs：0x14的内存中读取4个字节到eax。 gs是一个段寄存器。最有可能的是线程本地存储(AKA TLS)通过该寄存器引用。(百度的，我不懂，搜索了很多，还是没怎么看明白%gs的意思，故而找了一个感觉对的)<br> <div class="code-wrapper"><pre><code class="hljs text">804935e:89 45 f4             mov    %eax,-0xc(%ebp) //ebp-12 = eax8049361:31 c0                xor    %eax,%eax //eax异或运算8049363:83 3d c8 c3 04 08 06 cmpl   $0x6,0x804c3c8                                       // 0x804c3c8 与 6比较                                      // 经GDB查看后发现0x804c3c8指向&lt;num_input_strings&gt;:&quot;\005&quot;                                      // 其中&quot;\005&quot;是调试时处于phase_5得到的值x                                      // 在不同得phase阶段查此地址会得到不同的&quot;\00x&quot;,x取决于第几个                                      // 所以 这一行是判断密码输入的次数是否 = 6804936a:75 6e                jne    80493da &lt;phase_defused+0x8b&gt;804936c:8d 45 a4             lea    -0x5c(%ebp),%eax 804936f:89 44 24 10          mov    %eax,0x10(%esp)                                                       // esp+16 = ebp - 928049373:8d 45 a0             lea    -0x60(%ebp),%eax8049376:89 44 24 0c          mov    %eax,0xc(%esp)                                                       // esp+12 = ebp- 96804937a:8d 45 9c             lea    -0x64(%ebp),%eax804937d:89 44 24 08          mov    %eax,0x8(%esp)                                                      // esp+8 = ebp -100                                      8049381:c7 44 24 04 b1 a4 04 movl   $0x804a4b1,0x4(%esp)                                      // GDB查看得 &quot;%d %d %s&quot;                                      // 表示需要如此输入，经提示，我们知道了在第四关以这样得格式输入。8049388:08 8049389:c7 04 24 d0 c4 04 08 movl   $0x804c4d0,(%esp)                                      // 得 &lt;input_strings + 240&gt; : &quot;6 6&quot; (有点熟悉)                                      8049390:e8 cb f4 ff ff       call   8048860 &lt;__isoc99_sscanf@plt&gt;8049395:83 f8 03             cmp    $0x3,%eax                                       // 如果返回的输入个数不等于三跳转至80493ce，否则顺序执行8049398:75 34                jne    80493ce &lt;phase_defused+0x7f&gt;804939a:c7 44 24 04 ba a4 04 movl   $0x804a4ba,0x4(%esp)                                      // 易知地址中为&quot;DrEvil&quot;                                      // 不会是进入的密码呢，再往下看看80493a1:08 80493a2:8d 45 a4             lea    -0x5c(%ebp),%eax80493a5:89 04 24             mov    %eax,(%esp) //esp=ebp-9280493a8:e8 15 fd ff ff       call   80490c2 &lt;strings_not_equal&gt;                                      // 字符比较80493ad:85 c0                test   %eax,%eax //应该是判断输入的字符是否为&quot;DrEvil&quot;80493af:75 1d                jne    80493ce &lt;phase_defused+0x7f&gt;80493b1:c7 04 24 80 a3 04 08 movl   $0x804a380,(%esp)                                       80493b8:e8 33 f4 ff ff       call   80487f0 &lt;puts@plt&gt;80493bd:c7 04 24 a8 a3 04 08 movl   $0x804a3a8,(%esp)80493c4:e8 27 f4 ff ff       call   80487f0 &lt;puts@plt&gt;80493c9:e8 cf fb ff ff       call   8048f9d &lt;secret_phase&gt;                                      //以上就是发现secret_phase需要进行得操作80493ce:c7 04 24 e0 a3 04 08 movl   $0x804a3e0,(%esp)80493d5:e8 16 f4 ff ff       call   80487f0 &lt;puts@plt&gt;80493da:8b 45 f4             mov    -0xc(%ebp),%eax80493dd:65 33 05 14 00 00 00 xor    %gs:0x14,%eax80493e4:74 05                je     80493eb &lt;phase_defused+0x9c&gt;80493e6:e8 d5 f3 ff ff       call   80487c0 &lt;__stack_chk_fail@plt&gt;80493eb:c9                   leave  80493ec:8d 74 26 00          lea    0x0(%esi,%eiz,1),%esi80493f0:c3                   ret    80493f1:66 90                xchg   %ax,%ax80493f3:66 90                xchg   %ax,%ax80493f5:66 90                xchg   %ax,%ax80493f7:66 90                xchg   %ax,%ax80493f9:66 90                xchg   %ax,%ax80493fb:66 90                xchg   %ax,%ax80493fd:66 90                xchg   %ax,%ax80493ff:90                   nop</code></pre></div><br>上面几个地址中存在的值如图<br><a href="https://imgtu.com/i/qvZAn1"><img src="https://s1.ax1x.com/2022/04/06/qvZAn1.png" alt="qvZAn1.png"></a></p><p>经分析可知，secret_phase的进入需要我们成功解除了前六个炸弹后并在第四关以”%d %d %s”的格式输入”6 6 DrEvil”。</p><div class="code-wrapper"><pre><code class="hljs text">08048f9d &lt;secret_phase&gt;: 8048f9d:55                   push   %ebp 8048f9e:89 e5                mov    %esp,%ebp 8048fa0:53                   push   %ebx 8048fa1:83 ec 14             sub    $0x14,%esp//开栈 8048fa4:e8 a8 02 00 00       call   8049251 &lt;read_line&gt; 8048fa9:c7 44 24 08 0a 00 00 movl   $0xa,0x8(%esp) //esp+8 = 10 8048fb0:00  8048fb1:c7 44 24 04 00 00 00 movl   $0x0,0x4(%esp) //esp+4=0 8048fb8:00  8048fb9:89 04 24             mov    %eax,(%esp)  8048fbc:e8 0f f9 ff ff       call   80488d0 &lt;strtol@plt&gt; 8048fc1:89 c3                mov    %eax,%ebx 8048fc3:8d 40 ff             lea    -0x1(%eax),%eax 8048fc6:3d e8 03 00 00       cmp    $0x3e8,%eax //if 0x3e8 &lt;= eax,跳转，否则爆炸 8048fcb:76 05                jbe    8048fd2 &lt;secret_phase+0x35&gt; 8048fcd:e8 05 02 00 00       call   80491d7 &lt;explode_bomb&gt; 8048fd2:89 5c 24 04          mov    %ebx,0x4(%esp)                                       //ebx中值为输入的参数 8048fd6:c7 04 24 88 c0 04 08 movl   $0x804c088,(%esp)                                       //进入递归的参数 8048fdd:e8 68 ff ff ff       call   8048f4a &lt;fun7&gt; 8048fe2:83 f8 05             cmp    $0x5,%eax  8048fe5:74 05                je     8048fec &lt;secret_phase+0x4f&gt; 8048fe7:e8 eb 01 00 00       call   80491d7 &lt;explode_bomb&gt;                                       //只有当递归的返回值等于5时，不引爆炸弹 8048fec:c7 04 24 20 a3 04 08 movl   $0x804a320,(%esp) 8048ff3:e8 f8 f7 ff ff       call   80487f0 &lt;puts@plt&gt; 8048ff8:e8 52 03 00 00       call   804934f &lt;phase_defused&gt; 8048ffd:83 c4 14             add    $0x14,%esp 8049000:5b                   pop    %ebx 8049001:5d                   pop    %ebp 8049002:c3                   ret     8049003:66 90                xchg   %ax,%ax 8049005:66 90                xchg   %ax,%ax 8049007:66 90                xchg   %ax,%ax 8049009:66 90                xchg   %ax,%ax 804900b:66 90                xchg   %ax,%ax 804900d:66 90                xchg   %ax,%ax 804900f:90                   nop</code></pre></div><p>分析得secret_phase需要我们输入一个值，该值与0x804c088中的值一起进入递归函数，需使得递归返回值 &#x3D; 5。  </p><p>分析Func7 ：</p> <div class="code-wrapper"><pre><code class="hljs text">08048f4a &lt;fun7&gt;: 8048f4a:55                   push   %ebp 8048f4b:89 e5                mov    %esp,%ebp 8048f4d:53                   push   %ebx 8048f4e:83 ec 14             sub    $0x14,%esp 8048f51:8b 55 08             mov    0x8(%ebp),%edx //最开始是0x804c088中的值，记作参数one 8048f54:8b 4d 0c             mov    0xc(%ebp),%ecx //最开始是我们需要的参数，记作参数two 8048f57:85 d2                test   %edx,%edx //edx为0 返回-1 8048f59:74 37                je     8048f92 &lt;fun7+0x48&gt;------------------ 8048f5b:8b 1a                mov    (%edx),%ebx //ebx = *edx 8048f5d:39 cb                cmp    %ecx,%ebx //if ecx &lt;= ebx 跳转 8048f5f:7e 13                jle    8048f74 &lt;fun7+0x2a&gt;  8048f61:89 4c 24 04          mov    %ecx,0x4(%esp) 8048f65:8b 42 04             mov    0x4(%edx),%eax 8048f68:89 04 24             mov    %eax,(%esp)//(edx+4, ecx)两个参数进入递归 8048f6b:e8 da ff ff ff       call   8048f4a &lt;fun7&gt; 8048f70:01 c0                add    %eax,%eax//返回值=递归返回值*2 8048f72:eb 23                jmp    8048f97 &lt;fun7+0x4d&gt; ------------------ 8048f74:b8 00 00 00 00       mov    $0x0,%eax //eax = 0 8048f79:39 cb                cmp    %ecx,%ebx  8048f7b:74 1a                je     8048f97 &lt;fun7+0x4d&gt;                                        //if ecx == ebx 结束递归 8048f7d:89 4c 24 04          mov    %ecx,0x4(%esp) 8048f81:8b 42 08             mov    0x8(%edx),%eax 8048f84:89 04 24             mov    %eax,(%esp) //(*(edx+8),ecx)两个参数进入递归 8048f87:e8 be ff ff ff       call   8048f4a &lt;fun7&gt; 8048f8c:8d 44 00 01          lea    0x1(%eax,%eax,1),%eax                                       // 返回值 = 递归返回值*2 + 1 8048f90:eb 05                jmp    8048f97 &lt;fun7+0x4d&gt;-------------------- 8048f92:b8 ff ff ff ff       mov    $0xffffffff,%eax 8048f97:83 c4 14             add    $0x14,%esp 8048f9a:5b                   pop    %ebx 8048f9b:5d                   pop    %ebp 8048f9c:c3                   ret</code></pre></div><p>进行一波困难的逆向得Func7的C语言代码:  </p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func7</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> b)</span>&#123;    <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">NULL</span>)      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (*a &gt; b)    <span class="hljs-keyword">if</span> (*a == b)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;      <span class="hljs-keyword">else</span>      &#123;        result = func7(*(a + <span class="hljs-number">8</span>), b);        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * result + <span class="hljs-number">1</span>;      &#125;    <span class="hljs-keyword">else</span>     &#123;      result = func7(*(a + <span class="hljs-number">4</span>), b);        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * result;    &#125;&#125;</code></pre></div><p>由于最后的返回值是5，根据函数的结构可以想到这样的结构：</p><blockquote><p>a * 2 + 1 &#x3D; 5 ————&gt; b * 2 &#x3D; a ————&gt; c * 2 + 1 &#x3D; b ————&gt; c &#x3D; 0  </p></blockquote><p>即*a、b的关系为  </p><blockquote><p>*a &lt; b ————&gt; *a &gt; b ————&gt; *a &lt; b————&gt; *a &#x3D;&#x3D; b</p></blockquote><p>所以一共递归</p><blockquote><p>*a – b &gt; 0<br>*a – b &lt; 0<br>*a – b &gt; 0<br>*a – b &#x3D;&#x3D; 0</p></blockquote><p>用GDB查看<code>0x804c088</code>后得到</p><ol><li><code>0x804c088 = 0x24</code>，之后在<code>*a - b &lt; 0 (0x24 – b &lt; 0)</code>的分支中<code>*(a + 8)= 0x804c090</code>，所以<code>func7(0x804c090, b)</code>。</li><li><code>*0x804c090 = 0x32</code>，<code>*a - b &gt; 0 (0x32 - b &gt; 0)</code>，递归<code>fun7(*(0x804c090 + 4) = 0x804c094, b)</code>。</li><li><code>*0x804c094 = 0x2d</code>，<code>*a - b &lt; 0 (0x2d - b &lt; 0)</code>，<code>fun7(*(0x804c094 + 8) = 0x804c09c, b)</code>。</li><li><code>*0x804c09c = 0x2f</code>，<code>*a – b == 0 (0x2f – b == 0)</code>，所以<code>b = 0x2f</code>，递归返回。</li></ol><p>得到3个不等式和一个等式：</p><ol><li><code>0x24 – 0x2f &lt; 0</code></li><li><code>0x32 – 0x2f &gt; 0</code></li><li><code>0x2d – 0x2f &lt; 0</code></li><li><code>b = 0x2f</code><br>转为十进制 b &#x3D; 47，故隐藏关卡密码为47。</li></ol><p>淦！！！！！！！  </p><p>以上是正常情况下应该得出理解答案的结果，但是事实并不如我想象。操作后并没有得到答案。但是答案确实是47。<br>通过不断的查找，发现存着47的地址在老后面了，完全不对啊。 淦，问题真多。</p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><a href="https://imgtu.com/i/qvVXmq"><img src="https://s1.ax1x.com/2022/04/06/qvVXmq.md.png" alt="qvVXmq.md.png"></a></p>]]></content>
    
    
    <categories>
      
      <category>实验记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
      <tag>计算机基础</tag>
      
      <tag>Csapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Github Actions 实现 Hexo 博客在 Github 上的自动部署</title>
    <link href="/2020/11/30/using-github-actions/"/>
    <url>/2020/11/30/using-github-actions/</url>
    
    <content type="html"><![CDATA[<p><strong>文档存在信息滞后，部分信息可能与实际不符</strong></p><p class="note note-primary">2022-06-28 更新：当前使用的 [自动部署配置文件](https://github.com/Muxiner/muxiner.github.io/blob/source/.github/workflows/acitons.yml)</p><hr><p>使用自动部署之前，我都是用的 <code>hexo deploy</code> 把每次生成的 <code>public</code> 文件夹上传到 github 上去，使用自动部署之后，就省略掉了这一步骤，但是多了这三步</p><blockquote><p>git add -A<br>git commit -m “imformaion”<br>git push</p></blockquote><p>看似并没有简化自己的操作，实际上好处很多  </p><ul><li>博客源码托管在 Github 的仓库，避免源码丢失的风险</li><li>Github 会记录每一次 <code>commit</code>，方便回溯</li><li>高逼格</li><li>……</li></ul><h3 id="关于自动化部署"><a href="#关于自动化部署" class="headerlink" title="关于自动化部署"></a>关于自动化部署</h3><p>百度词条中的<a href="https://baike.baidu.com/item/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/18750522"><u>自动化部署</u></a></p><p>以及 <code>CI/CD</code> —— CI&#x2F;CD 是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法。CI&#x2F;CD 的核心概念是持续集成、持续交付和持续部署。  </p><p><a href="https://github.com/features/actions"><code>github Actions</code></a> 是 <a href="https://github.com/"><code>GitHub</code></a> 的持续集成服务，于 2018 年 10 月推出。</p><p>还有一个类似的是 <a href="https://travis-ci.org/"><code>TravisCI</code></a>。  </p><p>我之前使用的就是 <code>TravisCI</code>，然后出了点小小的问题，其无法使用，然后一直配置不好，我就开始使用 <code>GitHub Actions</code>，而且有大佬说<code>觉得它非常强大，有创意，比 Travis CI 玩法更多。</code></p><p>不多介绍，就推荐几个大佬的文章</p><ul><li><a href="https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">GitHub Actions 入门教程</a></li><li><a href="https://blog.kaygb.com/210.html">基于 Github actions 自动部署 Hexo 博客</a></li><li><a href="https://xirikm.net/2020/313-1">使用 GitHub Actions 自动构建 Hexo 博客</a></li></ul><p>不多介绍了，直接说我怎么使用 <code>github actions</code> 的，主要 chao 了大佬的东西。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>需要一个 <code>GitHub</code> 帐号、一个 <code>GitHub Pages</code> 仓库、一个 <code>Hexo</code> 博客备份仓库&#x2F;分支。另外我们还需要获取一个 <code>GitHub Personal Access Token</code> 用来推送构建好的文件到我们的 <code>GitHub Pages</code> 仓库。具体的操作这里不再重复叙述，有需要了解的可以去看之前的文章。</p><p>点开博客备份仓库上方的 <code>Settings</code>，点到左侧的 <code>Secrets</code> 项，添加两个秘密环境变量 <code>GH_REF </code>、<code>GH_TOKEN</code>，值分别填写自己的 <code>GitHub Pages</code> 仓库地址（不包含 https:&#x2F;&#x2F; ）和刚刚申请到的 <code>GitHub Personal Access Token</code>。</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628220050.png"></p><h3 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h3><p>准备工作做好后就可以开始编写 <code>GitHub Actions</code> 配置文件了，这里对 Hexo 博客编译部署的步骤进行拆分讲解。</p><p>配置文件的目录——在站点目录下新建 <code>.github</code> 文件夹，再在其中新建文件夹 <code>workflows</code>，在创建 <code>×××××××.yml</code> 文件，命名随意。</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628220127.png"></p><h3 id="触发条件和运行环境"><a href="#触发条件和运行环境" class="headerlink" title="触发条件和运行环境"></a>触发条件和运行环境</h3><p>我们设置在 <code>master</code> 分支上发生 <code>push</code> 操作时触发构建，使用最新的 <code>Ubuntu</code> 系统作为编译部署的环境，同时设置一个全局环境变量将时区修改为 <code>Asia/Shanghai</code> (修改原因见 <a href="https://xirikm.net/2020/215-1.html)%EF%BC%8C%E5%85%B7%E4%BD%93%E7%9A%84%E9%85%8D%E7%BD%AE%E5%86%85%E5%AE%B9%E5%A6%82%E4%B8%8B%EF%BC%9A">https://xirikm.net/2020/215-1.html)，具体的配置内容如下：</a></p><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">Blog</span> <span class="hljs-string">CI/CD</span><span class="hljs-attr">on:</span>  <span class="hljs-attr">push:</span>    <span class="hljs-attr">branches:</span>       <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><span class="hljs-attr">env:</span>  <span class="hljs-attr">TZ:</span> <span class="hljs-string">Asia/Shanghai</span><span class="hljs-attr">jobs:</span>  <span class="hljs-attr">blog-cicd:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">blog</span> <span class="hljs-string">build</span> <span class="hljs-string">&amp;</span> <span class="hljs-string">deploy</span>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>    <span class="hljs-attr">steps:</span></code></pre></div><h3 id="建立工作环境"><a href="#建立工作环境" class="headerlink" title="建立工作环境"></a>建立工作环境</h3><p>上面的大前提确定后就可以来开始建立我们的工作环境了（注： 后续所有步骤的配置都是接在上面 <code>steps</code> 块下的，不要弄混了层级关系）。</p><p>首先检出代码，设置一下 <code>node</code> 环境，我们这里使用 <code>12.x</code> 版本的 <code>node.js</code>：</p><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">steps:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">codes</span>  <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">node</span>  <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v1</span>  <span class="hljs-attr">with:</span>    <span class="hljs-attr">node-version:</span> <span class="hljs-string">&#x27;12.x&#x27;</span></code></pre></div><p>然后设置一下缓存目录以避免每次都要重新下载，从而加快构建速度（官方不建议直接缓存 <code>node_modules</code> 目录，所以这里设置的是 <code>npm</code> 的下载缓存目录 <code>~/.npm</code> ，这样后面仍需要使用 <code>npm install</code> 来安装依赖）。这里使用的是 <code>package-lock.json</code> 文件的 <code>hash</code> 值来标识缓存是否可以命中：</p><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cache</span> <span class="hljs-string">node</span> <span class="hljs-string">modules</span>  <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v1</span>  <span class="hljs-attr">with:</span>    <span class="hljs-attr">path:</span> <span class="hljs-string">~/.npm</span>    <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">runner.os</span> <span class="hljs-string">&#125;&#125;-node-$&#123;&#123;</span> <span class="hljs-string">hashFiles(&#x27;**/package-lock.json&#x27;)</span> <span class="hljs-string">&#125;&#125;</span></code></pre></div><p>最后就是安装依赖了，这个根据自己的需要操作就行，由于我使用了 <code>gulp</code> 任务来压缩 <code>Hexo</code> 生成的文件，所以我这里除了 <code>hexo-cli</code> 还全局安装了<code>gulp</code>：</p><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">dependencies</span>  <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><span class="hljs-string">    npm install hexo-cli gulp -g</span><span class="hljs-string">    npm install</span></code></pre></div><h3 id="生成部署文件"><a href="#生成部署文件" class="headerlink" title="生成部署文件"></a>生成部署文件</h3><p>这一步简单点 <code>hexo g</code> 就行了，我这里多加了一步执行 gulp 任务的操作（将其放在两个 <code>step</code> 中而不是一次性执行是为了方便在日志中看到每个操作消耗的时间）：</p><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Generate</span> <span class="hljs-string">files</span>  <span class="hljs-attr">run:</span> <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Execute</span> <span class="hljs-string">gulp</span> <span class="hljs-string">task</span>  <span class="hljs-attr">run:</span> <span class="hljs-string">gulp</span></code></pre></div><h3 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h3><p>我们先将 <code>GitHub Pages</code> 仓库克隆过来，将其中的 <code>.git</code> 目录移到存放部署文件的 <code>public</code> 目录中（为了保留 <code>GitHub Pages</code> 仓库的提交历史），然后进入 <code>public</code> 目录设置一下提交用户名和邮箱，<code>add</code> 所有文件并提交，最后利用保存在秘密环境变量中的 <code>GitHub Personal Access Token</code> 推送到 <code>GitHub Pages</code> 仓库中就可以了：</p><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">blog</span>  <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><span class="hljs-string">    git clone &quot;https://$&#123;&#123; secrets.GH_REF &#125;&#125;&quot; deploy_git</span><span class="hljs-string">    mv ./deploy_git/.git ./public/</span><span class="hljs-string">    cd ./public</span><span class="hljs-string">    git config user.name &quot;yourname&quot;</span><span class="hljs-string">    git config user.email &quot;youremail&quot;</span><span class="hljs-string">    git add .</span><span class="hljs-string">    git commit -m &quot;GitHub Actions Auto Builder at $(date +&#x27;%Y-%m-%d %H:%M:%S&#x27;)&quot;</span><span class="hljs-string">    git push --force --quiet &quot;https://$&#123;&#123; secrets.GH_TOKEN &#125;&#125;@$&#123;&#123; secrets.GH_REF &#125;&#125;&quot; master:master</span></code></pre></div><h3 id="完整配置文件"><a href="#完整配置文件" class="headerlink" title="完整配置文件"></a>完整配置文件</h3><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">Blog</span> <span class="hljs-string">CI/CD</span><span class="hljs-attr">on:</span>  <span class="hljs-attr">push:</span>    <span class="hljs-attr">branches:</span>       <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><span class="hljs-attr">env:</span>  <span class="hljs-attr">TZ:</span> <span class="hljs-string">Asia/Shanghai</span><span class="hljs-attr">jobs:</span>  <span class="hljs-attr">blog-cicd:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">blog</span> <span class="hljs-string">build</span> <span class="hljs-string">&amp;</span> <span class="hljs-string">deploy</span>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>    <span class="hljs-attr">steps:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">codes</span>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">node</span>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v1</span>      <span class="hljs-attr">with:</span>        <span class="hljs-attr">node-version:</span> <span class="hljs-string">&#x27;12.x&#x27;</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cache</span> <span class="hljs-string">node</span> <span class="hljs-string">modules</span>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v1</span>      <span class="hljs-attr">with:</span>        <span class="hljs-attr">path:</span> <span class="hljs-string">~/.npm</span>        <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">runner.os</span> <span class="hljs-string">&#125;&#125;-node-$&#123;&#123;</span> <span class="hljs-string">hashFiles(&#x27;**/package-lock.json&#x27;)</span> <span class="hljs-string">&#125;&#125;</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">dependencies</span>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><span class="hljs-string">        npm install hexo-cli gulp -g</span><span class="hljs-string">        npm install</span><span class="hljs-string"></span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Generate</span> <span class="hljs-string">files</span>      <span class="hljs-attr">run:</span> <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Execute</span> <span class="hljs-string">gulp</span> <span class="hljs-string">task</span>      <span class="hljs-attr">run:</span> <span class="hljs-string">gulp</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">blog</span>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><span class="hljs-string">        git clone &quot;https://$&#123;&#123; secrets.GH_REF &#125;&#125;&quot; deploy_git</span><span class="hljs-string">        mv ./deploy_git/.git ./public/</span><span class="hljs-string">        cd ./public</span><span class="hljs-string">        git config user.name &quot;yourname&quot;</span><span class="hljs-string">        git config user.email &quot;youremail&quot;</span><span class="hljs-string">        git add .</span><span class="hljs-string">        git commit -m &quot;GitHub Actions Auto Builder at $(date +&#x27;%Y-%m-%d %H:%M:%S&#x27;)&quot;</span><span class="hljs-string">        git push --force --quiet &quot;https://$&#123;&#123; secrets.GH_TOKEN &#125;&#125;@$&#123;&#123; secrets.GH_REF &#125;&#125;&quot; master:master</span></code></pre></div><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://xirikm.net/2020/313-1"><u>使用 GitHub Actions 自动构建 Hexo 博客</u></a></li><li><a href="https://easyhexo.com/1-Hexo-install-and-config/1-5-continuous-integration.html#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90"><u>持续集成 Continuous Integration</u></a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
      <tag>Github</tag>
      
      <tag>CI/CD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git push 不用每次输入用户名和密码</title>
    <link href="/2020/11/24/git-password/"/>
    <url>/2020/11/24/git-password/</url>
    
    <content type="html"><![CDATA[<p><strong>本文仅供参考</strong></p><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>每次 <code>git push</code> 时都要输入用户名和密码，觉得很累。  就想只输入一次将用户名密码保存下来，避免每次都要重新输入。  </p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><div class="code-wrapper"><pre><code class="hljs git">git config --global credential.helper store</code></pre></div><div class="code-wrapper"><pre><code class="hljs git">git pull /git push # (这里需要输入用户名和密码，以后就不用啦)</code></pre></div><p>push你的代码 (git push), 这时会让你输入用户名和密码, 这一步输入的用户名密码会被记住, 下次再push代码时就不用输入用户名密码 ! 这一步会在用户目录下生成文件.<code>git-credential</code> 记录用户名密码的信息。</p><p>然后就可以了。</p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>emmm，使用方法之前，我需要输入两次用户名密码，使用后我只需要输入一次啦，这是一次巨大的”成功“。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://blog.csdn.net/LosingCarryJie/article/details/73801554">git不用每次输入用户名和密码</a></p>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统基础实验之datalab-handout</title>
    <link href="/2020/11/10/datalab-handout/"/>
    <url>/2020/11/10/datalab-handout/</url>
    
    <content type="html"><![CDATA[<h2 id="实验开始"><a href="#实验开始" class="headerlink" title="实验开始"></a>实验开始</h2><p>下载 <code>lab1-handout.tar</code></p><blockquote><p>(可由老师提供，或者在 <code>http://csapp.cs.cmu.edu/3e/labs.html</code> <a href="http://csapp.cs.cmu.edu/3e/labs.html">csapp</a>下载,获取方法是点击实验后面的 <code>Self-Study Handout</code>)，存放在下载目录</p></blockquote><span id="more"></span><p>点击左侧 <code>dock</code> 图标，键入 <code>term</code> ，打开终端</p><ul><li><code>cd ~</code>    进入主目录      键入 </li><li><code>ls</code> 查看是否有下载文件</li><li><code>tar vxf lab1-handout.tar</code>   解压代码框架  </li><li><code>cd lab1-handout</code></li><li><code>ls</code>    显示当前目录文件</li><li><code>make</code>   编译生成可执行文件</li><li><code>ls</code>  看看多了几个文件</li><li><code>./btest</code> 试试运行</li></ul><p>本实验是默认在 32 位机上进行测试。</p><h2 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h2><h3 id="1-bitBor函数"><a href="#1-bitBor函数" class="headerlink" title="1. bitBor函数"></a>1. bitBor函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><span class="hljs-comment"> * bitXor - x^y using only ~ and &amp; </span><span class="hljs-comment"> *   Example: bitXor(4, 5) = 1</span><span class="hljs-comment"> *   Legal ops: ~ &amp;</span><span class="hljs-comment"> *   Max ops: 14</span><span class="hljs-comment"> *   Rating: 1</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">bitXor</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;</code></pre></div><ul><li>使用 <code>~</code> 和 <code>&amp;</code> 实现 <code>x^y</code></li></ul><p>法1：  </p><ul><li>题意：用 <code>~</code> 和 <code>&amp;</code> 运算符实现 <code>Xor</code> 运算符</li><li>思路：我们知道 <code>Xor</code> 运算符是对每一个位，相同的话返回 <code>0</code> ，不同的话返回 <code>1</code> ，即 <code>((~x)&amp;y)|(x&amp;(~y))</code> 。但不能使用 <code>|</code> 运算，故采用德摩根律将或运算转为与运算。</li></ul><p>法2：</p><ul><li>利用《数字逻辑》的知识：异或运算 德摩根律<blockquote><p>x ^ y &#x3D; (x &amp; ~y) | (~x &amp; y)<br>&#x3D; ~((x &amp; ~y) | (~x &amp; y))<br>&#x3D; ~(~(x &amp; ~y) &amp; ~(~x &amp; y))  D</p></blockquote></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">bitXor</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;  <span class="hljs-keyword">return</span> ~(~(x &amp; ~y) &amp; ~(~x &amp; y));&#125;</code></pre></div><h3 id="2-tmim函数"><a href="#2-tmim函数" class="headerlink" title="2. tmim函数"></a>2. tmim函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><span class="hljs-comment"> * tmin - return minimum two&#x27;s complement integer </span><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><span class="hljs-comment"> *   Max ops: 4</span><span class="hljs-comment"> *   Rating: 1</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">tmin</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;</code></pre></div><ul><li>题意：输出反码下的最小值</li><li>思路：直接由定义得最小值</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">tmin</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>;&#125;</code></pre></div><h3 id="3-isTmax函数"><a href="#3-isTmax函数" class="headerlink" title="3. isTmax函数"></a>3. isTmax函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><span class="hljs-comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span><span class="hljs-comment"> *     and 0 otherwise </span><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | +</span><span class="hljs-comment"> *   Max ops: 10</span><span class="hljs-comment"> *   Rating: 1</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">isTmax</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;</code></pre></div><p>判断一个数是否为有符号数的最大值 <code>Tmax</code> ，即  </p><blockquote><p>0x7FFFFFFF   16进制<br>2147483647   10进制<br>0111 1111 1111 1111 1111 1111 1111 1111    2进制(32位系统)</p></blockquote><blockquote><p>Tmax满足:  Tmax &#x3D; ~(Tmax + 1)    Tmax ^ (~(Tmax + 1)) &#x3D; 0<br><code>0xFFFFFFFF</code> 也满足上述关系，但 <code>0xFFFFFFFF + 1</code> 为 <code>0</code>, 所以要排除这种情况。  </p></blockquote><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">inTmax</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;    <span class="hljs-keyword">return</span> !(x ^ ~(x + <span class="hljs-number">1</span>)) &amp; !!(x + <span class="hljs-number">1</span>); &#125;</code></pre></div><h3 id="4-allOddBits函数"><a href="#4-allOddBits函数" class="headerlink" title="4. allOddBits函数"></a>4. allOddBits函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><span class="hljs-comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span><span class="hljs-comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span><span class="hljs-comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><span class="hljs-comment"> *   Max ops: 12</span><span class="hljs-comment"> *   Rating: 2</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">allOddBits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;</code></pre></div><p>判断一个二进制数奇数位是否全为 <code>1</code><br>思路:<br>若 <code>x</code> 奇数位全为 <code>1</code>，则 <code>~x</code> 的奇数位全为 <code>0</code> ，则 <code>~x &amp; 0xaaaaaaaa</code> 使得全部为 <code>0</code>。</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">allOddBits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">return</span> !(~x &amp; <span class="hljs-number">0xaaaaaaaa</span>);&#125;</code></pre></div><h3 id="5-negate函数"><a href="#5-negate函数" class="headerlink" title="5. negate函数"></a>5. negate函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><span class="hljs-comment"> * negate - return -x </span><span class="hljs-comment"> *   Example: negate(1) = -1.</span><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><span class="hljs-comment"> *   Max ops: 5</span><span class="hljs-comment"> *   Rating: 2</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">negate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;</code></pre></div><p>求一个数的相反数。<br>思路: <code>-x = ~x + 1</code>  (取反加一)</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">negate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;  <span class="hljs-keyword">return</span> ~x + <span class="hljs-number">1</span>;&#125;</code></pre></div><h3 id="6-isAsciiDigit函数"><a href="#6-isAsciiDigit函数" class="headerlink" title="6. isAsciiDigit函数"></a>6. isAsciiDigit函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><span class="hljs-comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span><span class="hljs-comment"> *   Example: isAsciiDigit(0x35) = 1.</span><span class="hljs-comment"> *            isAsciiDigit(0x3a) = 0.</span><span class="hljs-comment"> *            isAsciiDigit(0x05) = 0.</span><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><span class="hljs-comment"> *   Max ops: 15</span><span class="hljs-comment"> *   Rating: 3</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">isAsciiDigit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;</code></pre></div><p>判断一个数字是否在 <code>0x30</code> 到 <code>0x39</code> 范围之内。<br>思路:<br>判断差值是否大于等于 <code>x - y &gt;= 0</code> 即 <code>取符号位且取逻辑反</code>  </p><blockquote><p>!(x + (<del>y + 1) &gt;&gt; 31)<br>x + (</del>y + 1) &gt;&gt; 31   取符号位</p></blockquote><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">isAsciiDigit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;  <span class="hljs-keyword">return</span> !(x + (~<span class="hljs-number">0x30</span> + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">31</span>) &amp; !(<span class="hljs-number">0x39</span> + (~x + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">31</span>);&#125;</code></pre></div><h3 id="7-conditional函数"><a href="#7-conditional函数" class="headerlink" title="7. conditional函数"></a>7. conditional函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><span class="hljs-comment"> * conditional - same as x ? y : z </span><span class="hljs-comment"> *   Example: conditional(2,4,5) = 4</span><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><span class="hljs-comment"> *   Max ops: 16</span><span class="hljs-comment"> *   Rating: 3</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">conditional</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;</code></pre></div><p>题意：实现一个三目运算符 <code>x ? y : z</code><br>思路：用 <code>!</code> 判断 <code>x</code> 的真假；<code>x ? y : z</code> 的关系转换为 <code>(a &amp; y) | (b &amp; z)</code> ，当 <code>x</code> 为 <code>0</code> 时，<code>a</code> 为 <code>0x0</code> ，<code>b</code> 为 <code>0xffffffff</code> ；当 <code>x</code> 非零时，<code>a</code> 为<code>0xffffffff</code> , <code>b</code> 为 <code>0x0</code> 。即  </p><blockquote><p>0x0 &amp; 0xaaa &#x3D; 0<br>0xffffffff &amp; 0xaaa &#x3D; 0xaaa   </p></blockquote><p>所以得使得 <code>a = !x + 0xffffffff</code> , <code>b = !!x + 0xffffffff</code> ，这样 <code>a</code> <code>b</code> 就会要么是 <code>0x0</code> <code>0xffffffff</code>。  </p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">conditional</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> &#123;  <span class="hljs-keyword">return</span> ((!x + <span class="hljs-number">0xffffffff</span>)&amp; y) | (z &amp; (!!x + <span class="hljs-number">0xffffffff</span>));&#125;</code></pre></div><h3 id="8-isLessOrEqual函数"><a href="#8-isLessOrEqual函数" class="headerlink" title="8. isLessOrEqual函数"></a>8. isLessOrEqual函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><span class="hljs-comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span><span class="hljs-comment"> *   Example: isLessOrEqual(4,5) = 1.</span><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><span class="hljs-comment"> *   Max ops: 24</span><span class="hljs-comment"> *   Rating: 3</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">isLessOrEqual</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;</code></pre></div><p>题意：若 <code>x &lt;= y</code> ，则返回 <code>1</code> ，反之返回 <code>0</code>。<br>思路：直接用 <code>y-x</code> 可能会超出 <code>int</code> 的表示范围，故而：</p><blockquote><p>1.在x与y同号的情况下转换为p&#x3D;y-x&gt;&#x3D;0，然后对p符号位进行(p&gt;&gt;31)&amp;1操作，符号位为0则返回1，符号位1则返回0；<br>2.x，y异号时，只要x&gt;&#x3D;0，就要返回0，否则返回1，由(x&gt;&gt;31)&amp;1能达到该效果；<br>3.c&#x3D;a+b可作为x，y同号异号的判断。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">isLessOrEqual</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;  <span class="hljs-type">int</span> sign_bit_x = x &gt;&gt; <span class="hljs-number">31</span>;  <span class="hljs-type">int</span> sign_bit_y = y &gt;&gt; <span class="hljs-number">31</span>;  <span class="hljs-type">int</span> sign_bit_xy = sign_bit_x + sign_bit_y;  <span class="hljs-type">int</span> sign_bit_subyx = ((y + ~x + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>;  <span class="hljs-keyword">return</span> (sign_bit_xy &amp; (sign_bit_x &amp; <span class="hljs-number">1</span>)) | ((~sign_bit_xy) &amp; !sign_bit_subyx);&#125;</code></pre></div><h3 id="9-logicalNeg函数"><a href="#9-logicalNeg函数" class="headerlink" title="9. logicalNeg函数"></a>9. logicalNeg函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><span class="hljs-comment"> * logicalNeg - implement the ! operator, using all of </span><span class="hljs-comment"> *              the legal operators except !</span><span class="hljs-comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span><span class="hljs-comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><span class="hljs-comment"> *   Max ops: 12</span><span class="hljs-comment"> *   Rating: 4 </span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">logicalNeg</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;</code></pre></div><p>题意：计算 <code>!x</code> ：当 <code>x = 0</code> 时返回 <code>1</code>；当 <code>x ≠ 0</code> 时返回 <code>0</code>。<br>思路：<code>0</code>和<code>Tmin</code>的补码都是其本身，而其他数的补码则是符号位相反。所以要区别<code>0</code>和<code>Tmin</code>的区别  </p><blockquote><p>0x0000 0000<br>0x8000 0000    </p></blockquote><p>即最高位不同，故用算数右移取符号位判断。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">logicalNeg</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;  <span class="hljs-keyword">return</span> ((~x &amp; ~(~x + <span class="hljs-number">1</span>)) &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>;&#125;</code></pre></div><h3 id="10-haoManyBits函数"><a href="#10-haoManyBits函数" class="headerlink" title="10. haoManyBits函数"></a>10. haoManyBits函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* howManyBits - return the minimum number of bits required to represent x in</span><span class="hljs-comment"> *             two&#x27;s complement</span><span class="hljs-comment"> *  Examples: howManyBits(12) = 5</span><span class="hljs-comment"> *            howManyBits(298) = 10</span><span class="hljs-comment"> *            howManyBits(-5) = 4</span><span class="hljs-comment"> *            howManyBits(0)  = 1</span><span class="hljs-comment"> *            howManyBits(-1) = 1</span><span class="hljs-comment"> *            howManyBits(0x80000000) = 32</span><span class="hljs-comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><span class="hljs-comment"> *  Max ops: 90</span><span class="hljs-comment"> *  Rating: 4</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">howManyBits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;</code></pre></div><p>题意：  给一个数字x,求出要表示出x需要的最少的位数。  </p><p>思路：  使用二分法。  </p><p> 若<code>x</code>是负数，那么对其取反，因为所需要的位数是一样的。  </p><blockquote><p>即  x &#x3D; (((x &gt;&gt; 31) &amp; <del>x) | ((</del>!(x &gt;&gt; 31) + 1) &amp; x)) </p></blockquote><p>然后是用二分法，先向右位移16位，即<code>half_x = x &gt;&gt; 16</code>，再判断<code>half_x</code>是否为<code>0</code>，即<code>!!half_x</code>。若为<code>0</code>，则<code>x</code>的最高位数为<code>16</code>；反之，其最低位数为<code>16</code>。依此类推，继续对其右移<code>8</code>、<code>4</code>、<code>2</code>、<code>1</code>位，得到<code>bit8</code>, <code>bit4</code>, <code>bit2</code>, <code>bit1</code>,分别表示一分为二后其中的一半是否存在，而另一半继续循环直至1，这时还剩下<code>x</code>，最后还需要再加上符号位<code>0</code>。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">howManyBits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;  x = (((x &gt;&gt; <span class="hljs-number">31</span>) &amp; ~x) | ((~!(x &gt;&gt; <span class="hljs-number">31</span>) + <span class="hljs-number">1</span>) &amp; x));  <span class="hljs-type">int</span> bit16, bit8, bit4, bit2, bit1;  <span class="hljs-type">int</span> half_x;    half_x = x &gt;&gt; <span class="hljs-number">16</span>;  bit16 = !!half_x &lt;&lt; <span class="hljs-number">4</span>;  x = x &gt;&gt; bit16;  half_x = x &gt;&gt; <span class="hljs-number">8</span>;  bit8 = !!half_x &lt;&lt; <span class="hljs-number">3</span>;  x = x &gt;&gt; bit8;  half_x = x &gt;&gt; <span class="hljs-number">4</span>;  bit4 = !!half_x &lt;&lt; <span class="hljs-number">2</span>;  x = x &gt;&gt; bit4;  half_x = x &gt;&gt; <span class="hljs-number">2</span>;  bit2 = !!half_x &lt;&lt; <span class="hljs-number">1</span>;  x = x &gt;&gt; bit2;  half_x = x &gt;&gt; <span class="hljs-number">1</span>;  bit1 = !!half_x &lt;&lt; <span class="hljs-number">0</span>;  x = x &gt;&gt; bit1;    <span class="hljs-keyword">return</span> bit16 + bit8 + bit4 + bit2 + bit1 + <span class="hljs-number">1</span> + x;&#125;</code></pre></div><h3 id="11-floatScale2函数"><a href="#11-floatScale2函数" class="headerlink" title="11. floatScale2函数"></a>11. floatScale2函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//float</span><span class="hljs-comment">/* </span><span class="hljs-comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span><span class="hljs-comment"> *   floating point argument f.</span><span class="hljs-comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span><span class="hljs-comment"> *   they are to be interpreted as the bit-level representation of</span><span class="hljs-comment"> *   single-precision floating point values.</span><span class="hljs-comment"> *   When argument is NaN, return argument</span><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><span class="hljs-comment"> *   Max ops: 30</span><span class="hljs-comment"> *   Rating: 4</span><span class="hljs-comment"> */</span><span class="hljs-type">unsigned</span> <span class="hljs-title function_">floatScale2</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> uf)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;  &#125;</code></pre></div><p>题意：  给出一个无符号整数<code>x</code>，将其看作一个浮点数，返回此数的两倍<code>x*2</code>。<br>思路： 取出符号<code>s</code>、阶码<code>exp</code>、尾数<code>frac</code>   </p><blockquote><p>sgn &#x3D; uf &amp; 0x80000000<br>exp &#x3D; uf &amp; 0x7F800000<br>frac &#x3D; uf &amp; 0x007FFFFF  </p></blockquote><p>若<code>exp</code>为0，则是非规格，直接左移。<br>若<code>exp</code>不是<code>0x7F80 0000</code>，即有效，则直接阶码加一。 </p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-title function_">floatScale2</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> uf)</span> &#123;  <span class="hljs-type">unsigned</span> f = uf;  <span class="hljs-type">unsigned</span> sgn = uf &amp; <span class="hljs-number">0x80000000</span>;<span class="hljs-comment">//符号位</span>  <span class="hljs-type">unsigned</span> <span class="hljs-built_in">exp</span> = uf &amp; <span class="hljs-number">0x7F800000</span>;<span class="hljs-comment">//阶码</span>  <span class="hljs-type">unsigned</span> frac = uf &amp; <span class="hljs-number">0x007FFFFF</span>;<span class="hljs-comment">//位数</span>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span> == <span class="hljs-number">0</span>)      f = (frac &lt;&lt; <span class="hljs-number">1</span>) | sgn;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span> != <span class="hljs-number">0x7F800000</span>)      f = f + <span class="hljs-number">0x00800000</span>;<span class="hljs-comment">//阶码+1</span>  <span class="hljs-keyword">return</span> f;   &#125;</code></pre></div><h3 id="12-floatFloat2Int函数"><a href="#12-floatFloat2Int函数" class="headerlink" title="12. floatFloat2Int函数"></a>12. floatFloat2Int函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><span class="hljs-comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span><span class="hljs-comment"> *   for floating point argument f.</span><span class="hljs-comment"> *   Argument is passed as unsigned int, but</span><span class="hljs-comment"> *   it is to be interpreted as the bit-level representation of a</span><span class="hljs-comment"> *   single-precision floating point value.</span><span class="hljs-comment"> *   Anything out of range (including NaN and infinity) should return</span><span class="hljs-comment"> *   0x80000000u.</span><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><span class="hljs-comment"> *   Max ops: 30</span><span class="hljs-comment"> *   Rating: 4</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">floatFloat2Int</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> uf)</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;</code></pre></div><p>题意：给出一个无符号整数x，将其看作一个浮点数，实现一个(int)x的功能。  </p><p>思路：</p><p>主要是思考上下界溢出的问题。</p><p>下界溢出的临界是<code>bin(x) = 0 0111 1111 0000 0000 0000 0000 0000 000</code>，此时<code>s = 0</code>，<code>exp = 127</code>，<code>frac = 0</code>。表示的数字刚好是<code>1.0</code>。小于这个数直接返回<code>0</code>。</p><p>上界溢出的条件是<code>bin(x) = 0 1001 1101 0000 0000 0000 0000 0000 000</code>，此时<code>s = 0</code>，<code>exp = 127 + 31</code>，<code>frac = 0</code>。表示的数是<code>1.0*2**32</code>，也就是<code>TMax</code>，大于这个数就直接返回<code>TMax</code>。</p><p>其他数字考虑<code>exp = 127 + 23</code>这个临界。如果大于这个数，需要将<code>frac</code>右移。如果小于这个数，需要将<code>frac</code>左移。   </p><p>法一：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">floatFloat2Int</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> uf)</span>&#123;  <span class="hljs-type">int</span> s = (uf &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>;  <span class="hljs-type">int</span> <span class="hljs-built_in">exp</span> = ((uf &gt;&gt; <span class="hljs-number">23</span>) &amp; <span class="hljs-number">0xFF</span>) - <span class="hljs-number">127</span>; <span class="hljs-comment">//exp的真实值</span>  <span class="hljs-type">int</span> frac = (uf &amp; <span class="hljs-number">0x007FFFFF</span>) | <span class="hljs-number">0x00800000</span>;  <span class="hljs-type">int</span> tar = <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span> (s) s = <span class="hljs-number">-1</span>;  <span class="hljs-keyword">else</span> s = <span class="hljs-number">1</span>;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span> &gt; <span class="hljs-number">31</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0x80000000</span>;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span> &lt; <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span> &gt; <span class="hljs-number">23</span>)    tar = s * (frac &lt;&lt; (<span class="hljs-built_in">exp</span> - <span class="hljs-number">23</span>));  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span> &lt; <span class="hljs-number">23</span>)    tar = s * (frac &gt;&gt; (<span class="hljs-number">23</span> - <span class="hljs-built_in">exp</span>));  <span class="hljs-keyword">return</span> tar;&#125;</code></pre></div><p>法二：  </p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">floatFloat2Int</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> uf)</span> &#123;    <span class="hljs-type">unsigned</span> INF = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>;   <span class="hljs-comment">// INF = MaxInt+1</span>    <span class="hljs-type">int</span> e = (uf&gt;&gt;<span class="hljs-number">23</span>) &amp; <span class="hljs-number">0xff</span>;<span class="hljs-comment">// 阶码</span>    <span class="hljs-type">int</span> s = (uf&gt;&gt;<span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>;   <span class="hljs-comment">// 符号位</span>    <span class="hljs-keyword">if</span> (uf == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    uf &lt;&lt;= <span class="hljs-number">8</span>;       <span class="hljs-comment">// 左移保留至阶码最后1位</span>    uf |= <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>;    <span class="hljs-comment">// 阶码最后一位设为1</span>    uf &gt;&gt;= <span class="hljs-number">8</span>;       <span class="hljs-comment">// 高八位全0</span>    e -= <span class="hljs-number">127</span>;       <span class="hljs-comment">// 阶数</span>    <span class="hljs-keyword">if</span> ((uf &amp; <span class="hljs-number">0x7f80000</span>) == <span class="hljs-number">0x7f80000</span> || e &gt;= <span class="hljs-number">32</span>)        <span class="hljs-keyword">return</span> INF; <span class="hljs-comment">// 超过int范围返回INF</span>    <span class="hljs-keyword">if</span> (e &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 小数返回0</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (e &lt;= <span class="hljs-number">22</span>) <span class="hljs-comment">// 位数小于等于22位，尾数位右移</span>        uf &gt;&gt;= <span class="hljs-number">23</span>-e;    <span class="hljs-keyword">else</span>         uf &lt;&lt;= e<span class="hljs-number">-23</span>; <span class="hljs-comment">// 尾数大于22位，尾数为左移</span>    <span class="hljs-keyword">if</span> (s)         uf = ~uf + <span class="hljs-number">1</span>;<span class="hljs-comment">// 若原uf为负数，则对此处的正数uf取反加1得其相反数</span>    <span class="hljs-keyword">return</span> uf;&#125;</code></pre></div><h3 id="13-floatPower2函数"><a href="#13-floatPower2函数" class="headerlink" title="13. floatPower2函数"></a>13. floatPower2函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><span class="hljs-comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span><span class="hljs-comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *   The unsigned value that is returned should have the identical bit</span><span class="hljs-comment"> *   representation as the single-precision floating-point number 2.0^x.</span><span class="hljs-comment"> *   If the result is too small to be represented as a denorm, return</span><span class="hljs-comment"> *   0. If too large, return +INF.</span><span class="hljs-comment"> * </span><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span><span class="hljs-comment"> *   Max ops: 30 </span><span class="hljs-comment"> *   Rating: 4</span><span class="hljs-comment"> */</span><span class="hljs-type">unsigned</span> <span class="hljs-title function_">floatPower2</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;</code></pre></div><p>题意：  给出一个无符号整数x，将其看作一个浮点数，返回2**x。   </p><p>思路：  先得到阶码<code>exp = x + 127</code>，然后考虑临界值：  </p><p><code>bin(x) = 0 00000000 00000000000000000000001</code>，此数是<code>2**((-126)+(-23))</code>,<br>即<code>exp = 0</code>时情况；  </p><p><code>bin(x) = 0 00000001 00000000000000000000000</code>，此数是<code>2**(-126)</code>，<br>即<code>exp = 23</code>时情况；</p><p><code>bin(x) = 0 11111111 00000000000000000000000</code> ，此数是<code>2**(128)</code>，<br>即<code>exp = 255</code>时情况。</p><p>代码一：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-title function_">floatPower2</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;  <span class="hljs-type">int</span> <span class="hljs-built_in">exp</span> = x + <span class="hljs-number">0x7f</span>;                          <span class="hljs-comment">// x + 127</span>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span> &lt; <span class="hljs-number">0</span>)   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">exp</span> &lt; <span class="hljs-number">0xff</span> ? <span class="hljs-built_in">exp</span> &lt;&lt; <span class="hljs-number">23</span> : <span class="hljs-number">0x7f800000</span>;  <span class="hljs-comment">//0xff = 255</span>&#125;</code></pre></div><p>代码二：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-title function_">floatPower2</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;    <span class="hljs-type">unsigned</span> INF = <span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">23</span>; <span class="hljs-comment">// 阶码全1</span>    <span class="hljs-type">int</span> e = <span class="hljs-number">127</span> + x;    <span class="hljs-comment">// 得到阶码</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span> &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 阶数小于0直接返回0</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (e &gt;= <span class="hljs-number">255</span>) <span class="hljs-comment">// 阶码&gt;=255直接返回INF</span>        <span class="hljs-keyword">return</span> INF;    <span class="hljs-keyword">return</span> e &lt;&lt; <span class="hljs-number">23</span>;    <span class="hljs-comment">// 直接将阶码左移23位，尾数全0，规格化时尾数隐藏有1个1作为底数</span>&#125;</code></pre></div><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><a href="https://imgtu.com/i/qvVsYD"><img src="https://s1.ax1x.com/2022/04/06/qvVsYD.png" alt="qvVsYD.png"></a></p><h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>不愧是计算机系统的实验，实验内容和系统基础知识紧密联系，所接触到的不再是10进制数的计算，而是二进制及其反码补码，十六进制的计算，也不再仅仅是算术运算而更多的是逻辑、位的运算。由于知识储备的限制，一开始进行试验的时候实在是无从下手，思路上也受到了极大的限制，加之对于反码补码、有符号数无符号数、逻辑运算符、位运算符等等之类掌握的不深切，就觉得实验真的很难，当然本次实验的难度确实很大，实验内容也仅是datalab-handout的一部分，对其研究个八九不离十，十分有利与我对计算机系统学习，同时也要做好学习记录，以便日后回忆。  </p><p>tip：<br>  这篇博客会在后续继续完善（在自己更加明白时），目前内容仅供参考。</p>]]></content>
    
    
    <categories>
      
      <category>实验记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
      <tag>Csapp</tag>
      
      <tag>计算机系统</tag>
      
      <tag>位计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
